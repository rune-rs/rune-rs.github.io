<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rune Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rune Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<blockquote>
<p>"Why am I making a programming language?"</p>
</blockquote>
<p>This question keeps rolling around in my head as I'm typing out the code that is
slowly shaping into <em>Rune</em>. Programming is like magic. You imagine it in your
mind, write it out, and there it is. Doing <em>stuff</em> which wasn't being done
before.</p>
<p>Truth be told, I'm scared that people will tell me that I'm wasting my time.
This has already been done, or "Why not just use X?". A thing so glaringly
obvious that all of my efforts are wasted.</p>
<p>But you actually don't need a reason. It can simply be for The <a href="https://en.wikipedia.org/wiki/The_Joy_of_Painting">Joy of
Creating</a>, and then it's just you. Spending your own time. No harm done.</p>
<p>But I want to talk about why I'm making Rune beyond just for fun. So I'm
dedicating this foreword to it. I feel obligated to describe why this might
matter to others.</p>
<p>So here's why I'm making a new programming language.</p>
<p>I've spent a lot of effort working on <a href="https://github.com/udoprog/OxidizeBot">OxidizeBot</a>, a Twitch bot that streamers
can use to add commands and other interactive things in their chat. I built it
for myself while streaming. When adding features I always spend way too much time
tinkering with it. Making it as generic as possible so it can solve more than
just one problem. When it's a personal project, I don't care about being
efficient. I care much more about doing things the right way.</p>
<p>...</p>
<p>Ok, I <em>sometimes</em> do that professionally as well. But a working environment is
much more constrained. Personal projects should be fun!</p>
<p>Anyway, that means the bot isn't overly specialized to only suit my needs and
can be used by others. It's starting to see a little bit of that use now which
is a lot of fun. I made something which helps people do something cool.</p>
<p>All the commands in the bot are written in <a href="https://rust-lang.org">Rust</a>, and <a href="https://github.com/udoprog/OxidizeBot/tree/main/bot/src/module">compiled straight into
the bot</a>. This is nice because Rust is an incredible language. But Rust is also
complex. Not needlessly mind you. I believe it's complex because it
tackles <em>really hard problems</em>. And that usually comes with a <a href="https://en.wikipedia.org/wiki/Waterbed_theory">base level of
complexity</a> it's very hard to get rid of.</p>
<p>But it's still tricky enough that streamers who have limited programming
experience struggle getting up and running. I wanted them to be able to write
their own commands. Ones they could just drop into a folder and <em>presto</em> -
you're up and running.</p>
<blockquote>
<p>To this day I've tutored two of these streamers who were interested in
learning Rust to write their own commands.</p>
</blockquote>
<p>Embedding a Rust compiler isn't feasible. So I started looking into dynamic
programming languages. Ones that could be embedded into an existing application
with little to no effort. That seamlessly integrates with its environment.
A number of candidates came up, but the one that stood out the most to me was
<a href="https://github.com/jonathandturner/rhai">Rhai</a>.</p>
<p>So why is Rhai awesome? It has Rust-like syntax. The runtime is fully written in
mostly safe Rust, and can be easily embedded. Hooking up Rust functions is a
piece of cake.</p>
<p>But Rhai has a set of design decisions which didn't <em>exactly</em> scratch my itch.
The more I used it, the more I got inspired and started thinking about things
that could be changed or added. <a href="https://github.com/jonathandturner/rhai/commits?author=udoprog">I contributed a bit to the project</a>. And it
started to dawn on me that Rhai's approach wasn't exactly what I wanted. There's
nothing wrong with this. The authors of Rhai have specific goals and ideas of
what they want to accomplish. While it would be feasible to push Rhai in a
different direction, the project would emerge looking much different on the
other side. Which wouldn't be fair towards the people leveraging Rhai's
strengths today. So I wanted a clean slate to find my own compromises. To
discover freely what works and doesn't work well.</p>
<p>When I started working on Rune I had the following <em>rough</em> goals in mind:</p>
<ul>
<li>Performance should be comparable to Lua and Python (And eventually LuaJIT when
we have cranelift).</li>
<li>Scripts should compile quickly.</li>
<li>Rune should feel like "Rust without types".</li>
<li>Excellent support for asynchronous programming (i.e. native <code>select</code> statements).</li>
<li>Be as good as Rhai when it comes to integrating with native Rust.</li>
<li>Work well through C bindings.</li>
<li>A minimalistic stack-based runtime that is strictly single threaded*.</li>
</ul>
<blockquote>
<p>*: If this feels like a step backwards to you, don't worry too much. We can
still have concurrency and threading using async code as you'll see later in
this book.</p>
</blockquote>
<p>Rune is now in a state where I want people to poke at it. Not <em>too</em> hard mind
you. It's still early days. The compiler is very much in flux and a
miscompilation will definitely cause the wrong closure to be called. You know,
the one that <em>doesn't</em> perform your security checks üòÖ.</p>
<p>But the more poking and prodding people do, the more issues will be found. Every
solved issue brings Rune one step close to being production ready. Every set of
eyeballs that takes a look can bring fresh perspective and ideas, making the
project better for me and everyone else.</p>
<p>I really want to thank Jonathan Turner and all the contributors to the Rhai
project. They have been an an immense inspiration to me.</p>
<p>You can find the project <a href="https://github.com/rune-rs/rune/">on its GitHub page</a>. I hope you'll enjoy using
it as much as I've enjoyed making it!</p>
<p>‚Äî John-John Tedro</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome the <em>The Rune Programming Language</em>, a reference guide that will
familiarize yourself with Rune.</p>
<p>Rune is an open source embeddable dynamic programming language that compiles and
runs on a virtual machine called Runestick (thanks Brendan).</p>
<p>The goal of Rune is to reimagine Rust as a dynamic programming language. Trying
to mimic as many concepts as possible, and remixing the ones which do not
translate directly. We do this by using the same syntax as Rust. But a few
additions are inevitable because certain things are just done differently when
you have a dynamic environment.</p>
<p>I also concede that a number of program correctness features you get through
static typing will be sorely lacking. The tradeoff you get for this are fast
compilation times and <em>duck typing</em>, sometimes leading to more concise and
compact code. <a href="https://python.org">Python</a> is a great example of this, and is along with <a href="https://github.com/jonathandturner/rhai">Rhai</a> and
<a href="http://www.lua.org/">Lua</a> biggest inspirations for this project.</p>
<p>To read this book, you will definitely want to go to <a href="https://github.com/rune-rs/rune/">the GitHub project</a> and
grab yourself a clone of it. All the examples are in there, and it's highly
recommended that you run and tinker them yourself as you encounter them.</p>
<p>With that out of the way, let's get started. We have a bit to go through.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>The first thing you need to learn about in Rune is the <code>dbg</code> function. This is
used to "debug" values provided to it in order to understand them. Anything can
be provided to it, and it will do its best to describe it.</p>
<pre><code class="language-rune">fn function() {
    42
}

let a = [1, 2, 3];
let b = '‰ªä';
let closure = || println!("Hello");

dbg!(a);
dbg!(b);
dbg!(function);
dbg!(drop);
dbg!(closure);
</code></pre>
<blockquote>
<p><strong>Note</strong>: by convention Rune uses files ending in .rn.</p>
</blockquote>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/getting_started/dbg.rn
[1, 2, 3]
'‰ªä'
dynamic function (at: 0x1a)
native function (0x1bd03b8ee40)
dynamic function (at: 0x17)
</code></pre>
<p>The default <code>dbg</code> implementation outputs information on its arguments to stdout.
But its exact behavior can differ depending on how the environment is
configured. When Rune is embedded into a larger application it might for example
be more suitable to output to a log file.</p>
<p>Rune also provides <code>print!</code> and <code>println!</code> macros which can be used to format
directly to stdout, but these cannot be relied on to be present to the same
degree as <code>dbg</code>. However for our purposes we will be using <code>rune-cli</code>, which has
all of these modules installed. This is also what was used to run the above
code.</p>
<p>So for a more formal introduction, here is the official Rune <code>"Hello World"</code>:</p>
<pre><code class="language-rune">println!("Hello World");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/getting_started/hello_world.rn
Hello World
</code></pre>
<p>So now you know how to run Rune scripts. Well done! Let's move on to the next
chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>This chapter covers common concepts that appear in almost all programming
languages, and how they work in Rune.</p>
<p>Hopefully these should be familiar to anyone who's used imperative programming
languages before. We'll try to take each concept and describe how they work with
examples, one at a time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="items-and-imports"><a class="header" href="#items-and-imports">Items and imports</a></h1>
<p>Everything in Rune has a unique name. Every function, type, and import. This
name is what identifies that thing, and is called its <em>item</em>. Rune performs
compile time checks to make sure that every item we try to use actually exists.</p>
<p>The following are examples of items in Rune:</p>
<ul>
<li><code>std::result::Result</code> (a type)</li>
<li><code>std::iter::range</code> (a function)</li>
</ul>
<p>The first refers to the <code>Result</code> enum, and the second is the <code>range</code> function.
They both live within their corresponding <code>std</code> module. <code>Result</code> is a bit
special even, since it's part of the <em>prelude</em>, allowing us to use it without
importing it. But what about <code>range</code>?</p>
<p>If we wanted to use <code>range</code> we would have to import it first with a <code>use</code>
statement:</p>
<pre><code class="language-rune">use std::iter::once;

let it = once(0);

dbg!(it.next());
dbg!(it.next());
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/items_imports/example_import.rn
std::iter::Range
</code></pre>
<p>Trying to use an item which doesn't exist results in a compile error:</p>
<pre><code class="language-rune">pub fn main() {
    let foo = Foo::new();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/items_imports/missing_item.rn.fail
error: compile error
  ‚îå‚îÄ scripts/book/items_imports/missing_item.rn.fail:2:15
  ‚îÇ
2 ‚îÇ     let foo = Foo::new();
  ‚îÇ               ^^^^^^^^ missing item `Foo::new`
</code></pre>
<p>Every item used in a Rune program must be known at compile time. This is one of
the static guarantees every Rune script are has to fulfill. And is one important
point where it differs from Lua or Python.</p>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Rune has support for modules purely defined in Rune itself. This is done using
the <code>mod</code> keyword. And the module can either be loaded from a different file
matching the name of the module or defined directly inside of the source file.</p>
<p>The following is an example of an <em>inline</em> module:</p>
<pre><code class="language-rune">mod foo {
    pub fn number() {
        1
    }
}

mod bar {
    pub fn number() {
        2
    }
}

pub fn main() {
    dbg!(foo::number() + bar::number());
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/items_imports/inline_modules.rn
3
</code></pre>
<p>And this is the equivalent modules loaded from the filesystem. These are three
separate files:</p>
<pre><code class="language-rune">mod foo;
mod bar;

dbg!(foo::number() + bar::number());
</code></pre>
<pre><code class="language-rune">// file: ./foo/mod.rn
pub fn number() {
    2
}
</code></pre>
<pre><code class="language-rune">// file: ./bar.rn
pub fn number() {
    1
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/items_imports/modules.rn
3
</code></pre>
<h1 id="disambiguating-imports"><a class="header" href="#disambiguating-imports">Disambiguating imports</a></h1>
<p>Normally an item would simply be used through its local name, such as
<code>foo::number</code> above. But what happens if we need to reference a module which is
not a direct descendent of the current one or there is some ambiguation?</p>
<p>To this end Rune supports the following Rust keywords:</p>
<ul>
<li><code>self</code> - which will resolve items from the root of the <em>current</em> module.</li>
<li><code>crate</code> - which will look up items from the entrypoint of the current project.</li>
<li><code>super</code> - which will look up items from the <em>parent</em> of the current module.</li>
</ul>
<pre><code class="language-rune">mod first {
    pub fn number() {
        crate::number() + 2
    }
}

mod second {
    pub fn number() {
        super::first::number() + 4
    }
}

pub fn number() {
    1
}

dbg!(self::second::number());
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/items_imports/item_keywords.rn
7
</code></pre>
<h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Every item used has to be <em>visible</em> to that item. This is governed by Runes
visibility rules, which are the following:</p>
<ul>
<li>An item can have inherited (empty) or a specified visibility like <code>pub</code> or
<code>pub(crate)</code>.</li>
<li>For an item to be visible, all of its parent items have to be visible.</li>
<li>Items with inherited visibility are equivalent to <code>pub(self)</code>, making the item
only visible in the module in which they are defined.</li>
</ul>
<p>The available visibility modifiers are:</p>
<ul>
<li><code>pub</code> - the item is visible from anywhere.</li>
<li><code>pub(crate)</code> - the item is visible in the same crate.</li>
<li><code>pub(super)</code> - the item is visible in the parent item only.</li>
<li><code>pub(self)</code> - the item is only visible to other items in the same module.</li>
<li><code>pub(in path)</code> - the item is only visible in the specified path. This is <em>not
supported yet</em>.</li>
</ul>
<blockquote>
<p>Note that Rune doesn't have support for crates yet, meaning <code>pub(crate)</code> and
<code>pub</code> are currently effectively equivalent.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>One of the most common things in all of programming are functions. These are
stored procedures which take a arguments, do some work, and then return.
Functions are used because they encapsulate what they do so that the programmer
only needs to concern itself with the protocol of the function.</p>
<p>What does it do? What kind of arguments does it take? The alternative would be
to copy the code around and that wouldn't be very modular. Functions instead
provide a modular piece of code that can be called and re-used. Over and over
again.</p>
<h2 id="fn-keyword"><a class="header" href="#fn-keyword"><code>fn</code> keyword</a></h2>
<p>In Rune, functions are declared with the <code>fn</code> keyword. You've already seen one
which is used in every example, <code>main</code>. This is not a special function, but is
simply what the Rune cli looks for when deciding what to execute.</p>
<pre><code class="language-rune">pub fn main() {
    println!("Hello World");
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/functions/main_function.rn
Hello World
</code></pre>
<p>In Rune, you don't have to specify the return type of a function. Given that
Rune is a dynamic programming language, this allows a function to return
anything, even completely distinct types.</p>
<pre><code class="language-rune">fn foo(condition) {
    if condition {
        "Hello"
    } else {
        1
    }
}

pub fn main() {
    println!("{}", foo(true));
    println!("{}", foo(false));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/functions/return_value.rn
Hello
1
</code></pre>
<p>Depending on who you talk to, this is either the best thing since sliced bread
or quite scary. It allows for a larger ability to express a program, but at the
same time it can be harder to reason on what your program will do.</p>
<h2 id="calling-functions-in-rust"><a class="header" href="#calling-functions-in-rust">Calling functions in Rust</a></h2>
<p>Rune functions can be easily set up and called from Rust.</p>
<pre><code class="language-rust noplaypen">use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Diagnostics, Vm};

use std::sync::Arc;

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let context = rune_modules::default_context()?;

    let mut sources = rune::sources!(
        entry =&gt; {
            pub fn main(number) {
                number + 10
            }
        }
    );

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let mut vm = Vm::new(Arc::new(context.runtime()?), Arc::new(unit));
    let output = vm.execute(["main"], (33i64,))?.complete().into_result()?;
    let output: i64 = rune::from_value(output)?;

    println!("output: {}", output);
    Ok(())
}</code></pre>
<pre><code class="language-text">$&gt; cargo run --example minimal
output: 43
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Rune supports a number of control flow expressions. We will be dedicating this
section to describe the most common ones.</p>
<h2 id="return-expression"><a class="header" href="#return-expression"><code>return</code> expression</a></h2>
<p>In the previous section we talked about functions. And one of the primary things
a function does is return things. The <code>return</code> expression allows for returning
from the current function. If used without an argument, the function will return
a unit <code>()</code>.</p>
<p>The last statement in a function is known as an <em>implicit return</em>, and will be
what the function returns by default unless a <code>return</code> is specified.</p>
<pre><code class="language-rune">fn foo(n) {
    if n &lt; 1 {
        return "less than one";
    }

    "something else"
}

println!("{}", foo(0)); // =&gt; outputs: "less than one"
println!("{}", foo(10)); // =&gt; outputs: "something else"
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/control_flow/numbers_game.rn
less than one
something else
</code></pre>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> expressions</a></h2>
<p>If expressions allow you to provide a condition with one or more code branches.
If the condition is <code>true</code>, the provided block of code will run.</p>
<pre><code class="language-rune">let number = 3;

if number &lt; 5 {
    println!("The number is smaller than 5");
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/control_flow/conditional.rn
The number *is* smaller than 5
</code></pre>
<p>Optionally, we can add another branch under <code>else</code>, which will execute in case
the condition is false.</p>
<pre><code class="language-rune">let number = 3;

if number &lt; 5 {
    println!("the number is smaller than 5");
} else {
    println!("the number is 5 or bigger");
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/control_flow/conditional_else.rn
the number is smaller than 5
</code></pre>
<p>We can also add an arbitrary number of <code>else if</code> branches, which allow us to
specify many different conditions.</p>
<pre><code class="language-rune">let number = 3;

if number &lt; 5 {
    println!("the number is smaller than 5");
} else if number == 5 {
    println!("the number is exactly 5");
} else {
    println!("the number is bigger than 5");
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/control_flow/conditional_else_ifs.rn
the number is smaller than 5
</code></pre>
<p>Do note however that if you have <em>many</em> conditions, it might be cleaner to use
a <code>match</code>.</p>
<p>This will be covered in a later section, but here is a sneak peek:</p>
<pre><code class="language-rune">let number = 3;

match number {
    n if n &lt; 5 =&gt; {
        println!("the number is smaller than 5");
    }
    5 =&gt; {
        println!("the number is exactly 5");
    }
    n =&gt; {
        println!("the number is bigger than 5");
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/control_flow/first_match.rn
the number is smaller than 5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-memory"><a class="header" href="#variables-and-memory">Variables and memory</a></h1>
<p>Variables in Rune are defined using the <code>let</code> keyword. In contrast to Rust, all
variables in Rune are mutable and can be changed at any time.</p>
<pre><code class="language-rune">pub fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/variables/variables.rn
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Rune is a memory safe language. Regardless of what you write in a Rune script,
we maintain the same memory safety guarantees as safe Rust. This is accomplished
through reference counting.</p>
<p><a href="5_1_primitives.html">Unless a value is <code>Copy</code></a>, they are reference counted and
can be used at multiple locations. This means that they have <em>shared ownership</em>.
Every variable that points to that value therefore points to <em>the same instance</em>
of that value. You can think of every nontrivial value being automatically
wrapped in an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> if that helps you out.</p>
<blockquote>
<p>This is not exactly what's going on. If you're interested to learn more, Rune
uses a container called <a href="https://docs.rs/rune/0/rune/struct.Shared.html"><code>Shared&lt;T&gt;</code></a> which is <em>like</em> an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>, but
has a few more tricks.</p>
</blockquote>
<p>We can see how this works by sharing and mutating one object across two
variables:</p>
<pre><code class="language-rune">pub fn main() {
    let object = #{ field: 1 };
    let object2 = object;
    println!("{}", object.field);
    object2.field = 2;

    // Note: we changed `object2`, but read out `object`
    println!("{}", object.field);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/variables/shared_ownership.rn
1
2
</code></pre>
<p>This can cause issues if we call an external function which expects to take
ownership of its arguments. We say that functions like these <em>move</em> their
argument, and if we try to use a variable which has been moved an error will be
raised in the virtual machine.</p>
<blockquote>
<p>Note: Below we use the <code>drop</code> function, which is a built-in function that will
take its argument and free it.</p>
</blockquote>
<pre><code class="language-rune">pub fn main() {
    let object = #{ field: 1 };
    let object2 = object;
    println!("field: {}", object.field);
    drop(object2);
    println!("field: {}", object.field);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/variables/take_argument.rn
field: 1
== ! (cannot read, value is moved (at 14)) (469¬µs)
error: virtual machine error
  ‚îå‚îÄ scripts/book/variables/take_argument.rn:6:27
  ‚îÇ
6 ‚îÇ     println!("field: {}", object.field);
  ‚îÇ                           ^^^^^^^^^^^^ cannot read, value is moved
</code></pre>
<p>If you need to, you can test if a variable is still accessible for reading with
<code>is_readable</code>, and for writing with <code>is_writable</code>. These are both imported in
the prelude. An object which is writable is also <em>movable</em>, and can be provided
to functions which need to move the value, like <code>drop</code>.</p>
<pre><code class="language-rune">pub fn main() {
    let object = #{ field: 1 };
    let object2 = object;
    println!("field: {}", object.field);
    drop(object2);

    if is_readable(object) {
        println!("field: {}", object.field);
    } else {
        println!("object is no longer readable üò¢");
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/variables/is_readable.rn
field: 1
object is no longer readable üò¢
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>Loops are a fundamental building block common to many programming languages.
This is no exception in Rune.
Loops allow you to execute a block of code until a specific condition is
reached, which can be a powerful tool for accomplishing programming tasks.</p>
<h2 id="break-keyword"><a class="header" href="#break-keyword"><code>break</code> Keyword</a></h2>
<p>Every loop documented in this section can be <em>terminated early</em> using the
<code>break</code> keyword.</p>
<p>When Rune encounters a break, it will immediately jump out of the loop it is
currently in and continue running right after it.</p>
<pre><code class="language-rune">let value = 0;

while value &lt; 100 {
    if value &gt;= 50 {
        break;
    }

    value = value + 1;
}

println!("The value is {}", value); // =&gt; The value is 50
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/loops/while_loop.rn
The value is 50
</code></pre>
<h2 id="loop-expressions"><a class="header" href="#loop-expressions"><code>loop</code> Expressions</a></h2>
<p>The <code>loop</code> keyword builds the most fundamental form of loop in Rune.
One that repeats unconditionally forever, until it is exited using another
control flow operator like a <code>break</code> or a <code>return</code>.</p>
<pre><code class="language-rune">use time::Duration;

loop {
    println!("Hello forever!");
    time::sleep(Duration::from_secs(1)).await;
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/loops/loop_forever.rn
Hello forever!
Hello forever!
Hello forever!
...
</code></pre>
<blockquote>
<p>Hint: If you want this one to end, you're gonna have to kill it with <code>CTRL+C</code>.</p>
</blockquote>
<p>We're also using an asynchronous function called <code>sleep</code> above to avoid spamming
our terminals too much. Well talk more about these in a later section.</p>
<p>When broken out of, loops produce the value provided as an argument to the
<code>break</code> keyword. By default, this is simply a unit <code>()</code>.</p>
<pre><code class="language-rune">let counter = 0;

let total = loop {
    counter = counter + 1;

    if counter &gt; 10 {
        break counter;
    }
};

println!("The final count is: {}", total);
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/loops/loop_break.rn
The final count is: 11
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h1>
<p>In this section we will be discussing <em>Pattern Matching</em>.</p>
<p>Pattern matching is a flexible mechanism that allows for validating the
structure and type of the argument, while also destructuring it to give easy
access to what you need.</p>
<p>Below are some examples of its common uses to match on branch conditions:</p>
<pre><code class="language-rune">fn match_input(n) {
    match n {
        1 =&gt; println!("The number one."),
        n if n is i64 =&gt; println!("Another number: {}.", n),
        [1, 2, n, ..] =&gt; println!("A vector starting with one and two, followed by {}.", n),
        "one" =&gt; println!("One, but this time as a string."),
        _ =&gt; println!("Something else. Can I go eat now?"),
    }
}

match_input(1);
match_input(2);
match_input([1, 2, 42, 84]);
match_input("one");
match_input(#{ field: 42 });
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/pattern_matching/big_match.rn
The number one.
Another number: 2.
A vector starting with one and two, followed by 42.
One, but this time as a string.
Something else. Can I go eat now?
</code></pre>
<p>We will be covering each of these variants in detail in the coming sections.</p>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<p>Things that can be matched over are called <em>patterns</em>, and there's a fairly
large number of them. In this section we'll try to document the most common
ones.</p>
<p>Patterns that can be matched over are the following:</p>
<ul>
<li>A unit, simply <code>()</code>.</li>
<li>A boolean value, like <code>true</code> or <code>false</code>.</li>
<li>A byte, like <code>b'a'</code> or <code>b'\x10'</code>.</li>
<li>A character, like <code>'a'</code> or <code>'„ÅÇ'</code>.</li>
<li>An integer, like <code>42</code>.</li>
<li>A string, like <code>"Steven Universe"</code>.</li>
<li>A vector, like the numbers <code>[1, _, ..]</code>, or simply the empty vector <code>[]</code>. The
values in the vectors are patterns themselves.</li>
<li>A tuple, like <code>("Steven Universe", _, 42)</code>. The values in the tuple are
patterns themselves.</li>
<li>An object, like the numbers <code>{"name": "Steven Universe", "age": _}</code>, or the
empty <code>{}</code>. The values in the object are patterns themselves.</li>
</ul>
<p>Structs can be matched over by prefixing the match with their name:</p>
<ul>
<li>A unit struct: <code>Foo</code>.</li>
<li>A tuple struct: <code>Foo(1, _)</code>.</li>
<li>An object struct: <code>Foo { bar: 1, .. }</code>.</li>
</ul>
<p>Similarly, variants in an enum can be matched over as well in the same way:</p>
<ul>
<li>A unit variant: <code>Foo::Variant</code>.</li>
<li>A tuple variant: <code>Foo::Variant(1, _)</code>.</li>
<li>An object variant: <code>Foo::Variant { bar: 1, .. }</code>.</li>
</ul>
<p>Patterns can be almost <em>any</em> combination of the above. Even <code>{"items": ["Sword", "Bow", "Axe"]}</code> is a pattern that can be matched over.</p>
<p>Anything that qualifies as a collection can have <code>..</code> as a suffix to match the
case that there are extra fields or values which are not covered in the pattern.
This is called a <em>rest pattern</em>.</p>
<pre><code class="language-rune">let value = #{ a: 0, b: 1 };

let matched = match value {
    // this doesn't match, because a pattern without a rest pattern in it
    // must match exactly.
    #{ a } =&gt; false,
    // this matches, because it only requires `a` to be present.
    #{ a, .. } =&gt; true,
};

assert!(matched, "rest pattern matched");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/pattern_matching/rest_pattern.rn
</code></pre>
<h2 id="binding-and-ignoring"><a class="header" href="#binding-and-ignoring">Binding and ignoring</a></h2>
<p>In a pattern, every value can be replaced with a <em>binding</em> or an <em>ignore
pattern</em>. The ignore pattern is a single underscore <code>_</code>, which informs Rune that
it should ignore that value, causing it to match unconditionally regardless of
what it is.</p>
<pre><code class="language-rune">fn test_ignore(vector) {
    match vector {
        [_, 2] =&gt; println!("Second item in vector is 2."),
    }
}

test_ignore([1, 2]);
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/pattern_matching/ignore.rn
Second item in vector is 2.
</code></pre>
<p>In contrast to ignoring, we can also <em>bind</em> the value to a variable that is then
in scope of the match arm. This will also match the value unconditionally, but
give us access to it in the match arm.</p>
<pre><code class="language-rune">fn test_ignore(vector) {
    match vector {
        [_, b] =&gt; println!("Second item in vector is {}.", b),
    }
}

test_ignore([1, 2]);
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/pattern_matching/bind.rn
Second item in vector is 2.
</code></pre>
<p>Here are some more examples:</p>
<ul>
<li><code>[_, a, b]</code> which will ignore the first value in the vector, but then bind the
second and third as <code>a</code> and <code>b</code>.</li>
<li><code>{"name": name}</code> will bind the value <code>name</code> out of the specified object.</li>
</ul>
<pre><code class="language-rune">fn describe_car(car) {
    match car {
        #{ "make": year, .. } if year &lt; 1950 =&gt; "What, where did you get that?",
        #{ "model": "Ford", "make": year, .. } if year &gt;= 2000 =&gt; "Pretty fast!",
        _ =&gt; "Can't tell üòû",
    }
}

println!("{}", describe_car(#{"model": "Ford", "make": 2000}));
println!("{}", describe_car(#{"model": "Honda", "make": 1980}));
println!("{}", describe_car(#{"model": "Volvo", "make": 1910}));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/pattern_matching/fast_cars.rn
Pretty fast!
Can't tell üòû
What, where did you get that?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-literals"><a class="header" href="#template-literals">Template literals</a></h1>
<p>If you've been paying attention on previous sections you might have seen odd
looking strings like <code>`Hello ${name}`</code>. These are called <em>template
literals</em>, and allow you to conveniently build strings using variables from the
environment.</p>
<blockquote>
<p>Template literals are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">a concept borrowed from EcmaScript</a>.</p>
</blockquote>
<pre><code class="language-rune">let age = 30;
dbg!(`I am ${age} years old!`);
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/template_literals/basic_template.rn
"I am 30 years old!"
</code></pre>
<p>Template strings are accelerated by the Vm, each argument uses a <em>display
protocol</em> and it can be very efficient to build complex strings out of it.</p>
<h2 id="the-display_fmt-protocol"><a class="header" href="#the-display_fmt-protocol">The <code>DISPLAY_FMT</code> protocol</a></h2>
<p>The <code>DISPLAY_FMT</code> protocol is a function that can be implemented by any
<em>external</em> type which allows it to be used in a template string.</p>
<p>It expects a function with the signature <code>fn(&amp;self, buf: &amp;mut String) -&gt; fmt::Result</code>.</p>
<pre><code class="language-rust noplaypen">use rune::{ContextError, Module};
use rune::runtime::{Protocol, Formatter};
use std::fmt::Write as _;
use std::fmt;

#[derive(Debug)]
pub struct StatusCode {
    inner: u32,
}

impl StatusCode {
    #[rune::function(protocol = DISPLAY_FMT)]
    fn display_fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "{}", self.inner)
    }
}

pub fn module() -&gt; Result&lt;Module, ContextError&gt; {
    let mut module = Module::new(["http"]);
    module.function_meta(StatusCode::display_fmt)?;
    Ok(module)
}</code></pre>
<p>This is what allows status codes to be formatted into template strings, any
types which do not implement this protocol will fail to run.</p>
<pre><code class="language-rune">let vec = [1, 2, 3];
dbg!(`${vec}`);
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/template_literals/not_a_template.rn
== ! (`Vec` does not implement the `display_fmt` protocol (at 5)) (77.7¬µs)
error: virtual machine error
  ‚îå‚îÄ scripts/book/template_literals/not_a_template.rn:3:9
  ‚îÇ
3 ‚îÇ     dbg!(`${vec}`);
  ‚îÇ          ^^^^^^^^ `Vec` does not implement the `display_fmt` protocol
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instance-functions"><a class="header" href="#instance-functions">Instance functions</a></h1>
<p>Instance functions are functions that are associated to a specific type of
variable. When called they take the form <code>value.foo()</code>, where the <em>instance</em>
is the first part <code>value</code>. And the <em>instance function</em> is <code>foo()</code>.</p>
<p>These are a bit special in Rune. Since Rune is a dynamic programming language we
can't tell at compile time which instance any specific <code>value</code> can be. So
instance functions must be looked up at runtime.</p>
<pre><code class="language-rune">struct Foo;

impl Foo {
    fn new() {
        Foo
    }
}

let foo = Foo::new();
foo.bar();
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/instance_functions/missing_instance_fn.rn
error: virtual machine error
   ‚îå‚îÄ scripts/book/instance_functions/missing_instance_fn.rn:11:5
   ‚îÇ
11 ‚îÇ     foo.bar();
   ‚îÇ     ^^^^^^^^^ missing instance function `0xfb67fa086988a22d` for `type(0xc153807c3ddc98d7)``
</code></pre>
<blockquote>
<p>Note: The error is currently a bit nondescript. But in the future we will be
able to provide better diagnostics by adding debug information.</p>
</blockquote>
<p>What you're seeing above are type and function hashes. These uniquely identify
the item in the virtual machine and is the result of a deterministic computation
based on its item. So the hash for the item <code>Foo::new</code> will always be the same.</p>
<p>In Rust, we can calculate this hash using the <code>Hash::type_hash</code> method:</p>
<pre><code class="language-rune">use rune::{Hash, ItemBuf};

fn main() -&gt; rune::support::Result&lt;()&gt; {
    println!("{}", Hash::type_hash(&amp;ItemBuf::with_item(["Foo", "new"])?));
    println!("{}", Hash::type_hash(["Foo", "new"]));
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example function_hash
0xb5dc92ab43cb37d9
0xb5dc92ab43cb37d9
</code></pre>
<p>The exact implementation of the hash function is currently not defined, but will
be stabilized and documented in a future release.</p>
<h2 id="defining-instance-functions-in-rust"><a class="header" href="#defining-instance-functions-in-rust">Defining instance functions in Rust</a></h2>
<p>Native instance functions are added to a runtime environment using the
<a href="https://docs.rs/rune/0/rune/struct.Module.html#method.associated_function"><code>Module::associated_function</code></a> function. The type is identified as the first
argument of the instance function, and must be a type registered in the module
using <a href="https://docs.rs/rune/0/rune/struct.Module.html#method.ty"><code>Module::ty</code></a>.</p>
<pre><code class="language-rust noplaypen">use rune::termcolor::{ColorChoice, StandardStream};
use rune::{ContextError, Diagnostics, Module, Vm};

use std::sync::Arc;

#[rune::function(instance)]
fn divide_by_three(value: i64) -&gt; i64 {
    value / 3
}

#[tokio::main]
async fn main() -&gt; rune::support::Result&lt;()&gt; {
    let m = module()?;

    let mut context = rune_modules::default_context()?;
    context.install(m)?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources!(entry =&gt; {
        pub fn main(number) {
            number.divide_by_three()
        }
    });

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let mut vm = Vm::new(runtime, Arc::new(unit));
    let output = vm.execute(["main"], (33i64,))?.complete().into_result()?;
    let output: i64 = rune::from_value(output)?;

    println!("output: {}", output);
    Ok(())
}

fn module() -&gt; Result&lt;Module, ContextError&gt; {
    let mut m = Module::with_item(["mymodule"])?;
    m.function_meta(divide_by_three)?;
    Ok(m)
}</code></pre>
<pre><code class="language-text">$&gt; cargo run --example custom_instance_fn
output: 11
</code></pre>
<p>For more examples on how modules can be used you can have a look at the source
for the <a href="https://github.com/rune-rs/rune/tree/main/crates/rune-modules"><code>rune-modules</code></a> crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-functions"><a class="header" href="#field-functions">Field functions</a></h1>
<p>Field functions are special operations which operate on fields. These are
distinct from associated functions, because they are invoked by using the
operation associated with the kind of the field function.</p>
<p>The most common forms of fields functions are <em>getters</em> and <em>setters</em>, which are
defined through the <a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.GET"><code>Protocol::GET</code></a> and <a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.SET"><code>Protocol::SET</code></a> protocols.</p>
<p>The <code>Any</code> derive can also generate default implementations of these through
various <code>#[rune(...)]</code> attributes:</p>
<pre><code class="language-rust noplaypen">#[derive(Any)]
struct External {
    #[rune(get, set, add_assign, copy)]
    number: i64,
    #[rune(get, set)]
    string: String,
}</code></pre>
<p>Once registered, this allows <code>External</code> to be used like this in Rune:</p>
<pre><code class="language-rune">pub fn main(external) {
    external.number = external.number + 1;
    external.number += 1;
    external.string = `${external.string} World`;
}
</code></pre>
<p>The full list of available field functions and their corresponding attributes
are:</p>
<div class="table-wrapper"><table><thead><tr><th>Protocol</th><th>Attribute</th><th></th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.GET"><code>Protocol::GET</code></a></td><td><code>#[rune(get)]</code></td><td>For getters, like <code>external.field</code>.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.SET"><code>Protocol::SET</code></a></td><td><code>#[rune(set)]</code></td><td>For setters, like <code>external.field = 42</code>.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.ADD_ASSIGN"><code>Protocol::ADD_ASSIGN</code></a></td><td><code>#[rune(add_assign)]</code></td><td>The <code>+=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.SUB_ASSIGN"><code>Protocol::SUB_ASSIGN</code></a></td><td><code>#[rune(sub_assign)]</code></td><td>The <code>-=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.MUL_ASSIGN"><code>Protocol::MUL_ASSIGN</code></a></td><td><code>#[rune(mul_assign)]</code></td><td>The <code>*=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.DIV_ASSIGN"><code>Protocol::DIV_ASSIGN</code></a></td><td><code>#[rune(div_assign)]</code></td><td>The <code>/=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.BIT_AND_ASSIGN"><code>Protocol::BIT_AND_ASSIGN</code></a></td><td><code>#[rune(bit_and_assign)]</code></td><td>The <code>&amp;=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.BIT_OR_ASSIGN"><code>Protocol::BIT_OR_ASSIGN</code></a></td><td><code>#[rune(bit_or_assign)]</code></td><td>The bitwise or operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.BIT_XOR_ASSIGN"><code>Protocol::BIT_XOR_ASSIGN</code></a></td><td><code>#[rune(bit_xor_assign)]</code></td><td>The <code>^=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.SHL_ASSIGN"><code>Protocol::SHL_ASSIGN</code></a></td><td><code>#[rune(shl_assign)]</code></td><td>The <code>&lt;&lt;=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.SHR_ASSIGN"><code>Protocol::SHR_ASSIGN</code></a></td><td><code>#[rune(shr_assign)]</code></td><td>The <code>&gt;&gt;=</code> operation.</td></tr>
<tr><td><a href="https://docs.rs/rune/0/rune/runtime/struct.Protocol.html#associatedconstant.REM_ASSIGN"><code>Protocol::REM_ASSIGN</code></a></td><td><code>#[rune(rem_assign)]</code></td><td>The <code>%=</code> operation.</td></tr>
</tbody></table>
</div>
<p>The manual way to register these functions is to use the new <code>Module::field_function</code>
function. This clearly showcases that there's no relationship between the field
used and the function registered:</p>
<pre><code class="language-rust noplaypen">use rune::{Any, Module};
use rune::runtime::Protocol;

#[derive(Any)]
struct External {
}

impl External {
    fn field_get(&amp;self) -&gt; String {
        String::from("Hello World")
    }
}

let mut module = Module::new();
module.field_function(&amp;Protocol::GET, "field", External::field_get)?;</code></pre>
<p>Would allow for this in Rune:</p>
<pre><code class="language-rune">pub fn main(external) {
    println!("{}", external.field);
}
</code></pre>
<h2 id="customizing-how-fields-are-cloned-with-runeget"><a class="header" href="#customizing-how-fields-are-cloned-with-runeget">Customizing how fields are cloned with <code>#[rune(get)]</code></a></h2>
<p>In order to return a value through <code>#[rune(get)]</code>, the value has to be cloned.</p>
<p>By default, this is done through the <a href="https://docs.rs/rune/0/rune/alloc/clone/trait.TryClone.html"><code>TryClone</code> trait</a>, but its behavior can be
customized through the following attributes:</p>
<h4 id="runecopy"><a class="header" href="#runecopy"><code>#[rune(copy)]</code></a></h4>
<p>This indicates that the field is <code>Copy</code>.</p>
<h4 id="runeclone"><a class="header" href="#runeclone"><code>#[rune(clone)]</code></a></h4>
<p>This indicates that the field should use <code>std::clone::Clone</code> to clone the value.
Note that this effecitvely means that the memory the value uses during cloning
is <em>not</em> tracked and should be avoided in favor of using <a href="https://docs.rs/rune/0/rune/alloc/"><code>rune::alloc</code></a> and the
<a href="https://docs.rs/rune/0/rune/alloc/clone/trait.TryClone.html"><code>TryClone</code> trait</a> without good reason.</p>
<h4 id="runeclone_with--path"><a class="header" href="#runeclone_with--path"><code>#[rune(clone_with = &lt;path&gt;)]</code></a></h4>
<p>This specified a custom method that should be used to clone the value.</p>
<pre><code class="language-rust noplaypen">use rune::Any;

use std::sync::Arc;

#[derive(Any)]
struct External {
    #[rune(get, clone_with = Thing::clone)]
    field: Thing,
}

#[derive(Any, Clone)]
struct Thing {
    name: Arc&lt;String&gt;,
}</code></pre>
<h4 id="runetry_clone_with--path"><a class="header" href="#runetry_clone_with--path"><code>#[rune(try_clone_with = &lt;path&gt;)]</code></a></h4>
<p>This specified a custom method that should be used to clone the value.</p>
<pre><code class="language-rust noplaypen">use rune::Any;
use rune::prelude::*;

#[derive(Any)]
struct External {
    #[rune(get, try_clone_with = String::try_clone)]
    field: String,
}</code></pre>
<h2 id="custom-field-function"><a class="header" href="#custom-field-function">Custom field function</a></h2>
<p>Using the <code>Any</code> derive, you can specify a custom field function by using an
argument to the corresponding attribute pointing to the function to use instead.</p>
<p>The following uses an implementation of <code>add_assign</code> which performs checked
addition:</p>
<pre><code class="language-rust noplaypen">use rune::runtime::{VmError, VmResult};
use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Any, ContextError, Diagnostics, Module, Vm};

use std::sync::Arc;

#[derive(Any)]
struct External {
    #[rune(add_assign = External::value_add_assign)]
    value: i64,
}

#[allow(clippy::unnecessary_lazy_evaluations)]
impl External {
    fn value_add_assign(&amp;mut self, other: i64) -&gt; VmResult&lt;()&gt; {
        self.value = rune::vm_try!(self.value.checked_add(other).ok_or_else(VmError::overflow));
        VmResult::Ok(())
    }
}

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let m = module()?;

    let mut context = rune_modules::default_context()?;
    context.install(m)?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            pub fn main(e) {
                e.value += 1;
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let mut vm = Vm::new(runtime, Arc::new(unit));

    let input = External { value: i64::MAX };
    let err = vm.call(["main"], (input,)).unwrap_err();
    println!("{:?}", err);
    Ok(())
}

fn module() -&gt; Result&lt;Module, ContextError&gt; {
    let mut m = Module::new();
    m.ty::&lt;External&gt;()?;
    Ok(m)
}</code></pre>
<pre><code class="language-text">$&gt; cargo run --example checked_add_assign
Error: numerical overflow (at inst 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Traits in rune defines a collection associated items. Once a trait is
implemented by a type we can be sure that all the associated names it defines
are present on the type.</p>
<p>Traits allow us to reason about types more abstractly, such as this is an
iterator.</p>
<h4 id="limits"><a class="header" href="#limits">Limits</a></h4>
<p>As usual, Rune doesn't permit more than one definition of an associated name.
Attempting to define more than one with the same name results in a build-time
error. This is in contrast to Rust which allows multiple traits with overlapping
methods to be defined. So why doesn't Rune allow for this?</p>
<p>Since Rune is a dynamic language, consider what would happen in a situation like
this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    /* .. */
}

impl Iterator for Foo {
    fn next(self) {
        /* .. */
    }
}

impl OtherIterator for Foo {
    fn next(self) {
        /* .. */
    }
}

let foo = Foo {
    /* .. */
};

// Which implementation of `next` should we call?
while let Some(value) = foo.next() {

}
<span class="boring">}</span></code></pre></pre>
<p>Since there are no type parameters we can't solve the ambiguity by either only
having one trait defining the method in scope or by using an unambigious
function qualified function call.</p>
<h4 id="implementation"><a class="header" href="#implementation">Implementation</a></h4>
<p>In the background the user-facing implementation of traits is done by
implementing protocols just before. Protocols are still used by the virtual
machine to call functions.</p>
<p>The separation that protocols provide is important because we don't want a user
to <em>accidentally</em> implement an associated method which would then be picked up
by a trait. Protocols are uniquely defined in their own namespace and cannot be
invoked in user code.</p>
<p>As an example, to implement the <code>Iterator</code> trait you have to implement the
<code>NEXT</code> protocol. So if the <code>NEXT</code> protocol is present and we request that the
<code>::std::iter::Iterator</code> trait should be implemented, the <code>NEXT</code> protocol
implementation is used to construct all the relevant associated methods. This is
done by calling <code>Module::implement_trait</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut m = Module::with_item(["module"]);
m.ty::&lt;Iter&gt;()?;
m.function_meta(Iter::next__meta)?;
m.function_meta(Iter::size_hint__meta)?;
m.implement_trait::&lt;Iter&gt;(rune::item!(::std::iter::Iterator))?;

#[derive(Any)]
#[rune(item = "module")]
struct Iter {
    /* .. */
}

impl Iter {
    #[rune::function(keep, protocol = NEXT)]
    fn size_hint(&amp;self) -&gt; Option&lt;bool&gt; {
        Some(true)
    }

    #[rune::function(keep, protocol = SIZE_HINT)]
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (1, None)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that this allows the <code>Iter</code> type above to specialize its <code>SIZE_HINT</code>
implementation. If the <code>SIZE_HINT</code> protocol was not defined, a default
implementation would be provided by the trait.</p>
<p>As a result of implementing the <code>::std::iter::Iterator</code> trait, the <code>Iter</code> type
now <em>automatically</em> gets all the iterator-associated function added to it. So
not only can you call <code>Iter::next</code> to advance the iterator, but also make use of
combinators such as <code>filter</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let it = /* construct Iter */;

for value in it.filter(|v| v != true) {
    dbg!(value);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="defining-a-trait"><a class="header" href="#defining-a-trait">Defining a trait</a></h4>
<p>Defining a trait is currently a low-level module operation. It's done by
implementing a handler which will be called to populate the relevant methods
when the trait is implement. Such as this snippet for the <code>Iterator</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut m = Module::with_crate("std", ["iter"]);

let mut t = m.define_trait(["Iterator"])?;

t.handler(|cx| {
    let next = cx.find(&amp;Protocol::NEXT)?;

    let size_hint = cx.find_or_define(&amp;Protocol::SIZE_HINT, |_: Value| (0usize, None::&lt;usize&gt;))?;

    /* more methods */
    Ok(())
})?;
<span class="boring">}</span></code></pre></pre>
<p>Calling <code>find</code> requires that <code>NEXT</code> is implemented. We can also see that the
implementation for <code>SIZE_HINT</code> will fall back to a default implementation if
it's not implemented. The appropriate protocol is also populated if it's
missing. All the relevant associated functions are also provided, such as
<code>value.next()</code> and <code>value.size_hint()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rune-types"><a class="header" href="#rune-types">Rune types</a></h1>
<p>Types in Rune are identified uniquely by their <em>item</em>. An item path is a
scope-separated identifier, like <code>std::f64</code>. This particular item identifies
a type.</p>
<p>These items can be used to perform basic type checking using the <code>is</code> and <code>is not</code> operations, like this:</p>
<pre><code class="language-rune">assert!(() is Tuple, "tuples should be tuples");
assert!((1, 2) is Tuple, "tuples should be tuples");
assert!(true is bool, "bools should be bools");
assert!('a' is char, "chars should be chars");
assert!(b'a' is u64, "bytes should be unsigned integers");
assert!(42 is i64, "integers should be integers");
assert!(42.1 is f64, "floats should be floats");
assert!("hello" is String, "strings should be strings");
assert!("x" is not char, "strings are not chars");
assert!(#{"hello": "world"} is Object, "objects should be objects");
assert!(["hello", "world"] is Vec, "vectors should be vectors");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/types/types.rn
</code></pre>
<p>Conversely, the type check would fail if you're providing a value which is not
of that type.</p>
<pre><code class="language-rune">assert!(["hello", "world"] is String, "vectors should be strings");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/types/bad_type_check.rn
== ! (panicked `assertion failed: vectors should be strings` (at 12)) (133.3¬µs)
error: virtual machine error
  ‚îå‚îÄ scripts/book/types/bad_type_check.rn:2:5
  ‚îÇ
2 ‚îÇ     assert!(["hello", "world"] is String, "vectors should be strings");
  ‚îÇ     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ panicked `assertion failed: vectors should be strings`
</code></pre>
<p>This gives us insight at runtime which type is which, and allows Rune scripts to
make decisions depending on what type a value has.</p>
<pre><code class="language-rune">fn dynamic_type(n) {
    if n is String {
        "n is a String"
    } else if n is Vec {
        "n is a vector"
    } else {
        "n is unknown"
    }
}

println!("{}", dynamic_type("Hello"));
println!("{}", dynamic_type([1, 2, 3, 4]));
println!("{}", dynamic_type(42));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/types/type_check.rn
n is a String
n is a vector
n is unknown
</code></pre>
<p>A tighter way to accomplish this would be by using pattern matching, a mechanism
especially suited for many conditional branches. Especially when the branches
are different types or variants in an enum.</p>
<pre><code class="language-rune">fn dynamic_type(n) {
    match n {
        n if n is String =&gt; "n is a String",
        n if n is Vec =&gt; "n is a vector",
        _ =&gt; "n is unknown",
    }
}

println!("{}", dynamic_type("Hello"));
println!("{}", dynamic_type([1, 2, 3, 4]));
println!("{}", dynamic_type(42));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/types/type_check_patterns.rn
n is a String
n is a vector
n is unknown
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-and-reference-types"><a class="header" href="#primitive-and-reference-types">Primitive and reference types</a></h1>
<p>Primitives are values stored immediately on the stack. In Rust terminology,
these types are <code>Copy</code>, so reassigning them to different values will create
distinct <em>copies</em> of the underlying value.</p>
<p>The primitives available in Rune are:</p>
<ul>
<li>The unit <code>()</code>.</li>
<li>Booleans, <code>true</code> and <code>false</code>.</li>
<li>Bytes, like <code>b'\xff'</code>.</li>
<li>Characters, like <code>'‰ªä'</code>. Which are 4 byte wide characters.</li>
<li>Integers, like <code>42</code>. Which are 64-bit signed integers.</li>
<li>Floats, like <code>3.1418</code>. Which are 64-bit floating point numbers.</li>
<li>Static strings, like <code>"Hello World"</code>.</li>
<li>Type hashes.</li>
</ul>
<p>You can see that these bytes are <code>Copy</code> when assigning them to a different
variable, because a separate copy of the value will be used automatically.</p>
<pre><code class="language-rune">let a = 1;
let b = a;
a = 2;
println!("{a}");
println!("{b}");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/primitives/copy.rn
2
1
</code></pre>
<p>Other types like <em>strings</em> are stored by reference. Assigning them to a
different variable will only <em>copy their reference</em>, but they still point to the
same underlying data.</p>
<pre><code class="language-rune">let a = String::from("Hello");
let b = a;
a.push_str(" World");
println!("{a}");
println!("{b}");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/primitives/primitives.rn
Hello World
Hello World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>A vector is a native data structure of Rune which is a dynamic list of values. A
vector isn't typed, and can store <em>any</em> Rune values.</p>
<pre><code class="language-rune">pub fn main() {
    let values = ["Hello", 42];

    println!("{}", values[0]);
    println!("{}", values.1); // items in vectors can be accessed like tuple fields.

    for v in values {
        println!("{}", v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/vectors/vectors.rn
Hello
42
Hello
42
</code></pre>
<p>As you can see, you can iterate over a vector because it implements the iterator
protocol. It is also possible to create and use an iterator manually using
<code>Vec::iter</code>, giving you more control over it.</p>
<pre><code class="language-rune">pub fn main() {
    let values = ["Hello", 42];

    for v in values.iter().rev() {
        println!("{}", v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/vectors/vectors_rev.rn
42
Hello
</code></pre>
<h2 id="using-vectors-from-rust"><a class="header" href="#using-vectors-from-rust">Using vectors from Rust</a></h2>
<p>Vectors are represented externally as the standard <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Diagnostics, Vm};

use std::sync::Arc;

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let context = rune_modules::default_context()?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            pub fn calc(input) {
                let output = 0;

                for value in input {
                    output += value;
                }

                [output]
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;
    let mut vm = Vm::new(runtime, Arc::new(unit));

    let input = vec![1, 2, 3, 4];
    let output = vm.call(["calc"], (input,))?;
    let output: Vec&lt;i64&gt; = rune::from_value(output)?;

    println!("{:?}", output);
    Ok(())
}</code></pre></pre>
<pre><code class="language-text">$&gt; cargo run --example vector
[10]
</code></pre>
<p>If you have a vector which has values of non-uniform types, you can use
<a href="https://docs.rs/rune/0/rune/struct.VecTuple.html"><code>VecTuple</code></a> to deal with them.</p>
<pre><pre class="playground"><code class="language-rust">use rune::runtime::VecTuple;
use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Diagnostics, Vm};

use std::sync::Arc;

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let context = rune_modules::default_context()?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            pub fn calc(input) {
                let a = input[0] + 1;
                let b = format!("{} World", input[1]);
                [a, b]
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;
    let mut vm = Vm::new(runtime, Arc::new(unit));

    let input: VecTuple&lt;(i64, String)&gt; = VecTuple::new((1, String::from("Hello")));
    let output = vm.call(["calc"], (input,))?;
    let VecTuple((a, b)): VecTuple&lt;(u32, String)&gt; = rune::from_value(output)?;

    println!("({:?}, {:?})", a, b);
    Ok(())
}</code></pre></pre>
<pre><code class="language-text">$&gt; cargo run --example vec_tuple
(2, "Hello World")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>Objects are anonymous maps, which support defining and using arbitrary string
keys.</p>
<pre><code class="language-rune">let values = #{};
values["first"] = "bar";
values["second"] = 42;

dbg!(values["first"]);
dbg!(values.second); // items be accessed like struct fields.

if let Some(key) = values.get("not a key") {
    dbg!(key);
} else {
    println!("key did not exist");
}

for entry in values {
    dbg!(entry);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/objects/objects.rn
"bar"
42
key did not exist
("second", 42)
("first", "bar")
</code></pre>
<p>These are useful because they allow their data to be specified dynamically,
which is exactly the same use case as storing unknown JSON.</p>
<p>One of the biggest motivations for Rune to have anonymous objects is so that
we can natively handle data with unknown structure.</p>
<pre><code class="language-rune">async fn get_commits(repo, limit) {
    let limit = limit.unwrap_or(10);

    let client = http::Client::new();
    let request = client.get(`https://api.github.com/repos/${repo}/commits`);
    let response = request.header("User-Agent", "Rune").send().await?;
    let text = response.text().await?;
    let json = json::from_string(text)?;

    let commits = json.iter().take(limit).map(|e| e.sha).collect::&lt;Vec&gt;();
    Ok(commits)
}

for commit in get_commits("rune-rs/rune", Some(5)).await? {
    println!("{commit}");
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/objects/json.rn
9c4bdaf194410d8b2f5d7f9f52eb3e64709d3414
06419f2580e7a18838f483321055fc06c0d75c4c
cba225dad143779a0a9543cfb05cde9710083af5
15133745237c014ff8bae53d8ff8f3c137c732c7
39ac97ab4ebe26118e807eb91c7656ab95b1fcac
3f6310eeeaca22d0373cc11d8b34d346bd12a364
</code></pre>
<h2 id="using-objects-from-rust"><a class="header" href="#using-objects-from-rust">Using objects from Rust</a></h2>
<p>Objects are represented externally as the <a href="https://docs.rs/rune/0/rune/type.Object.html"><code>Object</code></a> type alias. The keys are
always strings, but its value must be specified as the sole type parameter.
Note that the dynamic <a href="https://docs.rs/rune/0/rune/enum.Value.html"><code>Value</code></a> can be used if the type is unknown.</p>
<pre><code class="language-rust noplaypen">use rune::alloc;
use rune::runtime::Object;
use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Diagnostics, Vm};

use std::sync::Arc;

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let context = rune_modules::default_context()?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            pub fn calc(input) {
                dbg(input["key"]);
                input["key"] = "World";
                input
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let mut vm = Vm::new(runtime, Arc::new(unit));

    let mut object = Object::new();
    object.insert(alloc::String::try_from("key")?, rune::to_value(42i64)?)?;

    let output = vm.call(["calc"], (object,))?;
    let output: Object = rune::from_value(output)?;

    println!("{:?}", output.get("key"));
    Ok(())
}</code></pre>
<pre><code class="language-text">$&gt; cargo run --example object
42
Some("World")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Tuples in Rune are fixed-size sequences of values. Similarly to a vector, tuples
can contain any sequence of values. But there's no way to change the size of a
tuple.</p>
<pre><code class="language-rune">let values = ("Now", "You", "See", "Me");
dbg!(values);

values.2 = "Don't";
values.3 = "!";
dbg!(values);
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/tuples/tuple_masquerade.rn
("Now", "You", "See", "Me")
("Now", "You", "Don\'t", "!")
</code></pre>
<p>The following is a simple example of a function returning a tuple:</p>
<pre><code class="language-rune">fn foo() {
    (1, "test")
}

dbg!(foo());
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/tuples/basic_tuples.rn
(1, "test")
</code></pre>
<p>Tuples can also be pattern matched:</p>
<pre><code class="language-rune">match ("test", 1) {
    ("test", n) =&gt; {
        dbg!("the first part was a number:", n);
    }
    _ =&gt; {
        dbg!("matched something we did not understand");
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/tuples/tuple_patterns.rn
"the first part was a number:"
1
</code></pre>
<h2 id="using-tuples-from-rust"><a class="header" href="#using-tuples-from-rust">Using tuples from Rust</a></h2>
<p>Tuples are represented externally as <a href="https://doc.rust-lang.org/std/primitive.tuple.html">primitive tuple types</a>.</p>
<pre><code class="language-rust noplaypen">use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Diagnostics, Vm};

use std::sync::Arc;

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let context = rune_modules::default_context()?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            pub fn calc(input) {
                (input.0 + 1, input.1 + 2)
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let mut vm = Vm::new(runtime, Arc::new(unit));
    let output = vm.call(["calc"], ((1u32, 2u32),))?;
    let output: (i32, i32) = rune::from_value(output)?;

    println!("{:?}", output);
    Ok(())
}</code></pre>
<pre><code class="language-text">$&gt; cargo run --example tuple
(2, 4)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-types"><a class="header" href="#dynamic-types">Dynamic types</a></h1>
<p>Dynamic types are types which can be defined and used solely within a Rune
script. They provide the ability to structure data and associate functions with
it.</p>
<p>The following is a quick example of a <code>struct</code>:</p>
<pre><code class="language-rune">struct Person {
    name,
}

impl Person {
    fn greet(self) {
        println!("Greetings from {}, and good luck with this section!", self.name);
    }
}

let person = Person { name: "John-John Tedro" };

person.greet();
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/dynamic_types/greeting.rn
Greetings from John-John Tedro, and good luck with this section!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs are like objects, except that they have a predefined structure with a
set of keys that are known at compile time and guaranteed to be defined.</p>
<p>Structs can also, like most types, have an <code>impl</code> block associated with them
which creates instance functions that you can call on an instance of that
struct.</p>
<pre><code class="language-rune">struct User {
    username,
    active,
}

impl User {
    fn set_active(self, active) {
        self.active = active;
    }

    fn describe(self) {
        if self.active {
            println!("{} is active.", self.username);
        } else {
            println!("{} is inactive.", self.username);
        }
    }
}

let user = User { username: "setbac", active: false };

user.describe();
user.set_active(true);
user.describe();
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/structs/user_database.rn
setbac is inactive
setbac is active
</code></pre>
<p>Structs can also be pattern matched, like most types.</p>
<p>But since the fields of a struct are known at compile time, the compiler can
ensure that you're only using fields which are defined.</p>
<pre><code class="language-rune">struct User {
    username,
    active,
}

impl User {
    fn describe(self) {
        match self {
            User { username: "setbac", .. } =&gt; {
                println!("Yep, it's setbac.");
            }
            User { username, .. } =&gt; {
                println!("Other user: {username}.");
            }
        }
    }
}

let user = User { username: "setbac", active: false };

user.describe();
user.username = "newt";
user.describe();
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/structs/struct_matching.rn
Yep, it's setbac.
Other user: newt.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Rune has support for <em>enumerations</em>. These allow you to define a type with zero
or more <em>variants</em>, where each variant can hold a distinct set of data.</p>
<p>In a dynamic programming language enums might not seem quite as useful, but it's
important for Rune to support them to have a level of feature parity with Rust.</p>
<p>Even so, in this section we'll explore some cases where enums are useful.</p>
<h2 id="the-option-enum"><a class="header" href="#the-option-enum">The <code>Option</code> enum</a></h2>
<p>Rune has native support for <code>Option</code>, the same enum available in Rust that
allows you to represent data that can either be present with <code>Option::Some</code>, or
absent with <code>Option::None</code>.</p>
<pre><code class="language-rune">fn count_numbers(limit) {
    let limit = limit.unwrap_or(10);

    for n in 0..limit {
        println!("Count: {}", n);
    }
}

println!("First count!");
count_numbers(None);

println!("Second count!");
count_numbers(Some(2));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/enums/count_numbers.rn
First count!
Count: 0
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
Count: 6
Count: 7
Count: 8
Count: 9
Second count!
Count: 0
Count: 1
</code></pre>
<p>Using an <code>Option</code> allows us to easily model the scenario where we have an
optional function parameter, with a default fallback value.</p>
<p>In the next section we'll be looking into a control flow construct which gives
<code>Option</code> superpowers.</p>
<p>The try operator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-types"><a class="header" href="#external-types">External types</a></h1>
<p>When a type is declared outside of Rune it is said to be <em>external</em>. External
types are declared when setting up native modules. And Rune allows various
levels of integration with the language.</p>
<p>On the simplest level an external type is entirely opaque. Rune knows nothing
about it except that it is a value bound to a variable.</p>
<p>Below is the most simple example of an external type. It's implemented by
deriving <a href="https://docs.rs/rune/latest/rune/derive.Any.html">Any</a> which can do a lot of heavy lifting for us.</p>
<pre><code class="language-rust noplaypen">use rune::runtime::Vm;
use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Any, ContextError, Diagnostics, Module};

use std::sync::Arc;

#[derive(Debug, Any)]
struct External {
    value: u32,
}

pub fn module() -&gt; Result&lt;Module, ContextError&gt; {
    let mut module = Module::new();
    module.ty::&lt;External&gt;()?;
    Ok(module)
}

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let m = module()?;

    let mut context = rune_modules::default_context()?;
    context.install(m)?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            pub fn main(external) {
                external
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let mut vm = Vm::new(runtime, Arc::new(unit));

    let output = vm.call(["main"], (External { value: 42 },))?;
    let output: External = rune::from_value(output)?;
    println!("{:?}", output);
    assert_eq!(output.value, 42);
    Ok(())
}</code></pre>
<p>This type isn't particularly useful. Attempting to access a field on <code>external</code>
would simply error. We have to instruct Rune how the field is accessed.</p>
<p>Luckily <a href="https://docs.rs/rune/latest/rune/derive.Any.html">Any</a> allows us to easily do that by marking the fields we want to make
accessible to Rune with <code>#[rune(get)]</code>.</p>
<pre><code class="language-rust noplaypen">#[derive(Debug, Any)]
struct External {
    #[rune(get)]
    value: u32,
}</code></pre>
<p>With our newfound power we can now read <code>external.value</code>.</p>
<pre><code class="language-rune">pub fn main(external) {
    println!("{}", external.value);
}
</code></pre>
<p>Setting the value is similarly simple. We simply mark the field with
<code>#[rune(set)]</code>.</p>
<pre><code class="language-rust noplaypen">#[derive(Debug, Any)]
struct External {
    #[rune(get, set)]
    value: u32,
}</code></pre>
<p>And now we can both read and write to <code>external.value</code>.</p>
<pre><code class="language-rune">pub fn main(external) {
    external.value = external.value + 1;
}
</code></pre>
<blockquote>
<p>Note: See the section about <a href="./field_functions.html">Field Functions</a> for a
complete reference of the available attributes.</p>
</blockquote>
<h1 id="external-enums"><a class="header" href="#external-enums">External enums</a></h1>
<p>Enums have a few more tricks that we need to cover. We want to be able to
<em>pattern match</em> and <em>construct</em> external enums.</p>
<p>There are three kinds of variants in an enum:</p>
<ul>
<li>Unit variants which have no fields. E.g. <code>External::Unit</code>.</li>
<li>Tuple variants which have <em>numerical</em> fields. E.g. <code>External::Tuple(1, 2, 3)</code>.</li>
<li>Struct variants which have <em>named</em> fields. E.g. <code>External::Struct { a: 1, b: 2, c: 3 }</code>.</li>
</ul>
<p>Pattern matching is supported out of the box. The only thing to take note of is
that pattern matching will only see fields that are annotated with
<code>#[rune(get)]</code>.</p>
<p>So the following type:</p>
<pre><code class="language-rust noplaypen">enum External {
    First(#[rune(get)] u32, u32),
    Second(#[rune(get)] u32),
}</code></pre>
<p>Could be pattern matched like this in Rune:</p>
<pre><code class="language-rune">pub fn main(external) {
    match external {
        External::First(a) =&gt; a,
        External::Second(b) =&gt; b,
    }
}
</code></pre>
<p>Take note on how <code>External::First</code> only "sees" the field marked with
<code>#[rune(get)]</code>.</p>
<p>Let's add a struct variant and see what we can do then:</p>
<pre><code class="language-rust noplaypen">enum External {
    First(#[rune(get)] u32, u32),
    Second(#[rune(get)] u32),
    Third {
        a: u32,
        b: u32,
        #[rune(get)]
        c: u32,
    },
}</code></pre>
<p>And let's add <code>Third</code> to our example:</p>
<pre><code class="language-rune">pub fn main(external) {
    match external {
        External::First(a) =&gt; a,
        External::Second(b) =&gt; b,
        External::Third { c } =&gt; b,
    }
}
</code></pre>
<h2 id="constructing-enum-variants"><a class="header" href="#constructing-enum-variants">Constructing enum variants</a></h2>
<p>Unit and tuple variants can be annotated with <code>#[rune(constructor)]</code> which is
necessary to allow for building enums in Rune. But in order for the constructor
to work, all fields <strong>must</strong> be annotated with <code>#[rune(get)]</code>.</p>
<pre><code class="language-rust noplaypen">enum External {
    #[rune(constructor)]
    First(#[rune(get)] u32, #[rune(get)] u32),
    #[rune(constructor)]
    Second(#[rune(get)] u32),
    Third {
        a: u32,
        b: u32,
        #[rune(get)]
        c: u32,
    },
}</code></pre>
<pre><code class="language-rune">pub fn main() {
    External::First(1, 2)
}
</code></pre>
<p>But why do we have the <code>#[rune(get)]</code> requirement? Consider what would happen
otherwise. How would we construct an instance of <code>External::First</code> without being
able to <em>specify</em> what the values of all fields are? The answer is that all
fields must be visible. Alternatively we can declare another constructor as an
associated function. The same way we'd do it in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="try-operator"><a class="header" href="#try-operator">Try operator</a></h1>
<p>The try operator (<code>?</code>) is a control flow operator which causes a function to
return early in case the value being tried over has a certain value.</p>
<p>For <code>Option</code>, this causes the function to return if it has the <code>Option::None</code>
variant.</p>
<pre><code class="language-rune">fn checked_div_mod(a, b) {
    let div = a.checked_div(b)?;
    Some((div, a % b))
}

if let Some((div, m)) = checked_div_mod(5, 2) {
    println!("Result: {}, {}", div, m);
}

if let Some((div, m)) = checked_div_mod(5, 0) {
    println!("Result: {}, {}", div, m);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/try_operator/basic_try.rn
Result: 2, 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generators"><a class="header" href="#generators">Generators</a></h1>
<p>Generators are a convenient method for constructing functions which are capable
of suspending themselves and their state.</p>
<p>The simplest use case for generators is to create a kind of iterator, whose
state is stored in the generator function.</p>
<p>With this, we can create a fairly efficient generator to build fibonacci
numbers.</p>
<pre><code class="language-rune">fn fib() {
    let a = 0;
    let b = 1;

    loop {
        yield a;
        let c = a + b;
        a = b;
        b = c;
    }
}

let g = fib();

while let Some(n) = g.next() {
    println!("{n}");

    if n &gt; 100 {
        break;
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/generators/fib_generator.rn
0
1
1
2
3
5
8
13
21
34
55
89
144
</code></pre>
<h2 id="advanced-generators-with-generatorstate"><a class="header" href="#advanced-generators-with-generatorstate">Advanced generators with <code>GeneratorState</code></a></h2>
<p>Generators internally are a bit more complex than that.
The <code>next</code> function simply slates over some of that complexity to make simple
things easier to do.</p>
<p>The first thing to know is that <code>yield</code> itself can actually <em>produce</em> a value,
allowing the calling procedure to send values to the generator.</p>
<pre><code class="language-rune">fn printer() {
    let collected = [];

    for _ in 0..2 {
        let out = yield;
        println!("{:?}", out);
        collected.push(out);
    }

    assert_eq!(collected, ["John", (1, 2, 3)]);
}

let printer = printer();
printer.resume(());
printer.resume("John");
printer.resume((1, 2, 3));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/generators/send_values.rn
"John"
(1, 2, 3)
</code></pre>
<p>But wait, what happened to the first value we sent, <code>1</code>?</p>
<p>Well, generators don't run immediately, they need to be "warmed up" by calling
resume once.
At that point it runs the block prior to the first yield, we can see this by
instrumenting our code a little.</p>
<pre><code class="language-rune">fn printer() {
    loop {
        println!("waiting for value...");
        let out = yield;
        println!("{out:?}");
    }
}

let printer = printer();

println!("firing off the printer...");
printer.resume(());
println!("ready to go!");

printer.resume("John");
printer.resume((1, 2, 3));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/generators/bootup.rn
firing off the printer...
waiting for value...
ready to go!
"John"
waiting for value...
(1, 2, 3)
waiting for value...
</code></pre>
<p>Ok, so we understand how to <em>send</em> values into a generator.
But how do we <em>receive</em> them?</p>
<p>This adds a bit of complexity, since we need to pull out <code>GeneratorState</code>.
This enum has two variants: <code>Yielded</code> and <code>Complete</code>, and represents all the
possible states a generator can suspend itself into.</p>
<pre><code class="language-rune">fn print_once() {
    let out = yield 1;
    println!("{:?}", out);
    2
}

let printer = print_once();
dbg!(printer.resume(()));
dbg!(printer.resume("John"));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/generators/states.rn
Yielded(1)
"John"
Complete(2)
</code></pre>
<p>After the first call to resume, we see that the generator produced <code>Yielded(1)</code>.
This corresponds to the <code>yield 1</code> statement in the generator.</p>
<p>The second value we get is <code>Complete(2)</code>.
This corresponds to the <em>return value</em> of the generator.</p>
<p>Trying to resume the generator after this will cause the virtual machine to
error.</p>
<pre><code class="language-rune">fn print_once() {
    yield 1
}

let printer = print_once();
dbg!(printer);
dbg!(printer.resume(()));
dbg!(printer.resume("John"));
dbg!(printer);
dbg!(printer.resume(()));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/generators/error.rn
Generator { completed: false }
Yielded(1)
Complete("John")
Generator { completed: true }
error: virtual machine error
   ‚îå‚îÄ scripts/book/generators/error.rn:11:9
   ‚îÇ
11 ‚îÇ     dbg!(printer.resume(()));
   ‚îÇ          ^^^^^^^^^^^^^^^^^^ cannot resume a generator that has completed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>We've gone over functions before, and while incredibly useful there's a few more
tricks worth mentioning.</p>
<p>We'll also be talking about closures, an anonymous function with the ability to
<em>close over</em> its environment, allowing the function to use and manipulate things
from its environment.</p>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function pointers</a></h2>
<p>Every function can be converted into a function pointer simply by referencing
its name without calling it.</p>
<p>This allows for some really neat tricks, like passing in a function which
represents the operation you want another function to use.</p>
<pre><code class="language-rune">fn do_thing(op) {
    op(1, 2)
}

fn add(a, b) {
    a + b
}

fn sub(a, b) {
    a - b
}

println!("Result: {}", do_thing(add));
println!("Result: {}", do_thing(sub));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/closures/function_pointers.rn
Result: 3
Result: -1
</code></pre>
<h2 id="closures-1"><a class="header" href="#closures-1">Closures</a></h2>
<p>Closures are anonymous functions which closes over their environment.
This means that they capture any variables used inside of the closure, allowing
them to be used when the function is being called.</p>
<pre><code class="language-rune">fn work(op) {
    op(1, 2)
}

let n = 1;
println!("Result: {}", work(|a, b| n + a + b));
println!("Result: {}", work(|a, b| n + a * b));
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/closures/basic_closure.rn
Result: 4
Result: 3
</code></pre>
<blockquote>
<p>Hint: Closures which do not capture their environment are <em>identical</em> in
representation to a function.</p>
</blockquote>
<h1 id="functions-outside-of-the-vm"><a class="header" href="#functions-outside-of-the-vm">Functions outside of the Vm</a></h1>
<p>Now things get <em>really</em> interesting.
Runestick, the virtual machine driving Rune, has support for passing function
pointers out of the virtual machine using the <code>Function</code> type.</p>
<p>This allows you to write code that takes a function constructed in Rune, and use
it for something else.</p>
<pre><code class="language-rust noplaypen">use rune::runtime::Function;
use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Diagnostics, Vm};

use std::sync::Arc;

fn main() -&gt; rune::support::Result&lt;()&gt; {
    let context = rune_modules::default_context()?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            fn foo(a, b) {
                a + b
            }

            pub fn main() {
                foo
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let mut vm = Vm::new(runtime, Arc::new(unit));
    let output = vm.call(["main"], ())?;
    let output: Function = rune::from_value(output)?;

    println!("{}", output.call::&lt;i64&gt;((1, 3)).into_result()?);
    println!("{}", output.call::&lt;i64&gt;((2, 6)).into_result()?);
    Ok(())
}</code></pre>
<pre><code class="language-text">$&gt; cargo run --example rune_function
4
8
</code></pre>
<p>Note that these functions by necessity have to capture their entire context and
can take up quite a bit of space if you keep them around while cycling many
contexts or units.</p>
<p>Values used in a closure can also be moved into it using the <code>move</code> keyword,
guaranteeing that no one else can use it afterwards. An attempt to do so will
cause a compile error.</p>
<pre><code class="language-rune">fn work(op) {
    op(1, 2)
}

pub fn main() {
    let n = 1;
    println!("Result: {}", work(move |a, b| n + a + b));
    assert!(!is_readable(n));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/closures/closure_move.rn.fail
error: compile error
  ‚îå‚îÄ scripts/book/closures/closure_move.rn.fail:7:33
  ‚îÇ
7 ‚îÇ     println!("Result: {}", work(move |a, b| n + a + b));
  ‚îÇ                                 --------------------- moved here
8 ‚îÇ     assert!(!is_readable(n));
  ‚îÇ                          ^ variable moved
</code></pre>
<blockquote>
<p>Moving indiscriminately applies to types which in principle could be copied
(like integers). We simply don't have the necessary type information available
right now to make that decision. If you know that the value can be copied and
you want to do so: assign it to a separate variable.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous programming</a></h1>
<p>Rune has first class support for Rust-like asynchronous programming.
In this section we'll be briefly covering what asynchronous programming is, and
how it applies to Rune as a dynamic programming language.</p>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>Asynchronous code allows us to run multiple tasks concurrently, and work with
the result of those tasks.</p>
<p>A typical example would be if we want to perform multiple HTTP requests at once:</p>
<pre><code class="language-rune">let a = http::get("https://google.com");
let b = http::get("https://amazon.com");

loop {
    let res = select {
        res = a =&gt; res?,
        res = b =&gt; res?,
    };

    match res {
        () =&gt; break,
        result =&gt; {
            println!("{}", result.status());
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/async/async_http.rn
200 OK
200 OK
</code></pre>
<p>In the above code we send two requests <em>concurrently</em>. They are both processed
at the same time and we collect the result.</p>
<h2 id="select-blocks"><a class="header" href="#select-blocks"><code>select</code> blocks</a></h2>
<p>A fundamental construct of async programming in Rune is the <code>select</code> block.
It enables us to wait on a set of futures at the same time.</p>
<p>A simple example of this is if we were to implement a simple request with a
timeout:</p>
<pre><code class="language-rune">struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep=${timeout}`);
    let timeout = time::sleep(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    println!("{}", result.status());
    Ok(())
}

if let Err(Timeout) = request(1000).await {
    println!("Request timed out!");
}

if let Err(Timeout) = request(4000).await {
    println!("Request timed out!");
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/async/async_http_timeout.rn
200 OK
Request timed out!
</code></pre>
<p>But wait, this is taking three seconds. We're not running the requests
concurrently any longer!</p>
<p>Well, while the request and the <em>timeout</em> is run concurrently, the <code>request</code>
function is run one at-a-time.</p>
<p>To fix this we need two new things: <code>async</code> functions and <code>.await</code>.</p>
<h2 id="async-functions"><a class="header" href="#async-functions"><code>async</code> functions</a></h2>
<p><code>async</code> functions are just like regular functions, except that when called they
produce a <code>Future</code>.</p>
<p>In order to get the result of this <code>Future</code> it must be <code>.await</code>ed. And <code>.await</code>
is only permitted inside of <code>async</code> functions and closures.</p>
<pre><code class="language-rune">use std::future;

struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep=${timeout}`);
    let timeout = time::sleep(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    Ok(result)
}

for result in future::join([request(1000), request(4000)]).await {
    match result {
        Ok(result) =&gt; println!("Result: {}", result.status()),
        Err(Timeout) =&gt; println!("Request timed out!"),
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/async/async_http_concurrent.rn
Result: 200 OK
Request timed out!
</code></pre>
<h2 id="async-closures"><a class="header" href="#async-closures"><code>async</code> closures</a></h2>
<p>Closures can be prefixed with the <code>async</code> keyword, meaning calling them will
produce a future.</p>
<pre><code class="language-rune">fn do_request(url) {
    async || {
        Ok(http::get(url).await?.status())
    }
}

let future = do_request("https://google.com");
let status = future().await?;
println!("Status: {status}");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/async/async_closure.rn
Status: 200 OK
</code></pre>
<h2 id="async-blocks"><a class="header" href="#async-blocks"><code>async</code> blocks</a></h2>
<p>Blocks can be marked with <code>async</code> to produce on-the-fly futures. These blocks
can capture variables the same way as closures do, but take no arguments.</p>
<pre><code class="language-rune">fn do_request(url) {
    async {
        Ok(http::get(url).await?.status())
    }
}

let future = do_request("https://google.com");
let status = future.await?;
println!("Status: {status}");
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/async/async_blocks.rn
Status: 200 OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="streams"><a class="header" href="#streams">Streams</a></h1>
<p>Streams are the asynchronous version of <a href="./7_generators.html">Generators</a>.</p>
<p>They have almost identical <code>next</code> and <code>resume</code> functions, but each must be used
with <code>.await</code>, and we are now allowed to use asynchronous functions inside of
the generator.</p>
<pre><code class="language-rune">async fn send_requests(list) {
    let client = http::Client::new();

    let do_request = async |url| {
        Ok(client.get(url).send().await?.status())
    };

    for url in list {
        yield do_request(url).await;
    }
}

let requests = send_requests(["https://google.com", "https://amazon.com"]);

while let Some(status) = requests.next().await.transpose()? {
    println!("{}", status);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/streams/basic_stream.rn
200 OK
200 OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multithreading"><a class="header" href="#multithreading">Multithreading</a></h1>
<p>Rune is thread safe, but the <a href="https://docs.rs/rune/latest/rune/runtime/struct.Vm.html"><code>Vm</code></a> does not implement <code>Sync</code> so cannot directly
be shared across threads. This section details instead how you are intended to
use Rune in a multithreaded environment.</p>
<p>Compiling a <a href="https://docs.rs/rune/latest/rune/runtime/struct.Unit.html"><code>Unit</code></a> and a <a href="https://docs.rs/rune/latest/rune/runtime/struct.RuntimeContext.html"><code>RuntimeContext</code></a> are expensive operations compared
to the cost of calling a function. So you should try to do this as little as
possible. It is appropriate to recompile a script when the source of the script
changes. See the <a href="./hot_reloading.html">Hot reloading</a> section for more information on this.</p>
<p>Once you have a <code>Unit</code> and a <code>RuntimeContext</code> they are thread safe and can be
used by multiple threads simultaneously through <code>Arc&lt;Unit&gt;</code> and
<code>Arc&lt;RuntimeContext&gt;</code>. Constructing a <code>Vm</code> with these through <code>Vm::new</code> is a
very cheap operation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unit: Arc&lt;Unit&gt; = /* todo */;
let context: Arc&lt;RuntimeContext&gt; = /* todo */;

std::thread::spawn(move || {
    let mut vm = Vm::new(unit, context);
    let value = vm.call(["function"], (42,))?;
    Ok(())
});
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Virtual machines do allocate memory. To avoide this overhead you'd have to
employ more advanced techniques, such as storing virtual machines in a pool or
<a href="https://doc.rust-lang.org/std/macro.thread_local.html">thread locals</a>. Once a machine has been acquired the <code>Unit</code> and
<code>RuntimeContext</code> associated with it can be swapped out to the ones you need
using <a href="https://docs.rs/rune/latest/rune/runtime/struct.Vm.html#method.unit_mut"><code>Vm::unit_mut</code></a> and <a href="https://docs.rs/rune/latest/rune/runtime/struct.Vm.html#method.context_mut"><code>Vm::context_mut</code></a> respectively.</p>
</blockquote>
<p>Using <a href="https://docs.rs/rune/latest/rune/runtime/struct.Vm.html#method.send_execute"><code>Vm::send_execute</code></a> is a way to assert that a given execution is thread
safe. And allows you to use Rune in asynchronous multithreaded environments,
such as Tokio. This is achieved by ensuring that all captured arguments are
<a href="https://docs.rs/rune/latest/rune/runtime/enum.ConstValue.html"><code>ConstValue</code></a>'s, which in contrast to <a href="https://docs.rs/rune/latest/rune/runtime/enum.Value.html"><code>Value</code></a>'s are guaranteed to be
thread-safe:</p>
<pre><pre class="playground"><code class="language-rust">use rune::alloc::prelude::*;
use rune::termcolor::{ColorChoice, StandardStream};
use rune::{Diagnostics, Vm};

use std::sync::Arc;

#[tokio::main]
async fn main() -&gt; rune::support::Result&lt;()&gt; {
    let context = rune_modules::default_context()?;
    let runtime = Arc::new(context.runtime()?);

    let mut sources = rune::sources! {
        entry =&gt; {
            async fn main(timeout) {
                time::sleep(time::Duration::from_secs(timeout)).await
            }
        }
    };

    let mut diagnostics = Diagnostics::new();

    let result = rune::prepare(&amp;mut sources)
        .with_context(&amp;context)
        .with_diagnostics(&amp;mut diagnostics)
        .build();

    if !diagnostics.is_empty() {
        let mut writer = StandardStream::stderr(ColorChoice::Always);
        diagnostics.emit(&amp;mut writer, &amp;sources)?;
    }

    let unit = result?;

    let vm = Vm::new(runtime, Arc::new(unit));

    let execution = vm.try_clone()?.send_execute(["main"], (5u32,))?;
    let t1 = tokio::spawn(async move {
        execution.async_complete().await.unwrap();
        println!("timer ticked");
    });

    let execution = vm.try_clone()?.send_execute(["main"], (2u32,))?;
    let t2 = tokio::spawn(async move {
        execution.async_complete().await.unwrap();
        println!("timer ticked");
    });

    tokio::try_join!(t1, t2).unwrap();
    Ok(())
}</code></pre></pre>
<p>Finally <a href="https://docs.rs/rune/latest/rune/runtime/struct.Function.html#method.into_sync"><code>Function::into_sync</code></a> exists to coerce a function into a
<a href="https://docs.rs/rune/latest/rune/runtime/struct.SyncFunction.html"><code>SyncFunction</code></a>, which is a thread-safe variant of a regular <a href="https://docs.rs/rune/latest/rune/runtime/struct.Function.html"><code>Function</code></a>. This
is a fallible operation since all values which are captured in the function-type
in case its a closure has to be coerced to <a href="https://docs.rs/rune/latest/rune/runtime/enum.ConstValue.html"><code>ConstValue</code></a>. If this is not the
case, the conversion will fail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hot-reloading"><a class="header" href="#hot-reloading">Hot reloading</a></h1>
<p>Compiling a <a href="https://docs.rs/rune/latest/rune/runtime/unit/struct.Unit.html"><code>Unit</code></a> and a [<code>RuntimeContext</code>] are expensive operations compared
to the cost of calling a function. So you should try to do this as little as
possible. It is appropriate to recompile a script when the source of the script
changes. This section provides you with details for how this can be done when
loading scripts from the filesystem.</p>
<p>A typical way to accomplish this is to watch a scripts directory using the
<a href="https://docs.rs/notify"><code>notify</code> crate</a>. This allow the application to generate events whenever changes
to the directory are detected. See the <a href="https://github.com/rune-rs/rune/blob/main/examples/examples/hot_reloading.rs"><code>hot_reloading</code> example</a> and in
particular the <a href="https://github.com/rune-rs/rune/blob/main/examples/examples/hot_reloading/path_reloader.rs"><code>PathReloader</code></a> type.</p>
<pre><pre class="playground"><code class="language-rust">#[path = "hot_reloading/path_reloader.rs"]
mod path_reloader;

use std::path::PathBuf;
use std::pin::pin;
use std::sync::Arc;

use anyhow::{Context as _, Result};
use rune::{Context, Vm};

#[tokio::main(flavor = "current_thread")]
async fn main() -&gt; Result&lt;()&gt; {
    let root =
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").context("missing CARGO_MANIFEST_DIR")?);

    let context = Context::with_default_modules()?;

    let mut exit = pin!(tokio::signal::ctrl_c());
    let mut reloader = pin!(path_reloader::PathReloader::new(
        root.join("scripts"),
        &amp;context
    )?);

    let context = Arc::new(context.runtime()?);

    let mut events = Vec::new();

    loop {
        tokio::select! {
            _ = exit.as_mut() =&gt; {
                break;
            }
            result = reloader.as_mut().watch(&amp;mut events) =&gt; {
                result?;
            }
        }

        for event in events.drain(..) {
            let mut vm = Vm::new(context.clone(), event.unit);

            match event.kind {
                path_reloader::EventKind::Added =&gt; {
                    if let Err(error) = vm.call(["hello"], ()) {
                        println!("Error: {}", error);
                    }
                }
                path_reloader::EventKind::Removed =&gt; {
                    if let Err(error) = vm.call(["goodbye"], ()) {
                        println!("Error: {}", error);
                    }
                }
            }
        }
    }

    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Rune has support for macros. These are functions which expand into code, and can
be used by library writers to "extend the compiler".</p>
<p>For now, the following type of macros are support:</p>
<ul>
<li>Function-like macros expanding to items (functions, type declarations, ..).</li>
<li>Function-like macros expanding to expression (statements, blocks, async
blocks, ..).</li>
<li>Attribute macros expanding around a function.</li>
</ul>
<p>Macros can currently only be defined natively. This is to get around the rather
tricky issue that the code of a macro has to be runnable during compilation.
Native modules have an edge here, because they have to be defined at a time when
they are definitely available to the compiler.</p>
<blockquote>
<p>Don't worry though, we will be playing around with <code>macro fn</code> as well, but at
a later stage üòâ (See <a href="https://github.com/rune-rs/rune/issues/27">issue #27</a>).</p>
</blockquote>
<p>Native modules also means we can re-use all the existing compiler infrastructure
for Rune as a library for macro authors. Which is really nice!</p>
<h2 id="writing-a-native-macro"><a class="header" href="#writing-a-native-macro">Writing a native macro</a></h2>
<p>The following is the definition of the <code>stringy_math!</code> macro. Which is a macro
that can be invoked on expressions.</p>
<p>This relies heavily on a Rune-specific <a href="https://docs.rs/rune/0/rune/macro.quote.html"><code>quote!</code> macro</a>. Which is inspired by its
<a href="https://docs.rs/quote/1/quote/">famed counterpart in the Rust world</a>. A major difference with Rune <code>quote!</code> is
that we need to pass in the <code>MacroContext</code> when invoking it. This is a detail
which will be covered in one of the advanced sections.</p>
<pre><code class="language-rust noplaypen">use crate as rune;
use crate::ast;
use crate::compile;
use crate::macros::{quote, MacroContext, TokenStream};
use crate::parse::Parser;

/// Implementation of the `stringy_math!` macro.
#[rune::macro_]
pub fn stringy_math(
    cx: &amp;mut MacroContext&lt;'_, '_, '_&gt;,
    stream: &amp;TokenStream,
) -&gt; compile::Result&lt;TokenStream&gt; {
    let mut parser = Parser::from_token_stream(stream, cx.input_span());

    let mut output = quote!(0);

    while !parser.is_eof()? {
        let op = parser.parse::&lt;ast::Ident&gt;()?;
        let arg = parser.parse::&lt;ast::Expr&gt;()?;

        output = match cx.resolve(op)? {
            "add" =&gt; quote!((#output) + #arg),
            "sub" =&gt; quote!((#output) - #arg),
            "div" =&gt; quote!((#output) / #arg),
            "mul" =&gt; quote!((#output) * #arg),
            _ =&gt; return Err(compile::Error::msg(op, "unsupported operation")),
        }
    }

    parser.eof()?;
    Ok(output.into_token_stream(cx)?)
}</code></pre>
<p>A macro is added to a <a href="https://docs.rs/rune/0/rune/module/struct.Module.html"><code>Module</code></a> using the <a href="https://docs.rs/rune/0/rune/module/struct.Module.html#method.macro_"><code>Module::macro_</code></a> function.</p>
<pre><code class="language-rust noplaypen">pub fn module() -&gt; Result&lt;rune::Module, rune::ContextError&gt; {
    let mut module = rune::Module::new(["test", "macros"]);
    module.macro_meta(stringy_math)?;
    Ok(module)
}</code></pre>
<p>With this module installed, we can now take <code>stringy_math!</code> for a spin.</p>
<pre><code class="language-rune">use ::test::macros::stringy_math;

pub fn main() {
    stringy_math!(add 10 sub 2 div 3 mul 100)
}
</code></pre>
<p>Running this would return <code>200</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<p>This chapter is dedicated to the advanced topics of Rune. Here we will discuss
the advanced and internal details of the language. This chapter is primarily
targeted at people who want to understand Rune and Runestick in detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop-order"><a class="header" href="#drop-order">Drop order</a></h1>
<p>Rune implements the following rules when determining when a place should be
dropped.</p>
<p>Places are distinct from values, in that they refer to a place where a value is
stored, not the value itself.</p>
<p>The distinction becomes apparent when we note that the same value can be
referenced by multiple places:</p>
<pre><code>let a = 42;
let b = a;
</code></pre>
<p>Above, <code>b</code> is a distinct place that refers to the same value as <code>a</code>.</p>
<p>There are two ways for a value to be dropped:</p>
<ul>
<li>All the places referencing go out of scope.</li>
<li>The value is explicitly dropped with <code>drop(value)</code>.</li>
</ul>
<p>The second variant causes the value to be dropped. Using any of the places
referencing that value after it has been dropped will cause an error.</p>
<h4 id="variables"><a class="header" href="#variables">Variables</a></h4>
<p>A variable declaration like this:</p>
<pre><code class="language-rune">let var = 42;
</code></pre>
<p>Defines a place called <code>var</code>.</p>
<p>Once variables like these go out of scope, their place is dropped. However,
dropping a place doesn't necessarily mean the value is dropped. This only
happens when that is the last place referencing that variable.</p>
<pre><code class="language-rune">let object = {
    let var = 42;
    let object = #{ var };
};

// object can be used here and `var` is still live.
</code></pre>
<h4 id="temporaries"><a class="header" href="#temporaries">Temporaries</a></h4>
<p>Temporaries are constructed when evaluating any non-trivial expression, such as
this:</p>
<pre><code class="language-rune">let var = [42, (), "hello"];
</code></pre>
<p>The drop order for temporaries is not strictly defined and can be extended. But
never beyond the block in which they are defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safety"><a class="header" href="#safety">Safety</a></h1>
<p>Rune is implemented in Rust, but that doesn't automatically make the language
safe (as Rust defines safety) since there are some uses of <code>unsafe</code>. In this
section we'll be documenting the pieces of the implementation which are
currently <code>unsafe</code>, rationalize, and document potential soundness holes.</p>
<h2 id="internal-any-type"><a class="header" href="#internal-any-type">Internal <code>Any</code> type</a></h2>
<p>Rune uses an <a href="https://docs.rs/rune/0/rune/runtime/struct.AnyObj.html">internal <code>Any</code> type</a>.</p>
<p>Apart from the <a href="safety.html#conflicts-in-type-hashes">hash conflict</a> documented above, the
implementation should be sound. We have an internal <code>Any</code> type instead of
relying on <code>Box&lt;dyn Any&gt;</code> to allow <a href="https://docs.rs/rune/0/rune/runtime/struct.AnyObjVtable.html"><code>AnyObjVtable</code></a> to be implementable by external
types to support external types through a C ffi.</p>
<h2 id="sharedt-and-unsafetoref--unsafetomut"><a class="header" href="#sharedt-and-unsafetoref--unsafetomut"><code>Shared&lt;T&gt;</code> and <code>UnsafeToRef</code> / <code>UnsafeToMut</code></a></h2>
<p>A large chunk of the <code>Shared&lt;T&gt;</code> container is <code>unsafe</code>. This is a container
which is behaviorally equivalent to <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.</p>
<p>We have this because it merges <code>Rc</code> and <code>RefCell</code> and provides the ability to
have <a href="https://docs.rs/rune/0/rune/runtime/struct.Shared.html#method.into_ref">"owned borrows"</a> and the ability to unsafely decompose these into a raw
pointer and a raw guard, which is used in many implementations of
<a href="https://docs.rs/rune/0/rune/runtime/trait.UnsafeToRef.html"><code>UnsafeToRef</code></a> or <a href="https://docs.rs/rune/0/rune/runtime/trait.UnsafeToMut.html"><code>UnsafeToMut</code></a>.</p>
<p><a href="https://docs.rs/rune/0/rune/runtime/trait.UnsafeToRef.html"><code>UnsafeToRef</code></a> and <a href="https://docs.rs/rune/0/rune/runtime/trait.UnsafeToMut.html"><code>UnsafeToMut</code></a> are conversion traits which are strictly
used internally to convert values into references. Its safety is documented in
the trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sandboxing"><a class="header" href="#sandboxing">Sandboxing</a></h1>
<p>Rune is capable of enforcing the following types of limitations:</p>
<ul>
<li>Memory limiting, where you specify the maxium amount of memory that Rune may
use either during compilation or execution.</li>
<li>Instruction budgeting, where you can specify how many instructions the virtual
machine is permitted to execute.</li>
</ul>
<h2 id="instruction-budgeting"><a class="header" href="#instruction-budgeting">Instruction budgeting</a></h2>
<p>Instruction budgeting is performed using the <a href="https://docs.rs/rune/latest/rune/runtime/budget/fn.with.html"><code>with</code> function</a> in the
<code>rune::budget</code> module.</p>
<p>The <code>with</code> function is capable of wrapping functions and futures. When wrapping
a future it ensures that the budget is suspended appropriately with the
execution of the future.</p>
<p>Budgeting is only performed on a per-instruction basis in the virtual machine.
What exactly constitutes an instruction might be a bit vague. But important to
note is that without explicit co-operation from native functions the budget
cannot be enforced. So care must be taken with the native functions that you
provide to Rune to ensure that the limits you impose cannot be circumvented.</p>
<h2 id="memory-limiting"><a class="header" href="#memory-limiting">Memory limiting</a></h2>
<p>Memory limiting is performed using the <a href="https://docs.rs/rune/latest/rune/runtime/budget/fn.with.html"><code>with</code> function</a> in the
<code>rune::alloc::limit</code> module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rune::alloc::prelude::*;
use rune::alloc::limit;

let f = limit::with(1024, || {
    let mut vec = Vec::&lt;u32&gt;::try_with_capacity(256)?;

    for n in 0..256u32 {
        vec.try_push(n)?;
    }

    Ok::&lt;_, rune_alloc::Error&gt;(vec.into_iter().sum::&lt;u32&gt;())
});

let sum = f.call()?;
assert_eq!(sum, 32640);
<span class="boring">}</span></code></pre></pre>
<p>In order for memory limiting to work as intended, you're may only use the
collections provided in the <a href="https://docs.rs/rune/latest/rune/alloc/index.html"><code>rune::alloc</code></a> module. These contain forks of
popular collections such as <a href="https://doc.rust-lang.org/std/collections/index.html"><code>std::collections</code></a> and <a href="docs.rs/hashbrown"><code>hashbrown</code></a>.</p>
<p>The <code>with</code> function is capable of wrapping <a href="%5Bfutures%5D:">functions</a> and [futures]. When
wrapping a future it ensures that the limit is suspended appropriately with the
execution of the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-stack"><a class="header" href="#the-stack">The stack</a></h1>
<p>Runestick is a stack-based virtual machine. It has two primary places where
things are stored. <em>The stack</em> and <em>the heap</em>. It has no registers.</p>
<p>Instructions in the virtual machine operate off the stack. Let's take a look at
the add operation with <code>--trace</code> and <code>--dump-stack</code>.</p>
<pre><code class="language-rune">1 + 3
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/the_stack/add.rn --trace --dump-stack
fn main() (0xe7fc1d6083100dcd):
  0000 = integer 1
    0+0 = 1
  0001 = integer 3
    0+0 = 1
    0+1 = 3
  0002 = add
    0+0 = 4
  0003 = return
    *empty*
== 4 (7.7691ms)
# stack dump after halting
frame #0 (+0)
    *empty*
</code></pre>
<p>Let's examine the stack after each instruction.</p>
<pre><code class="language-text">  0000 = integer 1
    0+0 = 1
</code></pre>
<p>We evaluate the <code>integer 1</code> instruction, which pushes an integer with the value
<code>1</code> onto the stack.</p>
<pre><code class="language-text">  0001 = integer 3
    0+0 = 1
    0+1 = 3
</code></pre>
<p>We evaluate the <code>integer 3</code> instruction, which pushes an integer with the value
<code>3</code> onto the stack.</p>
<pre><code class="language-text">  0002 = add
    0+0 = 4
</code></pre>
<p>We evaluate the <code>add</code> instruction which pops two values from the stack and adds
them together. Two integers in this instance would use built-in accelerated
implementations which performs addition.</p>
<pre><code class="language-text">  0003 = return
== 4 (7.7691ms)
</code></pre>
<p>We <code>return</code> from the virtual machine. The last value of the stack will be popped
as the return value.</p>
<pre><code class="language-text"># stack dump
frame #0 (+0)
</code></pre>
<p>This is the stack dump we see after the virtual machine has exited.
It tells us that at call frame <code>#0 (+0)</code>, the last and empty call frame at stack
position <code>+0</code> there is nothing on the stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-frames"><a class="header" href="#call-frames">Call frames</a></h1>
<p>Call frames are a cheap isolation mechanism available in the virtual machine.
They define a subslice in the stack, preventing the vm from accessing values
that are outside of the slice.</p>
<p>They have the following rules:</p>
<ul>
<li>Instructions cannot access values outside of their current call frame.</li>
<li>When we return from the call frame the subslice must be empty.</li>
</ul>
<p>If any these two conditions aren't maintained, the virtual machine will error.</p>
<p>Call frames fill two purposes. The subslice provides a well-defined variable
region. Stack-relative operations like <code>copy 0</code> are always defined relative to
the top of their call frame. Where <code>copy 0</code> would mean "copy from offset 0 of
the current stack frame".</p>
<p>They also provide a cheap security mechanism against <em>miscompilations</em>. This
might be made optional in the future once Rune is more stable, but for now it's
helpful to detect errors early and protect the user against bad instructions.
But don't mistake it for perfect security. Like <a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection">stack protection</a> which is
common in modern operating systems, the mechanism can be circumvented by
malicious code.</p>
<p>To look close at the mechanism, let's trace the following program:</p>
<pre><code class="language-rune">fn foo(a, b) {
    a + b
}

let a = 3;
foo(1, 2) + a
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/the_stack/call_and_add.rn --trace --dump-stack
fn main() (0xe7fc1d6083100dcd):
  0005 = integer 3
    0+0 = 3
  0006 = integer 1
    0+0 = 3
    0+1 = 1
  0007 = integer 2
    0+0 = 3
    0+1 = 1
    0+2 = 2
  0008 = call 0xbfd58656ec9a8ebe, 2 // fn `foo`
=&gt; frame 1 (1):
    1+0 = 1
    1+1 = 2
fn foo(arg, arg) (0xbfd58656ec9a8ebe):
  0000 = copy 0 // var `a`
    1+0 = 1
    1+1 = 2
    1+2 = 1
  0001 = copy 1 // var `b`
    1+0 = 1
    1+1 = 2
    1+2 = 1
    1+3 = 2
  0002 = add
    1+0 = 1
    1+1 = 2
    1+2 = 3
  0003 = clean 2
    1+0 = 3
  0004 = return
&lt;= frame 0 (0):
    0+0 = 3
    0+1 = 3
  0009 = copy 0 // var `a`
    0+0 = 3
    0+1 = 3
    0+2 = 3
  0010 = add
    0+0 = 3
    0+1 = 6
  0011 = clean 1
    0+0 = 6
  0012 = return
    *empty*
== 6 (45.8613ms)
# full stack dump after halting
  frame #0 (+0)
    *empty*
</code></pre>
<p>We're not going to go through each instruction step-by-step like in the last
section. Instead we will only examine the parts related to call frames.</p>
<p>We have a <code>call 0xbfd58656ec9a8ebe, 2</code> instruction, which tells the virtual
machine to jump to the function corresponding to the type hash
<code>0xbfd58656ec9a8ebe</code>, and isolate the top two values on the stack in the next
call frame.</p>
<p>We can see that the first argument <code>a</code> is in the <em>lowest</em> position, and the
second argument <code>b</code> is on the <em>highest</em> position. Let's examine the effects this
function call has on the stack.</p>
<pre><code class="language-text">    0+0 = 3
    0+1 = 1
    0+2 = 2
  0008 = call 0xbfd58656ec9a8ebe, 2 // fn `foo`
=&gt; frame 1 (1):
    1+0 = 1
    1+1 = 2
</code></pre>
<p>Here we can see a new call frame <code>frame 1</code> being allocated, and that it contains
two items: <code>1</code> and <code>2</code>.</p>
<p>We can also see that the items are offset from position <code>1</code>, which is the base
of the current call frame. This is shown as the addresses <code>1+0</code> and <code>1+1</code>. The
value <code>3</code> at <code>0+0</code> is no longer visible, because it is outside of the current
call frame.</p>
<p>Let's have a look at what happens when we <code>return</code>:</p>
<pre><code>    1+0 = 1
    1+1 = 2
    1+2 = 3
  0003 = clean 2
    1+0 = 3
  0004 = return
&lt;= frame 0 (0):
    0+0 = 3
    0+1 = 3
</code></pre>
<p>We call the <code>clean 2</code> instruction, which tells the vm to preserve the top of the
stack (<code>1+2</code>), and clean two items below it, leaving us with <code>3</code>. We then
<code>return</code>, which jumps us back to <code>frame 0</code>, which now has <code>0+0</code> visible <em>and</em>
our return value at <code>0+1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-guide"><a class="header" href="#compiler-guide">Compiler guide</a></h1>
<p>This is intended to be a guide into the compiler architecture for Rune for
people who want to hack on it.</p>
<blockquote>
<p><strong>Rune is in heavy development</strong> and this section is likely to change a lot.</p>
</blockquote>
<p>Compiling a rune program involves the following stages:</p>
<ul>
<li>Queue the initial source files specified by <a href="https://docs.rs/rune/0/rune/struct.Source.html#method.insert"><code>Source::insert</code></a>.</li>
<li><strong>Indexing and macro expansion</strong>, which processes tasks in the <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/worker.rs"><code>Worker</code></a>
queue until it is empty. These are:
<ul>
<li><code>Task::LoadFile </code> - Loads a single source into <a href="https://github.com/rune-rs/rune/tree/main/crates/rune/src/ast"><code>AST</code></a> file and indexes it.</li>
<li><code>Task::ExpandUnitWildcard</code> - A deferred expansion of a wildcard import. This
must happen after indexing because macros might expand into imports.</li>
</ul>
</li>
<li><strong>Compilation</strong> which processes a queue of items to be compiled and assembled.</li>
</ul>
<h2 id="indexing"><a class="header" href="#indexing">Indexing</a></h2>
<p>Indexing is primarily handled through the <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/indexing/index.rs"><code>Index</code></a> trait, which are
implemented for the type being indexed with the helper of the <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/indexing/index.rs"><code>Indexer</code></a>.</p>
<p>This walks through the <a href="https://github.com/rune-rs/rune/tree/main/crates/rune/src/ast"><code>AST</code></a> to be indexed and construct <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/item.rs">components</a> into an
item path for every:</p>
<ul>
<li>Functions, which adds components named after the function. <code>fn foo</code> would add
<code>foo</code>.</li>
<li>Closures, blocks, and nested functions, which adds an id component, like <code>$10</code>
where the number depends on how many sibling components there are. These are
effectively anonymous, and can't be referenced through the language directly.</li>
</ul>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>The compilation stage processed the entire <a href="https://github.com/rune-rs/rune/tree/main/crates/rune/src/ast"><code>AST</code></a> of every function that is
queued to be compiled and generates a sequence of instructions for them through
implementations of the <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/compiling/assemble/mod.rs"><code>Assemble</code></a> trait.</p>
<p>This stage uses the <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/query.rs"><code>Query</code></a> system to look up metadata about external items,
and any external item queried for is subsequently queued up to be built.</p>
<p>Consider the following unit:</p>
<pre><code class="language-rune">return foo();

fn foo() {
    2
}

fn bar() {
    3
}
</code></pre>
<p>Let's dump all dynamic functions in it:</p>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/compiler_guide/dead_code.rn --dump-functions --warnings
# dynamic functions
0x0 = {root}()
0x481411c4bd0a5f6 = foo()
---
== 2 (59.8¬µs)
</code></pre>
<p>As you can see, the code for <code>main::$0::bar</code> was <em>never generated</em>. This is
because it's a local function that is never called. And therefore never queried
for. So it's never queued to be built in the compilation stage.</p>
<h2 id="state-during-compilation"><a class="header" href="#state-during-compilation">State during compilation</a></h2>
<p>Each item in the AST is relatively isolated while they are being compiled. This
is one of the benefits of compiling for a stack-based virtual machine - the
compilation stage is relatively simple and <em>most</em> reasoning about what
instructions to emit can be made locally.</p>
<blockquote>
<p>Note that this quickly changes if you want to perform most forms of
optimizations. But it's definitely true for naive (and therefore fast!) code
generation.</p>
</blockquote>
<p>While compiling we keep track of the following state in the <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/compiling/compiler.rs"><code>Compiler</code></a></p>
<p>The source file and id that we are compiling for and global storage used for
macro-generated identifiers and literals. This is used to resolve values from
the AST through the corresponding <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/parse/resolve.rs"><code>Resolve</code></a> implementation. An example of this
is the <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/ast/lit_str.rs"><code>Resolve</code> implementation of <code>LitStr</code></a>.</p>
<p>We keep track of local variables using <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/compiling/scopes.rs"><code>Scopes</code></a>. Each block creates a new
scope of local variables, and this is simply a number that is incremented each
time a variable is allocated. These can either be named or anonymous. Each named
variable is associated with an offset relative to the current <a href="./call_frames.html">call
frame</a> that can be looked up when a variable needs to be used.</p>
<p>We maintain information on loops we're through <a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/compiling/loops.rs"><code>Loops</code></a>. This is a stack that
contains every loop we are nested in, information on the label in which the loop
terminates, and locals that would have to be cleaned up in case we encounter a
<a href="https://github.com/rune-rs/rune/blob/main/crates/rune/src/compiling/assemble/expr_break.rs"><code>break</code> expression</a>.</p>
<p>There are a couple more traits which are interesting during compilation:</p>
<ul>
<li><code>AssembleConst</code> - used for assembling constants.</li>
<li><code>AssembleFn</code> - used for assembling the content of functions.</li>
<li><code>AssembleClosure</code> - used for assembling closures.</li>
</ul>
<p>Let's look closer at how closures are assembled through AssembleClosure. Once a
closure is queried for, it is queued up to be built by the query system. The
closure procedure would be compiled and inserted into the unit separately at a
given item (like <code>main::$0::$0</code>). And when we invoke the closure, we assemble a
<em>call</em> to this procedure.</p>
<p>We can see this call by dumping all the dynamic functions in the following
script:</p>
<pre><code class="language-rune">let callable = || 42;
dbg!(callable());
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- run scripts/book/compiler_guide/closures.rn --emit-instructions --dump-functions
# instructions
fn main() (0x1c69d5964e831fc1):
  0000 = load-fn hash=0xbef6d5f6276cd45e // closure `3`
  0001 = copy offset=0 // var `callable`
  0002 = call-fn args=0
  0003 = pop
  0004 = pop
  0005 = return-unit

fn main::$0::$0() (0xbef6d5f6276cd45e):
  0006 = push value=42
  0007 = return address=top, clean=0
# dynamic functions
0xbef6d5f6276cd45e = main::$0::$0()
0x1c69d5964e831fc1 = main()
</code></pre>
<p>A function pointer is pushed on the stack <code>load-fn 0xca35663d3c51a903</code>, then
copied and called with zero arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h1>
<p>These are section of the book which have been deprecated for one reason or
another, but we still want to provide links to.</p>
<div style="break-before: page; page-break-before: always;"></div><p>You're probably looking for the section about <a href="template_literals.html">Template literals</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
