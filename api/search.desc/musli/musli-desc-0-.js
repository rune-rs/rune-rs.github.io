searchState.loadedDescShard("musli", 0, "  \nThe allocator associated with the context.\nProvides ergonomic access to the serialization context.\nContext associated with the decoder.\nContext associated with the encoder.\nTrait governing how types are decoded.\nDerive which automatically implements the <code>Decode</code> trait.\nDecoder returned by <code>Decoder::decode_buffer</code>.\nDecoder returned by <code>Decoder::decode_map</code>.\nDecoder returned by <code>Decoder::decode_map_entries</code>.\nDecoder used by <code>Decoder::decode_pack</code>.\nDecoder returned by <code>Decoder::decode_sequence</code>.\nDecoder returned by <code>Decoder::decode_option</code>.\nDecoder used by <code>Decoder::decode_variant</code>.\nTrait governing the implementation of a decoder.\nTrait governing how types are encoded.\nDerive which automatically implements the <code>Encode</code> trait.\nThe type of a map encoder.\nStreaming encoder for map pairs.\nSpecialized encoder for a struct variant.\nA simple pack that packs a sequence of elements.\nThe type of a sequence encoder.\nSpecialized encoder for a tuple variant.\nEncoder returned when encoding an optional value which is …\nEncoder for a struct variant.\nTrait governing how the encoder works.\nError produced by context.\nError associated with decoding.\nError associated with encoding.\nA fixed-size bytes storage which keeps track of how much …\nCoerce a type into a <code>Reader</code>.\nA mark during processing.\nMode of the context.\nMode associated with decoding.\nMode associated with encoding.\nType borrowed from self.\nReborrowed type.\nThe type returned by the encoder. For Encode …\nType encapsulating a static options for an encoding.\nTrait governing how a source of bytes is read.\nThe reader type.\nAn allocated buffer containing a valid string.\n<code>Decoder</code> with a different context returned by …\nConstructed <code>Encoder</code> with a different context.\nThe trait governing how a writer works.\nAdvance the context by <code>n</code> bytes of input.\nAllocation support for Müsli.\nAccess the underlying allocator.\nMissing variant field required to decode.\nBorrow the current reader.\nReborrow the current type.\nClear the state of the context, allowing it to be re-used.\nCollect and allocate a string from a <code>Display</code> …\nEncode a value that implements <code>Display</code> as a string.\nWrapper types for tweaking how something is encoded.\n<code>Context</code> implementations.\nReport a custom error, which is not encapsulated by the …\nReturn the context associated with the decoder.\nAccess the context associated with the encoder.\nTraits for generically dealing with a decoding framework.\nDecode the given input.\nDecode the current decoder into the value <code>T</code>.\nDecode the given input using the associated mode.\nDecode dynamically through a <code>Visitor</code>.\nDecode a fixed-length array.\nDecode a boolean.\nBuffer the current decoder into a buffer that can be used …\nDecode the given input as bytes using the associated mode.\nDecode a sequence of bytes whos length is encoded in the …\nDecode a character.\nDecode a unit.\nDecode a 32-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 128-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a <code>isize</code>.\nDecode a map who’s size is not known at compile time.\nSimplified decoding a map of unknown length.\nDecode a map using a simplified function.\nDecode an unknown number using a visitor.\nDecode an optional value.\nConstruct an unpack that can decode more than one element …\nDecode a sequence.\nDecode a sequence with a <code>hint</code> indicating its expected …\nDecode a string slice from the current decoder.\nDecode a 128-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode an unsized value by reference through the specified …\nDecode the given unsized value using the associated mode.\nDecode an unsized value as bytes by reference through the …\nDecode the given unsized value as bytes using the …\nDecode a <code>usize</code>.\nDecode a variant using a closure.\nThis is an attribute macro that must be used when …\nTraits for generically dealing with an encoding framework.\nEncode the given output.\nEncode the value <code>T</code> into the current encoder.\nEncode fixed-length array.\nEncode a boolean value.\nEncode a sequence of bytes.\nEncode the given slices of bytes in sequence, with one …\nEncode a character.\nEncode a unit or something that is completely empty.\nEncode a 32-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 128-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a <code>isize</code>.\nEncode a map with a known length <code>len</code>.\nEncode a map through pairs with a known length <code>len</code>.\nEncode a map using a closure.\nSimplified encoding for a struct variant.\nEncode an optional value that is absent.\nConstruct a pack that can encode more than one element at …\nEncodes a pack using a closure.\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence using a closure.\nSimplified encoding for a tuple variant.\nEncode an optional value that is present.\nEncode a string.\nEncode a 128-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nSimplified encoding for a unit variant.\nEncode a <code>usize</code>.\nEncode a variant.\nEncode a variant using a closure.\nThis is an attribute macro that must be used when …\nIndicate that we’ve entered an enum with the given <code>name</code>.\nTrace a that a map key has been entered.\nTrace that we’ve entered the given named field.\nTrace a sequence field.\nIndicate that we’ve entered a struct with the given <code>name</code>.\nTrace that we’ve entered the given unnamed field.\nTrace that we’ve entered the given variant in an enum.\nExpected another field to decode.\nThe value for the given tag could not be collected.\nFormat the human-readable message that should occur if the …\nAn expectation error. Every other implementation defers to …\nWrite a buffer to the current writer.\nFixed containers.\nReturns the argument unchanged.\nDetailed documentation for Müsli\nCore encoding hints.\nCalls <code>U::from(self)</code>.\nConvert the type into a reader.\nEncountered an unsupported field tag.\nEncountered an unsupported field tag.\nEncountered an unsupported variant field.\nReport that an invalid variant tag was encountered.\nTrace that we’ve left the last enum that was entered.\nTrace that we’ve left the last field that was entered.\nTrace that we’ve left the last map field that was …\nTrace that we’ve left the last sequence index that was …\nTrace that we’ve left the last struct that was entered.\nTrace that we’ve left the last variant that was entered.\nKeep an accurate record of the position within the reader.\nHelper macros for use with Musli.\nGenerate a map function which maps an error using the …\nGenerate a map function which maps an error using the …\nReturn a mark which acts as a checkpoint at the current …\nReport an error based on a mark.\nReport an error based on a mark.\nReport a message as an error.\nMissing adjacent tag when decoding.\nMissing variant field required to decode.\nIndicate that a variant tag could not be determined.\nType that describe a mode of encoding.\nTrait fills for <code>#[no_std]</code> environments.\nSerialization options.\nPeek the next value.\nRead a slice into the given buffer.\nRead an array out of the current reader.\nRead a single byte.\nRead a slice out of the current reader.\nTrait governing how to read bytes.\nSkip over the given number of bytes.\nSkip over the current next value.\nEfficient binary storage encoding for Müsli.\nThis is a variant of <code>Decoder::skip</code>, but instead of …\nTrying to decode an uninhabitable type.\nThis is an attribute macro that must be used when …\nConstruct an decoder with a different context.\nConstruct an encoder with a different context.\nWrapper for integrating musli with I/O types like std::io.\nWrite a single byte.\nWrite bytes to the current writer.\nTrait governing how to write bytes.\nAn allocator that can be used in combination with a …\nAn array that can conveniently be used as a buffer, by …\nThe default stack buffer size for the default allocator …\nAn allocator which cannot allocate anything.\nA raw buffer allocated through an <code>Allocator</code>.\nThe type of an allocated buffer.\nThe static system allocator instance.\nA no-std compatible slice-based allocator that can be used …\nWrapper around a buffer that is guaranteed to be a valid …\nSystem buffer that can be used in combination with an …\nA vector backed by an <code>Allocator</code>.\nGet a mutable pointer into the buffer.\nGet a pointer into the buffer.\nGet the initialized part of the buffer as a slice.\nClear the buffer vector.\nCall the given block <code>$body</code> with the default allocator.\nWrite a buffer of the same type onto the current buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the buffer is empty.\nGet the number of initialized elements in the buffer.\nConstruct a new allocator.\nConstruct a new disabled allocator.\nConstruct a new slice allocator.\nConstruct a new buffer with the default size of …\nConstruct a new buffer vector.\nConstruct a new string buffer in the provided allocator.\nConstruct a new buffer vector.\nConstruct an empty uninitialized raw vector with an …\nPop a single item from the buffer.\nWrite a single item.\nResize the buffer.\nTry to merge one buffer with another.\nConstruct a new buffer with a custom size.\nWrite the given number of bytes.\nTreat <code>T</code> as if its bytes.\nTreat <code>T</code> as if its packed.\nEnsures that the given value <code>T</code> is encoded as a sequence.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new sequence wrapper.\nA simple non-diagnostical capturing context.\nTrait governing errors raised during encodeing or decoding.\nThe default context which uses an allocator to track the …\nA collected error which has been context decorated.\nIndicates that an error occurred during encoding. This is …\nA simple non-diagnostical capturing context which ignores …\nA simple non-diagnostical capturing context which simply …\nConstruct a custom error.\nIterate over all collected errors.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConfigure the context to visualize type information, and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCollect an error from something that can be displayed.\nConstruct a new default context using the static <code>System</code> …\nConstruct a new same-error context with a custom allocator.\nConstruct a new capturing context using the <code>System</code> …\nConstruct a new ignoring context with a custom allocator.\nGenerate a line-separated report of all collected errors.\nConstruct an error or panic.\nConstruct an error or panic.\nConstruct a new default context using the provided …\nConstruct a new <code>Same</code> context with a custom allocator.\nConstruct a new capturing allocator.\nConstruct a new ignoring context.\nTrait that allows a type to be repeatedly coerced into a …\nBytes decoder to use.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nTrait governing how types are decoded.\nDerive which automatically implements the <code>Decode</code> trait.\nDecoder returned by <code>Decoder::decode_buffer</code>.\nTrait governing how types are decoded as bytes.\nThe decoder to use for a key.\nThe decoder to use for a tuple field index.\nThe decoder to use for a tuple field value.\nThe decoder to use for a tuple field index.\nDecoder returned by <code>Decoder::decode_map</code>.\nDecoder returned by <code>Decoder::decode_map_entries</code>.\nThe decoder for individual items.\nDecode to an owned value.\nDecoder used by <code>Decoder::decode_pack</code>.\nTrait governing how a type is decoded as a packed value.\nDecoder returned by <code>MapDecoder::decode_remaining_entries</code>.\nDecoder returned by <code>Decoder::decode_sequence</code>.\nDecoder returned by <code>Decoder::decode_option</code>.\nThe decoder to use for the variant tag.\nTrait governing how types are decoded specifically for …\nA trait implemented for types which can only be decoded by …\nA trait implemented for types which can be visited by …\nThe decoder to use for a tuple field value.\nThe decoder to use for the variant value.\nDecoder used by <code>Decoder::decode_variant</code>.\nTrait governing the implementation of a decoder.\nThe decoder we reborrow as.\nTrait governing how to decode a sequence of map pairs.\nTrait governing how to decode a map entry.\nError associated with decoding.\nTrait governing how to decode a sequence of pairs.\nMode associated with decoding.\nThe value produced.\nThe value produced by the visitor.\nTrait governing how to decode a sequence.\nA length hint.\nIndicates if skipping was performed.\nIndicates that skipping was successfully performed.\nString decoder to use.\nA visitor for data where we might need to borrow without …\nIndicates that skipping was not supported.\nTrait governing how to decode a variant.\nVisitor capable of decoding any type into a value …\n<code>Decoder</code> with a different context returned by …\nConstruct a size hint of unknown size.\nBorrow self as a new decoder.\nReturn the context associated with the decoder.\nDecode the given input.\nDecode the current decoder into the value <code>T</code>.\nDecode dynamically through a <code>Visitor</code>.\nDecode a fixed-length array.\nDecode a boolean.\nBuffer the current decoder into a buffer that can be used …\nDecode the given input as bytes.\nDecode a sequence of bytes whos length is encoded in the …\nDecode a character.\nDecode a unit.\nDecode the next key. This returns <code>Ok(None)</code> where there are …\nTry to return the decoder for the first value in the pair.\nDecode the value in the map.\nDecode a 32-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 128-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a <code>isize</code>.\nReturn the decoder for the first value in the pair.\nDecode a map who’s size is not known at compile time.\nSimplified decoding a map of unknown length.\nDecode a map using a simplified function.\nReturn decoder to decode the next element.\nDecode an unknown number using a visitor.\nDecode an optional value.\nConstruct an unpack that can decode more than one element …\nDecode the given input as bytes.\nReturn simplified decoder for remaining entries.\nDecode a sequence.\nDecode a sequence with a <code>hint</code> indicating its expected …\nDecode a string slice from the current decoder.\nReturn the decoder for the first value in the pair.\nDecode a 128-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode the given input using a closure as visitor.\nDecode an unsized value by reference through the specified …\nDecode the given input using a closure as visitor.\nDecode an unsized value as bytes by reference through the …\nDecode a <code>usize</code>.\nDecode the second value in the pair..\nDecode the second value in the pair..\nDecode a variant using a closure.\nEnd entries decoding.\nDecode the next map entry as a tuple.\nConstruct an exactly sized hint.\nFormat the human-readable message that should occur if the …\nFormat an error indicating what was expected by this …\nFormat the human-readable message that should occur if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCoerce into an <code>Option</code>.\nIndicates if a skip was performed.\nIndicates if a skip was not supported.\nDecode the next element of the given type, erroring in …\nGet a size hint or a default value.\nGet a size hint for the size of the map being decoded.\nGet a size hint for the size of the map being decoded.\nGet a size hint of known remaining elements.\nGet a size hint of known remaining elements.\nSkip over the current next value.\nDecode the given input.\nTry to decode the next element.\nDecode the next element of the given type.\nThis is a variant of <code>Decoder::skip</code>, but instead of …\nIndicates that the visited type is a <code>bool</code>.\nVisit a string that is borrowed directly from the source …\nIndicates that the visited type is <code>bytes</code>.\nIndicates that the visited type is a <code>char</code>.\nIndicates that the visited type is empty.\nIndicates that the visited type is a <code>f32</code>.\nIndicates that the visited type is a <code>f64</code>.\nIndicates that the visited type is a <code>i128</code>.\nIndicates that the visited type is a <code>i16</code>.\nIndicates that the visited type is a <code>i32</code>.\nIndicates that the visited type is a <code>i64</code>.\nIndicates that the visited type is a <code>i8</code>.\nIndicates that the visited type is a <code>isize</code>.\nIndicates that the visited type is a map.\nIndicates that the visited type is an optional type.\nVisit an owned value.\nVisit a value reference that is provided from the decoder …\nIndicates that the visited type is a sequence.\nIndicates that the visited type is <code>string</code>.\nIndicates that the visited type is a <code>u128</code>.\nIndicates that the visited type is a <code>u16</code>.\nIndicates that the visited type is a <code>u32</code>.\nIndicates that the visited type is a <code>u64</code>.\nIndicates that the visited type is a <code>u8</code>.\nIndicates that the encoding does not support dynamic types.\nIndicates that the visited type is a <code>usize</code>.\nIndicates that the visited type is a variant.\nConstruct an decoder with a different context.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nTrait governing how types are encoded.\nDerive which automatically implements the <code>Encode</code> trait.\nTrait governing how a type is encoded as bytes.\nThe encoder returned when advancing the map encoder to …\nEncode the next pair.\nThe encoder returned when advancing the map encoder to …\nThe encoder returned when advancing the map encoder to …\nThe encoder returned when advancing the map encoder to …\nThe type of a map encoder.\nStreaming encoder for map pairs.\nSpecialized encoder for a struct variant.\nThe encoder returned when advancing the sequence encoder.\nA simple pack that packs a sequence of elements.\nTrait governing how a type is encoded as a packed value.\nThe type of a sequence encoder.\nSpecialized encoder for a tuple variant.\nEncoder returned when encoding an optional value which is …\nThe encoder returned when advancing the map encoder to …\nTrait governing how types are encoded specifically for …\nThe encoder returned when advancing the map encoder to …\nEncoder for a struct variant.\nTrait governing how the encoder works.\nTrait governing how to encode a map entry.\nTrait governing how to encode a map entry.\nError associated with encoding.\nEncoder for a map.\nMode associated with encoding.\nThe type returned by the encoder. For Encode …\nResult type of the encoder.\nResult type of the encoder.\nResult type of the encoder.\nResult type of the encoder.\nResult type of the encoder.\nTrait governing how to encode a sequence.\nTrait governing how to encode a variant.\nConstructed <code>Encoder</code> with a different context.\nEncode a value that implements <code>Display</code> as a string.\nAccess the context associated with the encoder.\nEncode the given output.\nEncode the value <code>T</code> into the current encoder.\nEncode fixed-length array.\nEncode a boolean value.\nEncode the given output as bytes.\nEncode a sequence of bytes.\nEncode the given slices of bytes in sequence, with one …\nEncode a character.\nReturn encoder for the second element in the variant.\nEncode a unit or something that is completely empty.\nEncode the next pair.\nSimplified encoder for a map entry, which ensures that …\nReturn the encoder for the key in the entry.\nReturn encoder for value in the entry.\nEncode a 32-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 128-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a <code>isize</code>.\nReturn the encoder for the key in the entry.\nEncode a map with a known length <code>len</code>.\nEncode a map through pairs with a known length <code>len</code>.\nEncode a map using a closure.\nSimplified encoding for a struct variant.\nReturn encoder for the next element.\nEncode an optional value that is absent.\nConstruct a pack that can encode more than one element at …\nEncodes a pack using a closure.\nEncode the given output as bytes.\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence using a closure.\nSimplified encoding for a tuple variant.\nEncode an optional value that is present.\nEncode a string.\nReturn the encoder for the first element in the variant.\nEncode a 128-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nSimplified encoding for a unit variant.\nEncode a <code>usize</code>.\nReturn encoder for value in the entry.\nEncode a variant.\nEncode a variant using a closure.\nAn expectation error. Every other implementation defers to …\nComplete encoding map entries.\nStop encoding this pair.\nFinish encoding pairs.\nFinish encoding the sequence.\nEnd the variant encoder.\nInsert the pair immediately.\nInsert the pair immediately.\nInsert a pair immediately.\nInsert the variant immediately.\nPush an element into the sequence.\nEncode the given output.\nConstruct an encoder with a different context.\nA fixed-size bytes storage which keeps track of how much …\nCoerce into the mutable slice of initialized memory which …\nCoerce into the slice of initialized memory which is …\nClear the FixedBytes container.\nTry and extend from the given slice.\nCoerce into the underlying bytes if all of them have been …\nTest if the current container is empty.\nGet the length of the collection.\nConstruct a new fixed bytes array storage.\nTry and push a single byte.\nGet the remaining capacity of the FixedBytes.\nConstruct a fixed bytes while asserting that the given …\nTry and extend from the given slice.\nThe data model of Müsli.\nDeriving <code>Encode</code> and <code>Decode</code>.\nA hint passed in when encoding a map.\nA hint passed in when encoding a sequence.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe size for the map being encoded.\nThe size for the sequence being encoded.\nReturn the size hint that corresponds to this overall hint.\nReturn the size hint that corresponds to this overall hint.\nCreate a new struct hint with the specified size.\nCreate a new sequence hint with the specified size.\nThe binary encoding mode.\nThe text encoding mode.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe resulting type after obtaining ownership.\nA generalization of <code>Clone</code> to borrowed data.\nUses borrowed data to replace owned data, usually by …\nCreates owned data from borrowed data, usually by cloning.\nBig endian byte order.\n<code>Options</code> builder.\nByte order to use when encoding numbers.\nFixed number encoding.\nUse fixed float encoding.\nFloat serialization mode.\nInteger serialization mode.\nUse the same serialization as integers, after coercing the …\nLittle endian byte order.\nThe native byte order.\nThe network byte order.\nType encapsulating a static options for an encoding.\n16 bit width.\n32 bit width.\n64 bit width.\n8 bit width.\nVariable number encoding.\nUse variable float encoding.\nThe width of a numerical type.\nBuild a flavor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStart building new options.\nSpecify which byte order to use, if that’s relevant.\nIndicates the configuration of float serialization.\nIndicates if an integer serialization should be variable.\nSpecify how lengths should be serialized.\nIf length is set to <code>Integer::Fixed</code>, specify the width of …\nAllows for treating string keys as numbers.\nCoerce a type into a <code>Reader</code>.\nLimit the number of bytes that can be read out of a reader …\nType borrowed from self.\nTrait governing how a source of bytes is read.\nThe reader type.\nAn efficient <code>Reader</code> wrapper around a slice.\nGet the remaining contents of the reader as a slice.\nBorrow the current reader.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the type into a reader.\nKeep an accurate record of the position within the reader.\nConstruct a new instance around the specified slice.\nPeek the next value.\nRead a slice into the given buffer.\nRead an array out of the current reader.\nRead a single byte.\nRead a slice out of the current reader.\nGet remaining bytes in the reader.\nGet the remaining data in the limited reader.\nSkip over the given number of bytes.\nThe default configuration.\nSetting up encoding with parameters.\nContains the error value\nError raised during storage encoding.\nDefault options to use with <code>Encoding</code>.\nContains the success value\nConvenient result alias for use with <code>musli::storage</code>.\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given string using the …\nDecode the given type <code>T</code> from the given string using the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>Encoding</code> instance which uses <code>OPTIONS</code>.\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to a <code>Vec</code> using the <code>DEFAULT</code> <code>Encoding</code>.\nEncode the given value to a <code>Vec</code> using the current <code>Encoding</code>.\nEncode the given value to a <code>Vec</code> using the current <code>Encoding</code>.\nEncode the given value to the given <code>Write</code> using the <code>DEFAULT</code>\nEncode the given value to the given <code>Write</code> using the current\nEncode the given value to the given <code>Write</code> using the current\nChange the mode of the encoding.\nChange the options of the encoding.\nWrap a type so that it implements <code>Reader</code> and <code>Writer</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrap a type so that it implements <code>Reader</code> and <code>Writer</code>.\nA writer that writes against an underlying <code>Vec</code>.\nReborrowed type.\nThe trait governing how a writer works.\nReborrow the current type.\nWrite a buffer to the current writer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCoerce into inner buffer.\nConstruct a new buffer writer.\nWrite a single byte.\nWrite bytes to the current writer.")