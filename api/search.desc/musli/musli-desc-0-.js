searchState.loadedDescShard("musli", 0, "  \nPlease refer to the main musli documentation.\nPlease refer to the main musli documentation.\nPlease refer to the main musli documentation.\nPlease refer to the main musli documentation.\nWrapper types which ensures that a given field is encoded …\nTraits for generically dealing with a decoding framework.\nThe <code>Encode</code> and <code>Decode</code> derives\nTraits for generically dealing with an encoding framework.\nTrait governing what error types associated with the …\nType that describe a mode of encoding.\nModule that provides a never type which conveniently …\nUtility functions for when interacting with Müsli.\nEnsures that the given value <code>T</code> is encoded as bytes.\nTreat <code>T</code> as its packed.\nEnsures that the given value <code>T</code> is encoded as a sequence.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new sequence wrapper.\nAny numerical type of unknown kind.\nThe length isn’t known.\nAny type.\nTrait that allows a type to be repeatedly coerced into a …\nA boolean type.\nThe type returned when the decoder is buffered.\nA byte array.\nA character type.\nTrait governing how types are decoded.\nPlease refer to the main musli documentation.\nDecode to a <code>&#39;static</code> value.\nTrait governing the implementation of a decoder.\nThe decoder we reborrow as.\nThe encoder to use for the pack.\nThe decoder for individual items.\nThe decoder to use for a key.\nError type raised by calling <code>as_decoder</code>.\nError type raised by this unpack.\nError type.\nError type.\nError type.\nError type.\nError type raised by the decoder.\nAn error type.\nThe error produced.\nThe length is exactly known.\nA 32-bit float.\nA 64-bit float.\nThe decoder to use for a tuple field index.\nA signed 128-bit integer.\nA signed 16-bit integer.\nA signed 32-bit integer.\nA signed 64-bit integer.\nA signed 8-bit integer.\nA isize-typed value.\nA length hint.\nA map with a length hint.\nMap decoder implementation.\nThe type as a number.\nA number hint.\nA visitor capable of processing arbitrary number values.\nThe output of the visitor.\nThe value produced.\nAn optional value.\nPack decoder implementation.\nA pack that can construct encoders.\nTrait governing how to decode a field.\nTrait governing how to decode a sequence of pairs.\nThe decoder to use for a tuple field value.\nA sequence with a length hint.\nSequence decoder implementation.\nTrait governing how to decode a sequence.\nDecoder for a value that is present.\nA string with the given length.\nDecoder for a struct.\nThe decoder to use for the variant tag.\nThe value being visited.\nTuple decoder implementation.\nA type hint.\nAn unsigned 128-bit integer.\nAn unsigned 16-bit integer.\nAn unsigned 32-bit integer.\nAn unsigned 64-bit integer.\nAn unsigned 8-bit integer.\nA unit type or an empty value.\nA usize-typed value.\nA visitor for data where it might be possible to borrow it …\nA variant.\nThe decoder to use for the variant value.\nDecoder for a variant.\nTrait governing how to decode a variant.\nBorrow self as a new decoder.\nDecode the given input.\nDecode a fixed-length array.\nDecode a fixed-length array.\nDecode a boolean.\nDecode a boolean.\nBuffer the current decoder into a buffer that can be used …\nBuffer the current decoder into a buffer that can be used …\nDecode a sequence of bytes whos length is encoded in the …\nDecode a sequence of bytes whos length is encoded in the …\nDecode a character.\nDecode a character.\nDecode a 32-bit floating point value.\nDecode a 32-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 128-bit signed integer.\nDecode a 128-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a 8-bit signed integer.\nDecode Rusts <code>isize</code>.\nDecode Rusts <code>isize</code>.\nDecode a map of unknown length.\nDecode a map of unknown length.\nDecode an unknown number using a visitor that can handle …\nDecode an unknown number using a visitor that can handle …\nDecode an optional value.\nDecode an optional value.\nConstruct an unpack that can decode more than one element …\nConstruct an unpack that can decode more than one element …\nDecode a sequence.\nDecode a sequence.\nDecode a string slice from the current decoder.\nDecode a string slice from the current decoder.\nDecode a struct which has an expected <code>len</code> number of …\nDecode a struct which has an expected <code>len</code> number of …\nDecode a fixed-length sequence of elements of length <code>len</code>.\nDecode a fixed-length sequence of elements of length <code>len</code>.\nDecode a 128-bit unsigned integer.\nDecode a 128-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode a unit or something that is empty.\nDecode a unit or something that is empty.\nDecode Rusts <code>usize</code>.\nDecode Rusts <code>usize</code>.\nReturn decoder for a variant.\nReturn decoder for a variant.\nStop decoding the current pack.\nStop decoding the current sequence.\nEnd the pair decoder.\nEnd the pair decoder.\nFormat the human-readable message that should occur if the …\nFormat an error indicating what was expected by this …\nFormat an error indicating what was expected by this …\nReturn the decoder for the first value in the pair.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn decoder to unpack the next element.\nDecode the next element.\nDecode the next key. This returns <code>Ok(None)</code> where there are …\nDecode the second value in the pair..\nGet a size hint of known remaining elements.\nGet a size hint of known remaining elements.\nCoerce into a size hint.\nIndicate that the second value should be skipped.\nIndicate that the second value should be skipped.\nReturn the decoder for the first value in the pair.\nReturn a TypeHint indicating which type is being produced …\nReturn a TypeHint indicating which type is being produced …\nDecode the second value in the pair..\nVisit a string that is provided from the decoder in any …\nVisit a string that is provided from the decoder in any …\nVisit a string that is borrowed directly from the source …\nVisit a string that is borrowed directly from the source …\nVisit <code>f32</code>.\nVisit <code>f32</code>.\nVisit <code>f64</code>.\nVisit <code>f64</code>.\nVisit <code>i128</code>.\nVisit <code>i128</code>.\nVisit <code>i16</code>.\nVisit <code>i16</code>.\nVisit <code>i32</code>.\nVisit <code>i32</code>.\nVisit <code>i64</code>.\nVisit <code>i64</code>.\nVisit <code>i8</code>.\nVisit <code>i8</code>.\nVisit <code>isize</code>.\nVisit <code>isize</code>.\nVisit an owned value.\nVisit an owned value.\nVisit <code>u128</code>.\nVisit <code>u128</code>.\nVisit <code>u16</code>.\nVisit <code>u16</code>.\nVisit <code>u32</code>.\nVisit <code>u32</code>.\nVisit <code>u64</code>.\nVisit <code>u64</code>.\nVisit <code>u8</code>.\nVisit <code>u8</code>.\nVisit <code>usize</code>.\nVisit <code>usize</code>.\nTrait governing how types are encoded.\nPlease refer to the main musli documentation.\nTrait governing how the encoder works.\nThe encoder returned when advancing the sequence encoder.\nEncode the next pair.\nThe error raised by a sequence encoder.\nThe error raised by a map encoder.\nThe error raised by a map encoder.\nThe error raised by a map encoder.\nThe error raised by an encoder.\nThe encoder returned when advancing the map encoder to …\nThe type of a map encoder.\nResult type of the encoder.\nResult type of the encoder.\nResult type of the encoder.\nResult type of the encoder.\nThe type returned by the encoder. For Encode …\nA simple pack that packs a sequence of elements.\nTrait governing how to encode a sequence of pairs.\nEncoder for a sequence of pairs.\nThe encoder returned when advancing the map encoder to …\nThe type of a sequence encoder.\nTrait governing how to encode a sequence.\nEncoder returned when encoding an optional value which is …\nEncoder that can encode a struct.\nThe encoder returned when advancing the map encoder to …\nThe type of a tuple encoder.\nThe encoder returned when advancing the map encoder to …\nEncoder for a struct variant.\nTrait governing how to encode a variant.\nEncode the given output.\nEncode fixed-length array.\nEncode fixed-length array.\nEncode a boolean value.\nEncode a boolean value.\nEncode a sequence of bytes.\nEncode a sequence of bytes.\nEncode the given slices of bytes in sequence, with one …\nEncode the given slices of bytes in sequence, with one …\nEncode a character.\nEncode a character.\nEncode a 32-bit floating point value.\nEncode a 32-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 128-bit signed integer.\nEncode a 128-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a 8-bit signed integer.\nEncode Rusts <code>isize</code>.\nEncode Rusts <code>isize</code>.\nEncode a map with a known length <code>len</code>.\nEncode a map with a known length <code>len</code>.\nEncode an optional value that is absent.\nEncode an optional value that is absent.\nConstruct a pack that can encode more than one element at …\nConstruct a pack that can encode more than one element at …\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence with a known length <code>len</code>.\nEncode an optional value that is present.\nEncode an optional value that is present.\nEncode a string.\nEncode a string.\nEncode a struct.\nEncode a struct.\nEncode a tuple with a known length <code>len</code>.\nEncode a tuple with a known length <code>len</code>.\nEncode a 128-bit unsigned integer.\nEncode a 128-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nEncode a unit or something that is completely empty.\nEncode a unit or something that is completely empty.\nEncode Rusts <code>usize</code>.\nEncode Rusts <code>usize</code>.\nEncode an struct enum variant.\nEncode an struct enum variant.\nEnd the sequence.\nFinish encoding pairs.\nStop encoding this pair.\nEnd the variant encoder.\nAn expectation error. Every other implementation defers to …\nReturn the encoder for the first element in the pair.\nInsert a pair immediately.\nInsert a pair immediately.\nInsert the pair immediately.\nInsert the pair immediately.\nInsert the variant immediately.\nInsert the variant immediately.\nPrepare encoding of the next element.\nEncode the next pair.\nPush an element into the sequence.\nPush an element into the sequence.\nReturn encoder for the second element in the pair.\nReturn the encoder for the first element in the variant.\nReturn encoder for the second element in the variant.\nTrait governing errors raised during encodeing or decoding.\nConstruct a custom error.\nThe value for the given tag could not be collected.\nEncountered an unsupported number tag.\nEncountered an unsupported variant field.\nIndicate that a variant wasn’t supported by tag.\nCollect an error from something that can be displayed.\nMissing variant field required to decode.\nIndicate that a variant tag could not be determined.\nTrying to decode an uninhabitable type.\nThe default encoding mode.\nThe trait for a mode.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIndicate if the current mode is human readable.\nAn uninhabitable never type which implements all possible …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstruct an anonymous bytes visitor from a function.\nConstruct an anonymous string visitor from a function.")