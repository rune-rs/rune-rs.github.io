searchState.loadedDescShard("musli", 0, "  \nA raw allocation from the allocator.\nAn allocator that can be used in combination with a …\nThe allocator associated with the context.\nThe allocator associated with the decoder.\nProvides ergonomic access to the serialization context.\nContext associated with the decoder.\nContext associated with the encoder.\nTrait governing how types are decoded.\nTrait governing how types are decoded.\nDerive which automatically implements the <code>Decode</code> trait.\nDecoder returned by <code>Decoder::decode_buffer</code>.\nDecoder returned by <code>Decoder::decode_map</code>.\nDecoder returned by <code>Decoder::decode_map_entries</code>.\nDecoder used by <code>Decoder::decode_pack</code>.\nDecoder returned by <code>Decoder::decode_sequence</code>.\nDecoder returned by <code>Decoder::decode_option</code>.\nDecoder used by <code>Decoder::decode_variant</code>.\nTrait governing the implementation of a decoder.\nTrait governing how types are encoded.\nTrait governing how types are encoded.\nThe underlying type being encoded.\nThe underlying type being encoded.\nDerive which automatically implements the <code>Encode</code> trait.\nThe type of a map encoder.\nStreaming encoder for map pairs.\nEncoder for a map variant.\nA simple pack that packs a sequence of elements.\nThe type of a sequence encoder.\nEncoder for a sequence variant.\nEncoder returned when encoding an optional value which is …\nEncoder for a variant.\nTrait governing how the encoder works.\nError produced by the context.\nError associated with decoding.\nError associated with encoding.\nA fixed-size bytes storage which keeps track of how much …\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nWhether the allocations returned by this allocatore is …\nCoerce a type into a <code>Reader</code>.\nCoerce a type into a <code>Writer</code>.\nA mark during processing.\nMode associated with decoding.\nMode associated with encoding.\nType borrowed from self.\nReborrowed type.\nThe output of the writer which will be returned after …\nThe value returned from writing the value.\nType encapsulating a static options for an encoding.\nTrait governing how a source of bytes is read.\nThe reader type.\nType that can be cloned from the reader.\nA clone of the current decoder.\nThe trait governing how a writer works.\nThe writer type.\nDetailed documentation for Müsli\nAdvance the context by <code>n</code> bytes of input.\nAllocation support for Müsli.\nConstruct an empty uninitialized raw allocation with an …\nAccess the underlying allocator.\nConstruct an empty uninitialized raw vector with an …\nCoerce into the underlying value being encoded.\nCoerce into the underlying value being encoded.\nBorrow the current reader.\nReborrow the current type.\nClear the state of the context, allowing it to be re-used.\nEncode a value that implements <code>Display</code> as a string.\nWrapper types for tweaking how something is encoded.\n<code>Context</code> implementations.\nReport a custom error, which is not encapsulated by the …\nReport an error based on a mark.\nAccess the context associated with the decoder.\nAccess the context associated with the encoder.\nTraits for generically dealing with a decoding framework.\nDecode the current value.\nDecode the current value.\nDecode the current decoder into the value <code>T</code>.\nDecode dynamically through a <code>Visitor</code>.\nDecode a fixed-length array.\nDecode a boolean.\nBuffer the current decoder into a buffer that can be used …\nDecode a sequence of bytes whos length is encoded in the …\nDecode a character.\nDecode a unit.\nDecode a 32-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 128-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a <code>isize</code>.\nDecode a map who’s size is not known at compile time.\nSimplified decoding a map of unknown length.\nDecode a map using a simplified function.\nDecode an unknown number using a visitor.\nDecode an optional value.\nConstruct an unpack that can decode more than one element …\nDecode a sequence.\nDecode a sequence with a <code>hint</code> indicating its expected …\nDecode a sequence of values.\nDecode a string slice from the current decoder.\nDecode a 128-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode an unsized value by reference through the specified …\nDecode an unsized value as bytes by reference through the …\nDecode a <code>usize</code>.\nDecode a variant using a closure.\nThis is an attribute macro that must be used when …\nTraits for generically dealing with an encoding framework.\nEncode the given output.\nEncode the given output.\nEncode the value <code>T</code> into the current encoder.\nEncode fixed-length array.\nEncode a boolean value.\nEncode a sequence of bytes.\nEncode the given slices of bytes in sequence, with one …\nEncode a character.\nEncode a unit or something that is completely empty.\nEncode a 32-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 128-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a <code>isize</code>.\nEncode a map with a known length <code>len</code>.\nEncode a map through pairs with a known length <code>len</code>.\nEncode a map using a closure.\nSimplified encoding for a struct variant.\nEncode an optional value that is absent.\nConstruct a pack that can encode more than one element at …\nEncodes a pack using a closure.\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence using a closure.\nSimplified encoding for a tuple variant.\nEncode a slice as a sequence.\nEncode a sequence extracted from an iterator of slices …\nEncode an optional value that is present.\nEncode a string.\nEncode a 128-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nSimplified encoding for a unit variant.\nEncode a <code>usize</code>.\nEncode a variant.\nEncode a variant using a closure.\nThis is an attribute macro that must be used when …\nIndicate that we’ve entered an enum with the given <code>name</code>.\nTrace a that a map key has been entered.\nTrace that we’ve entered the given named field.\nTrace a sequence field.\nIndicate that we’ve entered a struct with the given <code>name</code>.\nTrace that we’ve entered the given unnamed field.\nTrace that we’ve entered the given variant in an enum.\nFormat the human-readable message that should occur if the …\nAn expectation error. Every other implementation defers to …\nWrite a buffer to the current writer.\nFinalize the writer and return the output.\nFixed containers.\nReturns the argument unchanged.\nCore encoding hints.\nCalls <code>U::from(self)</code>.\nConvert the type into a reader.\nConvert the type into a writer.\nTest if the given type <code>T</code> is marked with the …\nTest if the given type <code>T</code> is marked with the …\nTest if the reader is at end of input.\nTrace that we’ve left the last enum that was entered.\nTrace that we’ve left the last field that was entered.\nTrace that we’ve left the last map field that was …\nTrace that we’ve left the last sequence index that was …\nTrace that we’ve left the last struct that was entered.\nTrace that we’ve left the last variant that was entered.\nKeep an accurate record of the position within the reader.\nHelper macros for use with Musli.\nGenerate a map function which maps an error using the …\nReturn a mark which acts as a checkpoint at the current …\nReport a message as an error.\nReport an error based on a mark.\nType that describe a mode of encoding.\nImplementation fills for <code>#[no_std]</code> environments.\nSerialization options.\nThe most efficient binary storage encoding for Müsli.\nPeek the next value.\nRead a slice into the given buffer.\nRead an array out of the current reader.\nRead a single byte.\nRead a slice out of the current reader.\nRead into the given buffer which might not have been …\nTrait governing how to read bytes.\nRestore the state of the context to the specified mark.\nThe number of fields in the type.\nThe number of fields in the type.\nSkip over the given number of bytes.\nSkip over the current next value.\nEfficient binary storage encoding for Müsli.\nTry to clone the reader.\nAttempt to clone the decoder so that it can be used …\nTry to quickly decode the specified value.\nTry to quickly encode the specified value.\nThis is a variant of <code>Decoder::skip</code>, but instead of …\nWrapper for integrating musli with I/O types like std::io.\nWrite a single byte.\nWrite bytes to the current writer.\nTrait governing how to write bytes.\nThe data model of Müsli.\nDeriving <code>Encode</code> and <code>Decode</code> in Müsli\nA value allocated through <code>Allocator::alloc</code>.\nA raw allocation from the allocator.\nAn allocation error.\nAn allocator that can be used in combination with a …\nAn array that can conveniently be used as a buffer, by …\nA Müsli-allocated pointer type that uniquely owns a heap …\nThe default stack buffer size for the default allocator …\nThe default allocator implementation.\nAn allocator which cannot allocate anything.\nWhether the allocations returned by this allocatore is …\nThe owned value.\nA no-std compatible slice-based allocator that can be used …\nA slice allocated buffer.\nThe trait over anything that can be treated as a buffer by …\nA Müsli-allocated UTF-8–encoded, growable string.\nSystem buffer that can be used in combination with an …\nA vector-backed allocation.\nThe local `ToOwned`` implementation for Musli’s …\nA Müsli-allocated contiguous growable array type, written …\nConstruct an empty uninitialized raw allocation with an …\nConstruct an empty uninitialized raw vector with an …\nGet a mutable pointer into the allocation.\nGet a pointer into the allocation.\nGet the initialized part of the buffer as a slice.\nGet the initialized part of the buffer as a slice.\nExtracts a string slice containing the entire <code>String</code>.\nReturns the capacity of the buffer.\nReturns this <code>String</code>’s capacity, in bytes.\nReturns the total number of elements the vector can hold …\nClear the buffer vector.\nCall the given block <code>body</code> with an instance of the …\nWrite a buffer of the same type onto the current buffer.\nWrite the given number of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a vector from raw parts.\nConverts a vector of bytes to a <code>String</code>.\nConverts a vector of bytes to a <code>String</code> without checking …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a <code>String</code> into a byte vector.\nDeconstruct a vector into its raw parts.\nCoerce into a std string.\nCoerce into a std vector.\nReturns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code>\nCheck if the buffer is empty.\nReturns the length of this <code>String</code>, in bytes, not <code>char</code>s or …\nReturns the number of elements in the vector, also …\nConstruct a new slice allocator around a <code>SliceBuffer</code>.\nConstruct a new buffer with the default size of …\nConstruct a new system allocator.\nConstruct a new disabled allocator.\nCreates a new empty <code>String</code>.\nConstruct a new buffer vector.\nAllocates memory on the heap and then places <code>x</code> into it.\nPop a single item from the buffer.\nAppends the given <code>char</code> to the end of this <code>String</code>.\nWrite a single item.\nAppends a given string slice onto the end of this <code>String</code>.\nAccess a reference to the raw underlying allocation.\nReserves capacity for at least <code>additional</code> more elements to …\nResize the buffer to fit at least additional elements.\nForces the length of the vector to <code>new_len</code>.\nTry to merge one buffer with another.\nSame as <code>default()</code> but allows for specifying a default …\nCreates a new empty <code>String</code> with at least the specified …\nConstruct a new buffer vector.\nConstruct a new buffer with a custom size.\nTreat <code>T</code> as if its bytes.\nTreat <code>T</code> as if its packed.\nEnsures that the given value <code>T</code> is encoded as a sequence.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new sequence wrapper.\nCapture an error of the specified type <code>E</code>.\nTrait governing errors raised during encodeing or decoding.\nThe default context which uses an allocator to track the …\nEmit an error of the specified type <code>E</code>.\nA collected error which has been context decorated.\nIndicates that an error occurred during encoding. This is …\nThe trait governing how error capture is implemented.\nAn iterator over available errors.\nDisable error capture.\nTrace configuration indicating that tracing is fully …\nA line-separated report of all errors.\nMarker type indicating that tracing is enabled.\nThe trait governing how tracing works in a <code>DefaultContext</code>.\nTrait for marker types indicating the tracing mode to use.\nConstruct a custom error.\nIterate over all reported errors.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCollect an error from something that can be displayed.\nConstruct a new default context using the <code>System</code> allocator.\nConstruct a new default context using the provided …\nGenerate a line-separated report of all reported errors.\nCoerce a captured error into a result.\nUnwrap the error marker or panic if there is no error.\nCapture the specified error type.\nEmit the specified error type <code>E</code>.\nEnable tracing through the current allocator <code>A</code>.\nIf tracing is enabled through <code>DefaultContext::with_trace</code>, …\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the visitor.\nThe allocator associated with the decoder.\nThe allocator associated with the visitor.\nTrait that allows a type to be repeatedly coerced into a …\nBytes decoder to use.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nWhether the type is packed. Packed types can be bitwise …\nTrait governing how types are decoded.\nDerive which automatically implements the <code>Decode</code> trait.\nDecoder returned by <code>Decoder::decode_buffer</code>.\nTrait governing how types are decoded as bytes.\nThe decoder to use for a key.\nThe decoder to use for a tuple field index.\nThe decoder to use for a tuple field value.\nThe decoder to use for a tuple field index.\nDecoder returned by <code>Decoder::decode_map</code>.\nDecoder returned by <code>Decoder::decode_map_entries</code>.\nThe decoder for individual items.\nDecode to an owned value.\nDecoder used by <code>Decoder::decode_pack</code>.\nTrait governing how a type is decoded as a packed value.\nDecoder returned by <code>MapDecoder::decode_remaining_entries</code>.\nDecoder returned by <code>Decoder::decode_sequence</code>.\nTrait used to decode a slice into a type.\nDecoder returned by <code>Decoder::decode_option</code>.\nThe decoder to use for the variant tag.\nTrait governing how types are decoded specifically for …\nA trait implemented for types which can only be decoded by …\nA trait implemented for types which can be visited by …\nThe decoder to use for a tuple field value.\nThe decoder to use for the variant value.\nDecoder used by <code>Decoder::decode_variant</code>.\nTrait governing the implementation of a decoder.\nThe decoder we reborrow as.\nTrait governing how to decode a sequence of map pairs.\nTrait governing how to decode a map entry.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nThe error produced by the visitor.\nError associated with decoding.\nThe error produced by the visitor.\nWhether the type is packed. Packed types can be bitwise …\nTrait governing how to decode a sequence of pairs.\nThe mode of the decoder.\nMode associated with decoding.\nThe mode of the decoder.\nThe mode of the decoder.\nThe mode of the decoder.\nThe mode of the decoder.\nThe mode of the decoder.\nThe decode attempt was successful.\nThe value produced by the visitor.\nThe value produced by the visitor.\nTrait governing how to decode a sequence.\nA length hint.\nIndicates if skipping was performed.\nIndicates that skipping was successfully performed.\nString decoder to use.\nA clone of the current decoder.\nAn outcome of a fast decode attempt.\nA visitor for data where we might need to borrow without …\nThe decode was unsupported.\nIndicates that skipping was not supported.\nTrait governing how to decode a variant.\nVisitor capable of decoding any type into a value …\nBorrow self as a new decoder.\nGet a mutable pointer to the first element in the …\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nDecode the current value.\nDecode the current decoder into the value <code>T</code>.\nDecode dynamically through a <code>Visitor</code>.\nDecode a fixed-length array.\nDecode a boolean.\nBuffer the current decoder into a buffer that can be used …\nDecode the given input as bytes.\nDecode a sequence of bytes whos length is encoded in the …\nDecode a character.\nDecode a unit.\nDecode the next key. This returns <code>Ok(None)</code> where there are …\nTry to return the decoder for the first value in the pair.\nDecode the value in the map.\nDecode a 32-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 128-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a <code>isize</code>.\nReturn the decoder for the first value in the pair.\nDecode a map who’s size is not known at compile time.\nSimplified decoding a map of unknown length.\nDecode a map using a simplified function.\nReturn decoder to decode the next element.\nDecode an unknown number using a visitor.\nDecode an optional value.\nConstruct an unpack that can decode more than one element …\nDecode the given input as bytes.\nReturn simplified decoder for remaining entries.\nDecode a sequence.\nDecode a sequence with a <code>hint</code> indicating its expected …\nDecode a sequence of values.\nDecode a string slice from the current decoder.\nReturn the decoder for the first value in the pair.\nDecode a 128-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode the given input using a closure as visitor.\nDecode an unsized value by reference through the specified …\nDecode the given input using a closure as visitor.\nDecode an unsized value as bytes by reference through the …\nDecode a <code>usize</code>.\nDecode the second value in the pair..\nDecode the second value in the pair..\nDecode a variant using a closure.\nThis is an attribute macro that must be used when …\nEnd entries decoding.\nDecode the next map entry as a tuple.\nFormat the human-readable message that should occur if the …\nFormat an error indicating what was expected by this …\nFormat the human-readable message that should occur if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicates if a skip was performed.\nIndicates if a skip was not supported.\nConstruct a new empty container.\nDecode the next element of the given type, erroring in …\nPush a value into the container.\nReserve additional space for <code>capacity</code> elements in the …\nMark the given length as initialized.\nGet a size hint for the size of the map being decoded.\nGet a size hint for the size of the map being decoded.\nGet a size hint of known remaining elements.\nGet a size hint of known remaining elements.\nSkip over the current next value.\nDecode the given input.\nAttempt to clone the decoder so that it can be used …\nTry to decode the next element.\nTry to quickly decode the specified value.\nDecode the next element of the given type.\nThis is a variant of <code>Decoder::skip</code>, but instead of …\nThis is an attribute macro that must be used when …\nIndicates that the visited type is a <code>bool</code>.\nVisit a string that is borrowed directly from the source …\nIndicates that the visited type is <code>bytes</code>.\nIndicates that the visited type is a <code>char</code>.\nIndicates that the visited type is empty.\nIndicates that the visited type is a <code>f32</code>.\nIndicates that the visited type is a <code>f64</code>.\nIndicates that the visited type is a <code>i128</code>.\nIndicates that the visited type is a <code>i16</code>.\nIndicates that the visited type is a <code>i32</code>.\nIndicates that the visited type is a <code>i64</code>.\nIndicates that the visited type is a <code>i8</code>.\nIndicates that the visited type is a <code>isize</code>.\nIndicates that the visited type is a map.\nIndicates that the visited type is an optional value that …\nVisit an owned value.\nVisit a value reference that is provided from the decoder …\nIndicates that the visited type is a sequence.\nIndicates that the visited type is an optional value that …\nIndicates that the visited type is <code>string</code>.\nIndicates that the visited type is a <code>u128</code>.\nIndicates that the visited type is a <code>u16</code>.\nIndicates that the visited type is a <code>u32</code>.\nIndicates that the visited type is a <code>u64</code>.\nIndicates that the visited type is a <code>u8</code>.\nIndicates that the encoding does not support dynamic types.\nIndicates that the visited type is a <code>usize</code>.\nIndicates that the visited type is a variant.\nThis is an attribute macro that must be used when …\nConstruct a new container with the given capacity hint.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nWhether the type is packed. Packed types can be bitwise …\nTrait governing how types are encoded.\nThe underlying type being encoded.\nDerive which automatically implements the <code>Encode</code> trait.\nTrait governing how a type is encoded as bytes.\nThe underlying type being encoded.\nThe encoder returned when advancing the map encoder to …\nEncode the next pair.\nThe encoder returned when advancing the map encoder to …\nThe encoder returned when advancing the map encoder to …\nThe encoder returned when advancing the map encoder to …\nThe type of a map encoder.\nStreaming encoder for map pairs.\nEncoder for a map variant.\nThe encoder returned when advancing the sequence encoder.\nA simple pack that packs a sequence of elements.\nTrait governing how a type is encoded as a packed value.\nThe type of a sequence encoder.\nEncoder for a sequence variant.\nEncoder returned when encoding an optional value which is …\nThe encoder returned when advancing the map encoder to …\nTrait governing how types are encoded specifically for …\nThe encoder returned when advancing the map encoder to …\nEncoder for a variant.\nTrait governing how the encoder works.\nTrait governing how to encode a map entry.\nTrait governing how to encode a map entry.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nWhether the type is packed. Packed types can be bitwise …\nEncoder for a map.\nMode associated with encoding.\nThe mode of the encoder.\nThe mode of the encoder.\nThe mode of the encoder.\nThe mode of the encoder.\nThe mode of the encoder.\nThe encode attempt was successful.\nTrait governing how to encode a sequence.\nAn outcome of a fast encode attempt.\nThe encode was unsupported.\nTrait governing how to encode a variant.\nCoerce into the underlying value being encoded.\nCoerce into the underlying value being encoded.\nEncode a map entry.\nEncode a value that implements <code>Display</code> as a string.\nAccess the context associated with the encoder.\nAccess the context associated with the encoder.\nAccess the context associated with the encoder.\nAccess the context associated with the encoder.\nAccess the associated context.\nAccess the context associated with the encoder.\nEncode the given output.\nEncode the value <code>T</code> into the current encoder.\nEncode fixed-length array.\nEncode a boolean value.\nEncode the given output as bytes.\nEncode a sequence of bytes.\nEncode the given slices of bytes in sequence, with one …\nEncode a character.\nReturn encoder for the second element in the variant.\nEncode a unit or something that is completely empty.\nEncode the next map entry.\nSimplified encoder for a map entry, which ensures that …\nReturn the encoder for the key in the entry.\nReturn encoder for value in the entry.\nEncode a 32-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 128-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a <code>isize</code>.\nReturn the encoder for the key in the entry.\nEncode a map with a known length <code>len</code>.\nEncode a map through pairs with a known length <code>len</code>.\nEncode a map using a closure.\nSimplified encoding for a struct variant.\nReturn encoder for the next element.\nEncode an optional value that is absent.\nConstruct a pack that can encode more than one element at …\nEncodes a pack using a closure.\nEncode the given output as bytes.\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence using a closure.\nSimplified encoding for a tuple variant.\nEncode a slice as a sequence.\nEncode a slice of values.\nEncode a sequence extracted from an iterator of slices …\nEncode an iterator of contiguous slices of values.\nEncode an optional value that is present.\nEncode a string.\nReturn the encoder for the first element in the variant.\nEncode a 128-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nSimplified encoding for a unit variant.\nEncode a <code>usize</code>.\nReturn encoder for value in the entry.\nEncode a variant.\nEncode a variant using a closure.\nThis is an attribute macro that must be used when …\nAn expectation error. Every other implementation defers to …\nComplete encoding map entries.\nStop encoding this pair.\nFinish encoding a map.\nFinish encoding the sequence.\nEnd the variant encoder.\nReturns the argument unchanged.\nInsert the pair immediately.\nInsert the pair immediately.\nInsert a map entry.\nInsert the variant immediately.\nCalls <code>U::from(self)</code>.\nPush an element into the sequence.\nThe number of fields in the type.\nThe number of fields in the type.\nThe number of fields in the type.\nThe number of fields in the type.\nEncode the given output.\nTry to quickly encode the specified value.\nA fixed-size bytes storage which keeps track of how much …\nCoerce into the mutable slice of initialized memory which …\nCoerce into the slice of initialized memory which is …\nClear the FixedBytes container.\nTry and extend from the given slice.\nCoerce into the underlying bytes if all of them have been …\nTest if the current container is empty.\nGet the length of the collection.\nConstruct a new fixed bytes array storage.\nTry and push a single byte.\nGet the remaining capacity of the FixedBytes.\nConstruct a fixed bytes while asserting that the given …\nTry and extend from the given slice.\nA size hint passed in when encoding or decoding a map.\nA size hint passed in when encoding or decoding a sequence.\nGet an optional map hint.\nGet an optional sequence hint.\nRequire a map hint or raise an error indicating that the …\nRequire a sequence hint or raise an error indicating that …\nCoerce into a <code>SizeHint</code>.\nCoerce into a <code>SizeHint</code>.\nThe binary encoding mode.\nThe text encoding mode.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBig endian byte order.\n<code>Options</code> builder.\nByte order to use when encoding numbers.\nFixed number encoding.\nUse fixed float encoding.\nFloat serialization mode.\nInteger serialization mode.\nUse the same serialization as integers, after coercing the …\nLittle endian byte order.\nThe native byte order.\nThe native width.\nThe network byte order.\nType encapsulating a static options for an encoding.\n16 bit width.\n32 bit width.\n64 bit width.\n8 bit width.\nVariable number encoding.\nUse variable float encoding.\nUse a variable width encoding.\nThe width of a numerical type.\nBuilt an options builder into a constant.\nSpecify which byte order to use.\nConfigure the options to use fixed serialization.\nIndicates the configuration of float serialization.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>Builder</code> from the raw underlying value of an …\nIndicates if an integer serialization should be variable.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfigured a format to use numbers as map keys.\nSpecify that the <code>ByteOrder::NATIVE</code> byte order should be …\nStart building new options.\nSets the way in which pointer-like <code>usize</code> and <code>isize</code> types …\nConfigure the options to use variable serialization.\nSetting up encoding with parameters.\nContains the error value\nError raised during storage encoding.\nThe default options for the packed encoding.\nContains the success value\nConvenient result alias for use with <code>musli::storage</code>.\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given string using the …\nDecode the given type <code>T</code> from the given string using the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>Encoding</code> instance which uses <code>OPTIONS</code>.\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to the given slice using the default\nEncode the given value to the given slice using the current\nEncode the given value to the given slice using the current\nEncode the given value to a <code>Vec</code> using the default <code>Encoding</code>.\nEncode the given value to a <code>Vec</code> using the current <code>Encoding</code>.\nEncode the given value to a <code>Vec</code> using the current <code>Encoding</code>.\nEncode the given value to the given <code>Write</code> using the default\nEncode the given value to the given <code>Write</code> using the current\nEncode the given value to the given <code>Write</code> using the current\nChange the mode of the encoding.\nChange the options of the encoding.\nCoerce a type into a <code>Reader</code>.\nLimit the number of bytes that can be read out of a reader …\nType borrowed from self.\nTrait governing how a source of bytes is read.\nThe reader type.\nAn efficient <code>Reader</code> wrapper around a slice.\nType that can be cloned from the reader.\nGet the remaining contents of the reader as a slice.\nBorrow the current reader.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the type into a reader.\nTest if the reader is at end of input.\nKeep an accurate record of the position within the reader.\nConstruct a new instance around the specified slice.\nPeek the next value.\nRead a slice into the given buffer.\nRead an array out of the current reader.\nRead a single byte.\nRead a slice out of the current reader.\nRead into the given buffer which might not have been …\nGet remaining bytes in the reader.\nGet the remaining data in the limited reader.\nSkip over the given number of bytes.\nTry to clone the reader.\nSetting up encoding with parameters.\nContains the error value\nError raised during storage encoding.\nThe default options for the storage encoding.\nContains the success value\nConvenient result alias for use with <code>musli::storage</code>.\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nDecode the given type <code>T</code> from the given <code>Reader</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nEncode the given value to the given <code>Writer</code> using the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given slice using the …\nDecode the given type <code>T</code> from the given string using the …\nDecode the given type <code>T</code> from the given string using the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>Encoding</code> instance which uses <code>OPTIONS</code>.\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to a fixed-size bytes using the …\nEncode the given value to the given slice using the default\nEncode the given value to the given slice using the current\nEncode the given value to the given slice using the current\nEncode the given value to a <code>Vec</code> using the default <code>Encoding</code>.\nEncode the given value to a <code>Vec</code> using the current <code>Encoding</code>.\nEncode the given value to a <code>Vec</code> using the current <code>Encoding</code>.\nEncode the given value to the given <code>Write</code> using the default\nEncode the given value to the given <code>Write</code> using the current\nEncode the given value to the given <code>Write</code> using the current\nChange the mode of the encoding.\nChange the options of the encoding.\nWrap a type so that it implements <code>Reader</code> and <code>Writer</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrap a type so that it implements <code>Reader</code> and <code>Writer</code>.\nA writer that writes against an underlying <code>Vec</code>.\nCoerce a type into a <code>Writer</code>.\nReborrowed type.\nThe output of the writer which will be returned after …\nThe value returned from writing the value.\nA writer into a slice.\nThe trait governing how a writer works.\nThe writer type.\nReborrow the current type.\nWrite a buffer to the current writer.\nFinalize the writer and return the output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCoerce into inner buffer.\nConvert the type into a writer.\nConstruct a new buffer writer.\nWrite a single byte.\nWrite bytes to the current writer.")