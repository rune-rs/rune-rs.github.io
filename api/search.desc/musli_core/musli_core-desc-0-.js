searchState.loadedDescShard("musli_core", 0, "  \nA raw allocation from the allocator.\nAn allocator that can be used in combination with a …\nThe allocator associated with the context.\nThe allocator associated with the decoder.\nProvides ergonomic access to the serialization context.\nContext associated with the decoder.\nContext associated with the encoder.\nTrait governing how types are decoded.\nDerive which automatically implements the <code>Decode</code> trait.\nDecoder returned by <code>Decoder::decode_buffer</code>.\nDecoder returned by <code>Decoder::decode_map</code>.\nDecoder returned by <code>Decoder::decode_map_entries</code>.\nDecoder used by <code>Decoder::decode_pack</code>.\nDecoder returned by <code>Decoder::decode_sequence</code>.\nDecoder returned by <code>Decoder::decode_option</code>.\nDecoder used by <code>Decoder::decode_variant</code>.\nTrait governing the implementation of a decoder.\nTrait governing how types are encoded.\nThe underlying type being encoded.\nDerive which automatically implements the <code>Encode</code> trait.\nThe type of a map encoder.\nStreaming encoder for map pairs.\nEncoder for a map variant.\nA simple pack that packs a sequence of elements.\nThe type of a sequence encoder.\nEncoder for a sequence variant.\nEncoder returned when encoding an optional value which is …\nEncoder for a variant.\nTrait governing how the encoder works.\nError produced by the context.\nError associated with decoding.\nError associated with encoding.\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nWhether the allocations returned by this allocatore is …\nA mark during processing.\nMode associated with decoding.\nMode associated with encoding.\nA clone of the current decoder.\nAdvance the context by <code>n</code> bytes of input.\nMüsli Rust core allocation and collections library\nConstruct an empty uninitialized raw allocation with an …\nAccess the underlying allocator.\nConstruct an empty uninitialized raw vector with an …\nCoerce into the underlying value being encoded.\nClear the state of the context, allowing it to be re-used.\nEncode a value that implements <code>Display</code> as a string.\nEncode a value that implements <code>Display</code> as a string.\nReport a custom error, which is not encapsulated by the …\nReport an error based on a mark.\nReport an error based on a mark.\nAccess the context associated with the decoder.\nAccess the context associated with the encoder.\nTraits for generically dealing with a decoding framework.\nDecode the current value.\nDecode the current decoder into the value <code>T</code>.\nDecode the current decoder into the value <code>T</code>.\nDecode dynamically through a <code>Visitor</code>.\nDecode dynamically through a <code>Visitor</code>.\nDecode a fixed-length array.\nDecode a fixed-length array.\nDecode a boolean.\nDecode a boolean.\nBuffer the current decoder into a buffer that can be used …\nBuffer the current decoder into a buffer that can be used …\nDecode a sequence of bytes whos length is encoded in the …\nDecode a sequence of bytes whos length is encoded in the …\nDecode a character.\nDecode a character.\nDecode a unit.\nDecode a unit.\nDecode a 32-bit floating point value.\nDecode a 32-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 128-bit signed integer.\nDecode a 128-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a <code>isize</code>.\nDecode a <code>isize</code>.\nDecode a map who’s size is not known at compile time.\nDecode a map who’s size is not known at compile time.\nSimplified decoding a map of unknown length.\nSimplified decoding a map of unknown length.\nDecode a map using a simplified function.\nDecode a map using a simplified function.\nDecode an unknown number using a visitor.\nDecode an unknown number using a visitor.\nDecode an optional value.\nDecode an optional value.\nConstruct an unpack that can decode more than one element …\nConstruct an unpack that can decode more than one element …\nDecode a sequence.\nDecode a sequence.\nDecode a sequence with a <code>hint</code> indicating its expected …\nDecode a sequence with a <code>hint</code> indicating its expected …\nDecode a sequence of values.\nDecode a sequence of values.\nDecode a string slice from the current decoder.\nDecode a string slice from the current decoder.\nDecode a 128-bit unsigned integer.\nDecode a 128-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode an unsized value by reference through the specified …\nDecode an unsized value by reference through the specified …\nDecode an unsized value as bytes by reference through the …\nDecode an unsized value as bytes by reference through the …\nDecode a <code>usize</code>.\nDecode a <code>usize</code>.\nDecode a variant using a closure.\nDecode a variant using a closure.\nThis is an attribute macro that must be used when …\nTraits for generically dealing with an encoding framework.\nEncode the given output.\nEncode the value <code>T</code> into the current encoder.\nEncode the value <code>T</code> into the current encoder.\nEncode fixed-length array.\nEncode fixed-length array.\nEncode a boolean value.\nEncode a boolean value.\nEncode a sequence of bytes.\nEncode a sequence of bytes.\nEncode the given slices of bytes in sequence, with one …\nEncode the given slices of bytes in sequence, with one …\nEncode a character.\nEncode a character.\nEncode a unit or something that is completely empty.\nEncode a unit or something that is completely empty.\nEncode a 32-bit floating point value.\nEncode a 32-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 128-bit signed integer.\nEncode a 128-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a <code>isize</code>.\nEncode a <code>isize</code>.\nEncode a map with a known length <code>len</code>.\nEncode a map with a known length <code>len</code>.\nEncode a map through pairs with a known length <code>len</code>.\nEncode a map through pairs with a known length <code>len</code>.\nEncode a map using a closure.\nEncode a map using a closure.\nSimplified encoding for a struct variant.\nSimplified encoding for a struct variant.\nEncode an optional value that is absent.\nEncode an optional value that is absent.\nConstruct a pack that can encode more than one element at …\nConstruct a pack that can encode more than one element at …\nEncodes a pack using a closure.\nEncodes a pack using a closure.\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence using a closure.\nEncode a sequence using a closure.\nSimplified encoding for a tuple variant.\nSimplified encoding for a tuple variant.\nEncode a slice as a sequence.\nEncode a slice as a sequence.\nEncode a sequence extracted from an iterator of slices …\nEncode a sequence extracted from an iterator of slices …\nEncode an optional value that is present.\nEncode an optional value that is present.\nEncode a string.\nEncode a string.\nEncode a 128-bit unsigned integer.\nEncode a 128-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nSimplified encoding for a unit variant.\nSimplified encoding for a unit variant.\nEncode a <code>usize</code>.\nEncode a <code>usize</code>.\nEncode a variant.\nEncode a variant.\nEncode a variant using a closure.\nEncode a variant using a closure.\nThis is an attribute macro that must be used when …\nIndicate that we’ve entered an enum with the given <code>name</code>.\nIndicate that we’ve entered an enum with the given <code>name</code>.\nTrace a that a map key has been entered.\nTrace a that a map key has been entered.\nTrace that we’ve entered the given named field.\nTrace that we’ve entered the given named field.\nTrace a sequence field.\nTrace a sequence field.\nIndicate that we’ve entered a struct with the given <code>name</code>.\nIndicate that we’ve entered a struct with the given <code>name</code>.\nTrace that we’ve entered the given unnamed field.\nTrace that we’ve entered the given unnamed field.\nTrace that we’ve entered the given variant in an enum.\nTrace that we’ve entered the given variant in an enum.\nFormat the human-readable message that should occur if the …\nAn expectation error. Every other implementation defers to …\nCore encoding hints.\nTrace that we’ve left the last enum that was entered.\nTrace that we’ve left the last enum that was entered.\nTrace that we’ve left the last field that was entered.\nTrace that we’ve left the last field that was entered.\nTrace that we’ve left the last map field that was …\nTrace that we’ve left the last map field that was …\nTrace that we’ve left the last sequence index that was …\nTrace that we’ve left the last sequence index that was …\nTrace that we’ve left the last struct that was entered.\nTrace that we’ve left the last struct that was entered.\nTrace that we’ve left the last variant that was entered.\nTrace that we’ve left the last variant that was entered.\nGenerate a map function which maps an error using the …\nGenerate a map function which maps an error using the …\nReturn a mark which acts as a checkpoint at the current …\nReport a message as an error.\nReport an error based on a mark.\nReport an error based on a mark.\nType that describe a mode of encoding.\nRestore the state of the context to the specified mark.\nThe number of fields in the type.\nThe number of fields in the type.\nSkip over the current next value.\nSkip over the current next value.\nAttempt to clone the decoder so that it can be used …\nAttempt to clone the decoder so that it can be used …\nTry to quickly decode the specified value.\nTry to quickly decode the specified value.\nTry to quickly encode the specified value.\nTry to quickly encode the specified value.\nThis is a variant of <code>Decoder::skip</code>, but instead of …\nThis is a variant of <code>Decoder::skip</code>, but instead of …\nA value allocated through <code>Allocator::alloc</code>.\nA raw allocation from the allocator.\nAn allocation error.\nAn allocator that can be used in combination with a …\nA Müsli-allocated pointer type that uniquely owns a heap …\nAn allocator which cannot allocate anything.\nA possible error value when converting a <code>String</code> from a …\nWhether the allocations returned by this allocatore is …\nThe owned value.\nA Müsli-allocated UTF-8–encoded, growable string.\nSystem buffer that can be used in combination with an …\nA vector-backed allocation.\nThe local `ToOwned`` implementation for Musli’s …\nA Müsli-allocated contiguous growable array type, written …\nConstruct an empty uninitialized raw allocation with an …\nConstruct an empty uninitialized raw vector with an …\nReturns a slice of <code>u8</code>s bytes that were attempted to …\nGet a mutable pointer into the allocation.\nGet a pointer into the allocation.\nGet the initialized part of the buffer as a slice.\nGet the initialized part of the buffer as a slice.\nExtracts a string slice containing the entire <code>String</code>.\nReturns the capacity of the buffer.\nReturns this <code>String</code>’s capacity, in bytes.\nReturns the total number of elements the vector can hold …\nClear the buffer vector.\nWrite a buffer of the same type onto the current buffer.\nWrite the given number of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a vector from raw parts.\nConverts a vector of bytes to a <code>String</code>.\nConverts a vector of bytes to a <code>String</code> without checking …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a <code>String</code> into a byte vector.\nReturns the bytes that were attempted to convert to a …\nDeconstruct a vector into its raw parts.\nCoerce into a std string.\nCoerce into a std vector.\nReturns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code>\nCheck if the buffer is empty.\nReturns the length of this <code>String</code>, in bytes, not <code>char</code>s or …\nReturns the number of elements in the vector, also …\nConstruct a new system allocator.\nConstruct a new disabled allocator.\nCreates a new empty <code>String</code>.\nConstruct a new buffer vector.\nAllocates memory on the heap and then places <code>x</code> into it.\nPop a single item from the buffer.\nAppends the given <code>char</code> to the end of this <code>String</code>.\nWrite a single item.\nAppends a given string slice onto the end of this <code>String</code>.\nAccess a reference to the raw underlying allocation.\nReserves capacity for at least <code>additional</code> more elements to …\nResize the buffer to fit at least additional elements.\nForces the length of the vector to <code>new_len</code>.\nTry to merge one buffer with another.\nFetch a <code>Utf8Error</code> to get more details about the conversion …\nCreates a new empty <code>String</code> with at least the specified …\nConstruct a new buffer vector.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the decoder.\nThe allocator associated with the visitor.\nThe allocator associated with the decoder.\nThe allocator associated with the visitor.\nTrait that allows a type to be repeatedly coerced into a …\nBytes decoder to use.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nContext associated with the decoder.\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nTrait governing how types are decoded.\nDerive which automatically implements the <code>Decode</code> trait.\nDecoder returned by <code>Decoder::decode_buffer</code>.\nTrait governing how types are decoded as bytes.\nThe decoder to use for a key.\nThe decoder to use for a tuple field index.\nThe decoder to use for a tuple field value.\nThe decoder to use for a tuple field index.\nDecoder returned by <code>Decoder::decode_map</code>.\nDecoder returned by <code>Decoder::decode_map_entries</code>.\nThe decoder for individual items.\nDecode to an owned value.\nDecoder used by <code>Decoder::decode_pack</code>.\nTrait governing how a type is decoded as a packed value.\nDecoder returned by <code>MapDecoder::decode_remaining_entries</code>.\nDecoder returned by <code>Decoder::decode_sequence</code>.\nTrait used to decode a slice into a type.\nDecoder returned by <code>Decoder::decode_option</code>.\nThe decoder to use for the variant tag.\nTrait governing how types are decoded specifically for …\nA trait implemented for types which can only be decoded by …\nA trait implemented for types which can be visited by …\nThe decoder to use for a tuple field value.\nThe decoder to use for the variant value.\nDecoder used by <code>Decoder::decode_variant</code>.\nTrait governing the implementation of a decoder.\nThe decoder we reborrow as.\nTrait governing how to decode a sequence of map pairs.\nTrait governing how to decode a map entry.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nError associated with decoding.\nThe error produced by the visitor.\nError associated with decoding.\nThe error produced by the visitor.\nWhether the type is packed. Packed types can be bitwise …\nTrait governing how to decode a sequence of pairs.\nThe mode of the decoder.\nMode associated with decoding.\nThe mode of the decoder.\nThe mode of the decoder.\nThe mode of the decoder.\nThe mode of the decoder.\nThe mode of the decoder.\nThe decode attempt was successful.\nThe value produced by the visitor.\nThe value produced by the visitor.\nTrait governing how to decode a sequence.\nIndicates if skipping was performed.\nIndicates that skipping was successfully performed.\nString decoder to use.\nA clone of the current decoder.\nAn outcome of a fast decode attempt.\nA visitor for data where we might need to borrow without …\nThe decode was unsupported.\nIndicates that skipping was not supported.\nTrait governing how to decode a variant.\nVisitor capable of decoding any type into a value …\nBorrow self as a new decoder.\nGet a mutable pointer to the first element in the …\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nAccess the context associated with the decoder.\nDecode the current value.\nDecode the current decoder into the value <code>T</code>.\nDecode dynamically through a <code>Visitor</code>.\nDecode a fixed-length array.\nDecode a boolean.\nBuffer the current decoder into a buffer that can be used …\nDecode the given input as bytes.\nDecode a sequence of bytes whos length is encoded in the …\nDecode a character.\nDecode a unit.\nDecode the next key. This returns <code>Ok(None)</code> where there are …\nTry to return the decoder for the first value in the pair.\nDecode the value in the map.\nDecode a 32-bit floating point value.\nDecode a 64-bit floating point value.\nDecode a 128-bit signed integer.\nDecode a 16-bit signed integer.\nDecode a 32-bit signed integer.\nDecode a 64-bit signed integer.\nDecode a 8-bit signed integer.\nDecode a <code>isize</code>.\nReturn the decoder for the first value in the pair.\nDecode a map who’s size is not known at compile time.\nSimplified decoding a map of unknown length.\nDecode a map using a simplified function.\nReturn decoder to decode the next element.\nDecode an unknown number using a visitor.\nDecode an optional value.\nConstruct an unpack that can decode more than one element …\nDecode the given input as bytes.\nReturn simplified decoder for remaining entries.\nDecode a sequence.\nDecode a sequence with a <code>hint</code> indicating its expected …\nDecode a sequence of values.\nDecode a string slice from the current decoder.\nReturn the decoder for the first value in the pair.\nDecode a 128-bit unsigned integer.\nDecode a 16-bit unsigned integer.\nDecode a 32-bit unsigned integer.\nDecode a 64-bit unsigned integer.\nDecode a 8-bit unsigned integer (a.k.a. a byte).\nDecode the given input using a closure as visitor.\nDecode an unsized value by reference through the specified …\nDecode the given input using a closure as visitor.\nDecode an unsized value as bytes by reference through the …\nDecode a <code>usize</code>.\nDecode the second value in the pair..\nDecode the second value in the pair..\nDecode a variant using a closure.\nThis is an attribute macro that must be used when …\nEnd entries decoding.\nDecode the next map entry as a tuple.\nDecode the next map entry as a tuple.\nFormat the human-readable message that should occur if the …\nFormat an error indicating what was expected by this …\nFormat the human-readable message that should occur if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicates if a skip was performed.\nIndicates if a skip was not supported.\nConstruct a new empty container.\nDecode the next element of the given type, erroring in …\nDecode the next element of the given type, erroring in …\nPush a value into the container.\nReserve additional space for <code>capacity</code> elements in the …\nMark the given length as initialized.\nGet a size hint for the size of the map being decoded.\nGet a size hint for the size of the map being decoded.\nGet a size hint for the size of the map being decoded.\nGet a size hint for the size of the map being decoded.\nGet a size hint of known remaining elements.\nGet a size hint of known remaining elements.\nGet a size hint of known remaining elements.\nGet a size hint of known remaining elements.\nSkip over the current next value.\nDecode the given input.\nAttempt to clone the decoder so that it can be used …\nTry to decode the next element.\nTry to quickly decode the specified value.\nDecode the next element of the given type.\nDecode the next element of the given type.\nThis is a variant of <code>Decoder::skip</code>, but instead of …\nThis is an attribute macro that must be used when …\nIndicates that the visited type is a <code>bool</code>.\nIndicates that the visited type is a <code>bool</code>.\nVisit a string that is borrowed directly from the source …\nVisit a string that is borrowed directly from the source …\nIndicates that the visited type is <code>bytes</code>.\nIndicates that the visited type is <code>bytes</code>.\nIndicates that the visited type is a <code>char</code>.\nIndicates that the visited type is a <code>char</code>.\nIndicates that the visited type is empty.\nIndicates that the visited type is empty.\nIndicates that the visited type is a <code>f32</code>.\nIndicates that the visited type is a <code>f32</code>.\nIndicates that the visited type is a <code>f64</code>.\nIndicates that the visited type is a <code>f64</code>.\nIndicates that the visited type is a <code>i128</code>.\nIndicates that the visited type is a <code>i128</code>.\nIndicates that the visited type is a <code>i16</code>.\nIndicates that the visited type is a <code>i16</code>.\nIndicates that the visited type is a <code>i32</code>.\nIndicates that the visited type is a <code>i32</code>.\nIndicates that the visited type is a <code>i64</code>.\nIndicates that the visited type is a <code>i64</code>.\nIndicates that the visited type is a <code>i8</code>.\nIndicates that the visited type is a <code>i8</code>.\nIndicates that the visited type is a <code>isize</code>.\nIndicates that the visited type is a <code>isize</code>.\nIndicates that the visited type is a map.\nIndicates that the visited type is a map.\nIndicates that the visited type is an optional value that …\nIndicates that the visited type is an optional value that …\nVisit an owned value.\nVisit an owned value.\nVisit a value reference that is provided from the decoder …\nVisit a value reference that is provided from the decoder …\nIndicates that the visited type is a sequence.\nIndicates that the visited type is a sequence.\nIndicates that the visited type is an optional value that …\nIndicates that the visited type is an optional value that …\nIndicates that the visited type is <code>string</code>.\nIndicates that the visited type is <code>string</code>.\nIndicates that the visited type is a <code>u128</code>.\nIndicates that the visited type is a <code>u128</code>.\nIndicates that the visited type is a <code>u16</code>.\nIndicates that the visited type is a <code>u16</code>.\nIndicates that the visited type is a <code>u32</code>.\nIndicates that the visited type is a <code>u32</code>.\nIndicates that the visited type is a <code>u64</code>.\nIndicates that the visited type is a <code>u64</code>.\nIndicates that the visited type is a <code>u8</code>.\nIndicates that the visited type is a <code>u8</code>.\nIndicates that the encoding does not support dynamic types.\nIndicates that the encoding does not support dynamic types.\nIndicates that the visited type is a <code>usize</code>.\nIndicates that the visited type is a <code>usize</code>.\nIndicates that the visited type is a variant.\nIndicates that the visited type is a variant.\nThis is an attribute macro that must be used when …\nConstruct a new container with the given capacity hint.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nContext associated with the encoder.\nWhether the type is packed. Packed types can be bitwise …\nWhether the type is packed. Packed types can be bitwise …\nTrait governing how types are encoded.\nThe underlying type being encoded.\nDerive which automatically implements the <code>Encode</code> trait.\nTrait governing how a type is encoded as bytes.\nThe underlying type being encoded.\nThe encoder returned when advancing the map encoder to …\nEncode the next pair.\nThe encoder returned when advancing the map encoder to …\nThe encoder returned when advancing the map encoder to …\nThe encoder returned when advancing the map encoder to …\nThe type of a map encoder.\nStreaming encoder for map pairs.\nEncoder for a map variant.\nThe encoder returned when advancing the sequence encoder.\nA simple pack that packs a sequence of elements.\nTrait governing how a type is encoded as a packed value.\nThe type of a sequence encoder.\nEncoder for a sequence variant.\nEncoder returned when encoding an optional value which is …\nThe encoder returned when advancing the map encoder to …\nTrait governing how types are encoded specifically for …\nThe encoder returned when advancing the map encoder to …\nEncoder for a variant.\nTrait governing how the encoder works.\nTrait governing how to encode a map entry.\nTrait governing how to encode a map entry.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nError associated with encoding.\nWhether the type is packed. Packed types can be bitwise …\nEncoder for a map.\nMode associated with encoding.\nThe mode of the encoder.\nThe mode of the encoder.\nThe mode of the encoder.\nThe mode of the encoder.\nThe mode of the encoder.\nThe encode attempt was successful.\nTrait governing how to encode a sequence.\nAn outcome of a fast encode attempt.\nThe encode was unsupported.\nTrait governing how to encode a variant.\nCoerce into the underlying value being encoded.\nCoerce into the underlying value being encoded.\nEncode a map entry.\nEncode a map entry.\nEncode a value that implements <code>Display</code> as a string.\nAccess the context associated with the encoder.\nAccess the context associated with the encoder.\nAccess the context associated with the encoder.\nAccess the context associated with the encoder.\nAccess the associated context.\nAccess the context associated with the encoder.\nEncode the given output.\nEncode the value <code>T</code> into the current encoder.\nEncode fixed-length array.\nEncode a boolean value.\nEncode the given output as bytes.\nEncode a sequence of bytes.\nEncode the given slices of bytes in sequence, with one …\nEncode a character.\nReturn encoder for the second element in the variant.\nEncode a unit or something that is completely empty.\nEncode the next map entry.\nSimplified encoder for a map entry, which ensures that …\nSimplified encoder for a map entry, which ensures that …\nReturn the encoder for the key in the entry.\nReturn encoder for value in the entry.\nEncode a 32-bit floating point value.\nEncode a 64-bit floating point value.\nEncode a 128-bit signed integer.\nEncode a 16-bit signed integer.\nEncode a 32-bit signed integer.\nEncode a 64-bit signed integer.\nEncode a 8-bit signed integer.\nEncode a <code>isize</code>.\nReturn the encoder for the key in the entry.\nEncode a map with a known length <code>len</code>.\nEncode a map through pairs with a known length <code>len</code>.\nEncode a map using a closure.\nSimplified encoding for a struct variant.\nReturn encoder for the next element.\nEncode an optional value that is absent.\nConstruct a pack that can encode more than one element at …\nEncodes a pack using a closure.\nEncode the given output as bytes.\nEncode a sequence with a known length <code>len</code>.\nEncode a sequence using a closure.\nSimplified encoding for a tuple variant.\nEncode a slice as a sequence.\nEncode a slice of values.\nEncode a slice of values.\nEncode a sequence extracted from an iterator of slices …\nEncode an iterator of contiguous slices of values.\nEncode an iterator of contiguous slices of values.\nEncode an optional value that is present.\nEncode a string.\nReturn the encoder for the first element in the variant.\nEncode a 128-bit unsigned integer.\nEncode a 16-bit unsigned integer.\nEncode a 32-bit unsigned integer.\nEncode a 64-bit unsigned integer.\nEncode a 8-bit unsigned integer.\nSimplified encoding for a unit variant.\nEncode a <code>usize</code>.\nReturn encoder for value in the entry.\nEncode a variant.\nEncode a variant using a closure.\nThis is an attribute macro that must be used when …\nAn expectation error. Every other implementation defers to …\nComplete encoding map entries.\nStop encoding this pair.\nFinish encoding a map.\nFinish encoding the sequence.\nEnd the variant encoder.\nReturns the argument unchanged.\nInsert the pair immediately.\nInsert the pair immediately.\nInsert the pair immediately.\nInsert the pair immediately.\nInsert a map entry.\nInsert a map entry.\nInsert the variant immediately.\nInsert the variant immediately.\nCalls <code>U::from(self)</code>.\nPush an element into the sequence.\nPush an element into the sequence.\nThe number of fields in the type.\nThe number of fields in the type.\nThe number of fields in the type.\nThe number of fields in the type.\nThe number of fields in the type.\nThe number of fields in the type.\nThe number of fields in the type.\nEncode the given output.\nTry to quickly encode the specified value.\nA size hint passed in when encoding or decoding a map.\nA size hint passed in when encoding or decoding a sequence.\nGet an optional map hint.\nGet an optional sequence hint.\nRequire a map hint or raise an error indicating that the …\nRequire a map hint or raise an error indicating that the …\nRequire a sequence hint or raise an error indicating that …\nRequire a sequence hint or raise an error indicating that …\nCoerce into a <code>SizeHint</code>.\nCoerce into a <code>SizeHint</code>.\nCoerce into a <code>SizeHint</code>.\nCoerce into a <code>SizeHint</code>.\nThe binary encoding mode.\nThe text encoding mode.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")