searchState.loadedDescShard("rune", 1, "Trait governing things that can be returned from native …\nTrait for converting types into the dynamic <code>Value</code> …\nDerive macro for the <code>ToValue</code> trait for converting types …\nPerform the try operation which takes the value at the …\nThe type of a tuple slice.\nMatches an anonymous tuple.\nConstruct a tuple at <code>out</code>, populating it with <code>count</code> …\nConstruct a one element tuple at <code>out</code>, populating it with …\nConstruct a two element tuple at <code>out</code>, populating it with …\nConstruct a three element tuple at <code>out</code>, populating it with …\nConstruct a four element tuple at <code>out</code>, populating it with …\nTarget a tuple field.\nGet the given index out of a tuple from the given variable …\nSet the given index of the tuple on the stack, with the …\nA tuple with a well-defined type.\nA value representing a type in the virtual machine.\nA type hash.\nA type hash. Describes a type in the virtual machine.\nType checks for built-in types.\nStatic type hash for a given type.\nDiagnostical type information for a given type.\nTrait used for Rust types for which we can determine the …\nMatches a unit type.\nAn empty tuple.\nThe unit value.\nA pattern didn’t match where it unconditionally has to.\nA potentially unsafe conversion for value conversion.\nUnsafe to mut coercion.\nUnsafe to ref coercion.\nTrait for converting types into values.\nAn unsigned integer.\nAn unsigned number.\nAn entry on the stack.\nDefined guard for a reference value.\nDefined guard for a reference value.\nConstruct a built-in variant onto the stack.\nStruct representing a dynamic vector.\nMatches a vector.\nConstruct a vector at <code>out</code>, populating it with <code>count</code> …\nA helper type to deserialize arrays with different …\nA stack which references variables indirectly from a slab.\nA virtual machine error which includes tracing information.\nThe execution environment for a virtual machine.\nA result produced by the virtual machine.\nA wrapper that makes <code>VmExecution</code> <code>Send</code>.\nPerform a generator yield where the value yielded is …\nPerform a generator yield with a unit.\nThe generator yielded.\nThe first possible address.\nConstruct type info from an statically known <code>Any</code> type.\nGet the slice at the given address with the given static …\nGet the slice at the given address with the given static …\nCoerce into <code>bool</code>.\nCoerce into <code>bool</code>.\nCoerce into <code>bool</code>.\nCoerce into <code>bool</code>.\nCoerce into <code>char</code>.\nCoerce into <code>char</code>.\nCoerce into <code>char</code>.\nCoerce into <code>char</code>.\nCoerce into <code>f64</code> float.\nCoerce into <code>f64</code> float.\nCoerce into <code>f64</code> float.\nCoerce into <code>f64</code> float.\nTry to coerce the current value as the specified integer <code>T</code>.\nTry to coerce the current value as the specified integer <code>T</code>.\nCoerce into <code>Ordering</code>.\nCoerce into <code>Ordering</code>.\nCoerce into <code>Ordering</code>.\nCoerce into <code>Ordering</code>.\nCoerce into <code>i64</code> integer.\nCoerce into <code>i64</code> signed integer.\nCoerce into <code>i64</code> integer.\nCoerce into <code>i64</code> signed integer.\nAccess bytes as a slice.\nGet the value as a string.\nCoerce into <code>Type</code>.\nCoerce into <code>Type</code>.\nCoerce into <code>Type</code>.\nCoerce into <code>Type</code>.\nCoerce into <code>u64</code> unsigned integer.\nCoerce into <code>u64</code> unsigned integer.\nCoerce into <code>u64</code> unsigned integer.\nCoerce into <code>u64</code> unsigned integer.\nTry to coerce value into a usize.\nCall the given function immediately asynchronously, …\nComplete the current execution without support for async …\nComplete the current execution with support for async …\nRun the given vm to completion with support for async …\nComplete the current execution with support for async …\nSee <code>Function::function</code>.\nResume the current execution with support for async …\nResume the current execution with the given value and …\nResume the current execution with support for async …\nPerform an asynchronous call over the function which also …\nPerform an asynchronous call over the function which also …\nStep the single execution for one step with support for …\nGet the location where the error happened.\nAccess the value at the given frame offset.\nGet a value mutable at the given index from the stack …\nGet a value mutable at the given index from the stack …\nBad argument count.\nConstruct an instruction to push a boolean.\nReturns some mutable reference to the boxed value if it is …\nTry to borrow value into a typed mutable reference of type …\nGet a reference to the interior value while checking for …\nBorrow the value as a typed reference of type <code>T</code>.\nBorrow the interior value as a string reference.\nBorrow as a tuple as mutable.\nBorrow as a tuple.\nBudgeting module for Runestick.\nPerform a call over the function represented by this …\nPerform a call over the function represented by this …\nCall the given function immediately, returning the …\nGet the stack.\nCall the given function immediately, returning the …\nGet the capacity of the bytes collection.\nReturns the number of elements in the dynamic vector, also …\nGet the full backtrace of errors and their corresponding …\nConstruct an instruction to push a character.\nGet the bytes collection.\nClears the object, removing all key-value pairs. Keeps the …\nClears the vector, removing all values.\nReset this virtual machine, freeing all memory used.\nPerform a shallow clone of the value using the <code>CLONE</code> …\nPerform a total ordering comparison between two values.\nTest the range for total ordering.\nTest the full range for total ordering.\nTest the range for total ordering.\nTest the range for total ordering.\nTest the range for total ordering.\nTest the range for total ordering.\nComplete the current execution without support for async …\nRun the given vm to completion.\nComplete the current execution without support for async …\nRead a constant value.\nReturn the constant constructor for the given type.\nReturn the constant constructor for the given type.\nReturn the constant constructor for the given type.\nReturns <code>true</code> if the map contains a value for the specified …\nAccess the context related to the virtual machine.\nAccess the context related to the virtual machine mutably.\nThe number of arguments.\nThe number of arguments.\nAccess underlying data.\nAccess truct data.\nDebug information for units.\nDebug format the value using the <code>DEBUG_FMT</code> protocol.\nFormat the value using the Protocol::DISPLAY_FMT protocol.\nDowncast the value into a stored value that implements <code>Any</code>.\nGenerate formatted diagnostics capable of referencing …\nConstruct an empty value.\nConstruct type info for the empty type.\nConstruct an empty.\nThe end value of the range.\nThe end value of the range.\nThe end value of the range.\nThe to value of the range.\nPerform a total equality test between two values.\nTest the range for total equality.\nTest the full range for total equality.\nTest the range for total equality.\nTest the range for total equality.\nTest the range for total equality.\nTest the range for total equality.\nConstruct a new error from a type that can be converted …\nCall the function identified by the given name.\nExpect a value or panic.\nConstruct an expectation error. The actual type received …\nConstruct an expectation error. The actual type received …\nConstruct an expected error.\nExtend these bytes with another collection of bytes.\nExtend this vector with something that implements the …\nConstruct a hash.\nGet the first byte.\nGet the first error location.\nConstruct an instruction to push a float.\nConstruct a constant value for a struct.\nTypes for dealing with formatting specifications.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct from an atomically reference-counted value.\nConstruct from an atomically reference-counted value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert something into a <code>ConstValue</code>.\nConvert from a constant value.\nLook up protocol for the given hash.\nConstruct a value that wraps a mutable pointer.\nConvert a raw reference and guard into a regular reference.\nConvert a raw mutable reference and guard into a regular …\nConstruct an Any that wraps a pointer.\nConvert a slice into bytes.\nConstruct an owned reference from a static value.\nConstruct an owned mutable reference from a static value.\nConvert something into the dynamic <code>Value</code>.\nTry to convert to the given type, from the given value.\nConvert a byte array into bytes.\nSee <code>Function::new</code>.\nLookup the given native function handler in the context.\nGet a value from the dynamic struct.\nGet the value at the given index in the tuple.\nGet a field through the accessor.\nReturns a reference to the value corresponding to the key.\nGet the value at the given index.\nReturns a mutable reference to the value corresponding to …\nGet the mutable value at the given index.\nGet the given value at the given index.\nGet the given value at the given index.\nGet the given value at the given index.\nEncode arguments onto a stack.\nEncode arguments into a vector.\nHash the current value.\nGet the hash of the string.\nThe hash of the builtin function.\nInserts a key-value pair into the map.\nInserts an element at position index within the vector, …\nInserts a key-value pair into the dynamic object, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCoerce into an <code>AnyObj</code>.\nTry to coerce value into a typed reference.\nEncode arguments as array.\nCoerce this owned tuple into a boxed tuple.\nCoerce into a future, or convert into a future using the …\nCoerce the current execution into a generator if …\nCoerce into inner type hash.\nConvert into inner std boxed slice.\nConvert into inner rune alloc vector.\nConvert value into an iterator using the …\nCreates a consuming iterator, that is, one that moves each …\nBuild an iterator over the range.\nIterate over the range.\nIterate over the range.\nTry to coerce value into a typed mutable reference of type …\nCoerce the current value into an output.\nConvert the current execution into one which owns its …\nConvert the current generator into one which owns its …\nConvert the current stream into one which owns its virtual …\nConvert into a raw pointer and associated raw access guard.\nConvert into a raw pointer and associated raw access guard.\nTry to coerce value into a typed reference of type <code>T</code>.\nConvert a <code>VmResult</code> into a <code>Result</code>.\nEncode arguments onto a stack.\nCoerce the current execution into a stream if appropriate.\nTake the current value as a string.\nTry to convert into a SyncFunction. This might not be …\nBorrow as an owned tuple reference.\nCoerce into tuple.\nBorrow as an owned tuple mutable.\nBorrow as an owned tuple reference.\nRetrieves a human readable type name for the current value.\nCoerce into a unit.\nConvert into a value that can be pushed onto the stack.\nConvert the byte array into a vector of bytes.\nAccess the current instruction pointer.\nThe stored instruction pointer.\nTest if the state is complete.\nCheck if future is completed.\nTest if the collection is empty.\nReturns <code>true</code> if the object is empty.\nReturns <code>true</code> if the vector contains no elements.\nTest if the result is an error.\nTest if the result is an ok.\nTest if the value is readable.\nTest if the virtual machine is the same context and unit …\nTest if the virtual machine is the same context.\nTest if the virtual machine is the same context.\nTest if the value is writable.\nTest if the state is yielded.\nIndicates that the call frame is isolated and should force …\nAccess the item of the RTTI.\nAn iterator visiting all key-value pairs in arbitrary …\nIterate over the range.\nIterate over the range.\nIterate over the range.\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all keys in arbitrary order. The …\nGet the last byte.\nAccess the last instruction that was executed.\nGet the length of the bytes collection.\nReturns the number of elements in the object.\nReturns the number of elements in the dynamic vector, also …\nLook up a function in the virtual machine by its name.\nMap the mutable reference.\nMap the reference.\nMap the interior reference of an owned mutable value.\nMap the interior reference of an owned mutable value.\nType information for the given type.\nIf this protocol defines an associated method, this is the …\nThe name of the builtin function.\nConstruct type info from an statically known <code>Named</code> type.\nConstruct a new tuple slice from a reference.\nConstruct a value from a type that implements <code>Any</code> which …\nConstruct a new byte array.\nConstruct a Function from a Rust closure.\nConstruct a new object.\nConstruct a new range.\nConstruct a new full range.\nConstruct a new range.\nConstruct a new range.\nConstruct a new range.\nConstruct a new range.\nConstruct a new static string.\nConstruct a new empty tuple.\nConstructs a new, empty dynamic <code>Vec</code>.\nConstruct a new vector tuple for serializing values.\nConstruct a new virtual machine.\nConstruct a new tuple slice from a mutable reference.\nGet the next value produced by this stream.\nGet the next value produced by this stream.\nConstruct an instruction to push an ordering.\nKeep the value produced from the call frame.\nConstruct an overflow error.\nConstruct an error containing a panic.\nConstruct a result containing a panic.\nConstruct an error containing a panic.\nPerform a partial ordering comparison between two values.\nTest the range for partial ordering.\nTest the full range for partial ordering.\nTest the range for partial ordering.\nTest the range for partial ordering.\nTest the range for partial ordering.\nTest the range for partial ordering.\nPerform a partial equality test between two values.\nTest the range for partial equality.\nTest the full range for partial equality.\nTest the range for partial equality.\nTest the range for partial equality.\nTest the range for partial equality.\nTest the range for partial equality.\nPop the last byte.\nRemoves the last element from a dynamic vector and returns …\nAppends an element to the back of a dynamic vector.\nAppends an element to the back of a dynamic vector, …\nRemoves a key from the map, returning the value at the key …\nRemoves the element at the specified index from a dynamic …\nReserve additional space.\nResever additional space to the exact amount specified.\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nResume the current execution without support for async …\nResume the generator with a value and get the next …\nResume the generator and return the next generator state.\nResume the current execution with the given value and …\nResume the current execution without support for async …\nAccess runtime type information.\nAccess runtime type information.\nAccess struct rtti.\nConvert into iterator\nAn iterator visiting all keys and values in arbitrary …\nIterate over the vector.\nAn iterator visiting all keys in arbitrary order.\nAn iterator visiting all values in arbitrary order.\nAn <code>execute</code> variant that returns an execution which …\nSet by index\nSet  the current instruction pointer.\nShrink to fit the amount of bytes in the container.\nConstruct an instruction to push an integer.\nTypes for working with slices.\nGet the slice at the given address with the given length.\nGet the slice at the given address with the given length.\nAccess the given slice mutably.\nGet the mutable slice at the given address with the given …\nSort the vector with the given comparison function.\nGet the stack.\nGet the stack mutably.\nThe start value of the range.\nThe start value of the range.\nThe start value of the range.\nStep the single execution for one step without support for …\nWrite output using the provided <code>IntoOutput</code> implementation …\nTake a mutable value, replacing the original location with …\nConvert something into a <code>ConstValue</code>.\nConvert into a constant value.\nConvert something into a return value.\nConvert something into the dynamic <code>Value</code>.\nConvert into a value.\nThe top of the stack at the time of the call to ensure …\nTry to borrow a reference to the interior value while …\nTry to borrow a reference to the interior value while …\nConvert arguments into a vector.\nTry to map the mutable reference to a projection.\nTry to map the reference to a projection.\nTry to map the reference to a projection.\nTry to map the mutable reference to a projection.\nConstruct a tuple.\nConstruct a new tuple constant value.\nConstruct a typed tuple.\nConstruct an instruction to push a type.\nType Hash of the underlying function.\nGet the type hash for the current value.\nType Hash of the underlying function.\nAccess the type hash of the RTTI.\nGet human readable type information for the dynamic tuple.\nGet human readable type information for the dynamic tuple.\nGet human readable type information for the dynamic struct.\nGet type info associated with the current type.\nGet type info associated with the current type.\nGet type info for the typed tuple.\nGet type info for the typed tuple.\nGet the type information for the current value.\nAccess the type information for the RTTI.\nA single execution unit in the rune virtual machine.\nConstruct an instruction to push a unit.\nAccess the underlying unit of the virtual machine.\nAccess the underlying unit of the virtual machine mutably.\nCoerce the output of an unsafe from value into the final …\nConvert the given reference using unsafe assumptions to a …\nSafety\nSafety\nConvert into a value.\nConstruct an instruction to push an unsigned integer.\nUnwrap the interior value.\nAn iterator visiting all values in arbitrary order. The …\nConstruct a vector.\nGet a reference to the current virtual machine.\nGet a mutable reference the current virtual machine.\nCall the provided closure within the context of this …\nConstruct a byte array with the given preallocated …\nConstruct a new object with the given capacity.\nConstruct a new dynamic vector guaranteed to have at least …\nConstruct a new virtual machine with a custom stack.\nConstruct a vm with a default empty RuntimeContext. This …\nOffset to the first value.\nThe address of the first argument.\nThe operand to negate.\nThe operand to negate.\nAddress of the future being awaited.\nThe tuple to push.\nThe address of the value to test.\nAddress of the value being yielded.\nWhere to load captured values from.\nThe address where the arguments are stored.\nThe address of the arguments being passed.\nThe address of arguments being passed.\nThe address of the instance for which the function is …\nThe address of the arguments being passed.\nThe address where the tuple we are getting from is stored.\nThe address where the object is stored.\nThe base address of futures being waited on.\nAddress of the value being copied.\nAddress of the value being moved.\nThe address of the value to return.\nWhere the arguments to the vector are stored.\nTuple arguments.\nTuple arguments.\nTuple arguments.\nTuple arguments.\nWhere the arguments to the tuple are stored.\nWhere the arguments to the tuple are stored.\nThe address to load fields from.\nWhere constructor arguments are stored.\nWhere the strings to concatenate are stored.\nAddress of the value being formatted.\nAddress of value to try.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nThe address of the value to test.\nThe address of the value to test.\nThe address of the value to test.\nThe address of the value to test.\nThe address of the value to test.\nWhere the arguments to construct the variant are stored.\nThe address of the iterator to advance.\nThe number of arguments passed in at <code>addr</code>.\nThe number of arguments passed in at <code>addr</code>.\nThe number of arguments passed in at <code>addr</code>.\nThe number of arguments passed in at <code>addr</code>.\nOffset to the second value.\nThe address of the second argument.\nThe calling convention to use.\nThe address of the condition for the jump.\nThe address of the condition for the jump.\nThe expected size of the tuple.\nThe number of captured values to store in the environment.\nThe number of elements in the vector.\nThe number of elements in the tuple.\nThe number of constructor arguments.\nThe container type.\nWhether the operation should check exact <code>true</code> or minimum …\nWhether the operation should check exact <code>true</code> or minimum …\nThe address of the function being called.\nThe hash of the internally stored closure function.\nThe hash of the function to call.\nThe hash of the name of the function to call.\nThe name hash of the instance function.\nThe hash of the function to push.\nThe type of the object to construct.\nThe type of the struct to construct.\nThe type of the struct to construct.\nThe type hash to match against.\nThe index to set.\nHow the index is addressed.\nThe index to set.\nThe index to fetch.\nThe index of the variant.\nOffset to jump to.\nOffset to jump to.\nThe offset to jump if the condition is true.\nA relative jump to perform if the iterator could not be …\nThe number of futures to poll.\nThe number of items to pop from the stack.\nThe minimum length to test for.\nThe offset of the function being called in the same unit.\nThe actual operation.\nThe actual operation.\nWhether the produced value from the not should be kept or …\nWhether the produced value from the negation should be …\nWhether the produced value from the await should be kept …\nWhere to unpack the environment.\nWhere to store the output.\nWhere to store the produced resume value.\nWhere to store the produced resume value.\nWhere to store the produced closure.\nWhether the return value should be kept or not.\nWhether the return value should be kept or not.\nWhether the return value should be kept or not.\nWhere to store the loaded instance function.\nWhether the returned value from calling the function …\nWhether the produced value should be kept or not.\nWhether the produced value should be kept or not.\nWhere to store the fetched value.\nWhere to store the loaded function.\nWhere the value is being copied to.\nWhere the value is being copied to.\nWhere the value is being moved to.\nWhere to store the produced vector.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced range.\nWhere to write the empty struct.\nWhere to write the constructed struct.\nWhere to write the constructed struct.\nWhere to store the string.\nWhere to store the bytes.\nWhere to store the produced string.\nWhere to store the produced format.\nWhere to store the value in case there is a continuation.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the output.\nWhere to store the output.\nWhere to store the output.\nWhere to store the output.\nWhere to store the output.\nWhere to store the variant.\nWhether the produced value from the operation should be …\nWhere to store the produced value from the iterator.\nThe kind of the range, which determines the number …\nThe reason for the panic.\nAn indicator of the set of addresses to drop.\nThe size of the memory region to allocate.\nThe minimum string size used.\nThe static string slot corresponding to the index to set.\nThe static string slot corresponding to the index to fetch.\nThe static slot of the object keys.\nThe static string slot to load the string from.\nThe static byte string slot to load the string from.\nThe slot to test against.\nThe slot to test against.\nThe slot of object keys to use.\nThe format specification to use.\nThe object being assigned to.\nHow the target is addressed.\nThe object being assigned to.\nThe object being assigned to.\nThe target of the operation.\nThe type to check for.\nType constraints that the sequence must match.\nThe value being assigned.\nThe value being assigned.\nThe value being assigned.\nWhere to store the value produced by the future that …\nThe value to push.\nThe character to test against.\nThe value to test against.\nThe value to test against.\nThe value to test against.\nThe value being assigned.\nThe kind of built-in variant to construct.\nThe exact type hash of the variant.\nThe end address of the range.\nThe end address of the range.\nThe end address of the range.\nThe end address of the range.\nThe start address of the range.\nThe start address of the range.\nThe start address of the range.\nWrapper for something being budgeted.\nA locally acquired budget.\nAcquire the current budget.\nCall the budgeted function.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake a ticker from the budget.\nWrap the given value with a budget.\nDebug information on function arguments.\nDebug information about a unit.\nDebug information for every instruction.\nA description of a function signature.\nAn empty, with not arguments.\nA collection of named arguments.\nA tuple, with the given number of arguments.\nThe number of arguments expected in the function.\nThe comment for the line.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the function corresponding to the given instruction …\nFunction signatures.\nReverse lookup of a function.\nHash to identifier.\nAccess an identifier for the given hash - if it exists.\nGet debug instruction at the given instruction pointer.\nDebug information on each instruction.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLabel associated with the location.\nConstruct a new debug instruction.\nConstruct a new function signature.\nThe path of the function.\nThe file by id the instruction belongs to.\nThe span of the instruction.\nThe alignment requested.\nError raised when trying to parse an alignment string and …\nAlternate specifier <code>#</code>.\nBinary formatting type.\nCenter alignment.\nDebug type.\nDisplay type (default).\nA single flag for format spec.\nFormat specification flags.\nA format specification, wrapping an inner value.\nA format specification.\nLeft alignment.\nUpper hex type.\nPointer formatting type.\nRight alignment.\nSign-aware zero pad <code>0</code>.\nMinus sign <code>-</code>.\nPlus sign <code>+</code>.\nThe type of formatting requested.\nError raised when trying to parse a type string and it …\nUpper hex type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the flags as a number. This representation is not …\nCheck if the set of flags is empty.\nConstruct a new format specification.\nSet the given flag.\nTest the given flag.\nUnit stored as array of instructions.\nUnit stored as byte code, which is a more compact …\nDefault storage implementation to use.\nInstructions from a single source file.\nInstructions and debug info from a single compilation.\nBuilder trait for unit storage.\nInstruction storage used by a <code>Unit</code>.\nAccess debug information for the given location if it is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a new unit from a pair of data and debug info.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccess unit data.\nError raised when constructing a source.\nA single source file.\nReturns the argument unchanged.\nRead and load a source from the given filesystem path.\nCalls <code>U::from(self)</code>.\nConstruct a new anonymously named <code>&lt;memory&gt;</code> source.\nGet the name of the source.\nConstruct a new source with the given name.\nGet the path associated with the source.\nConvert the given offset to a utf-16 line and character.\nConstruct a new source with the given content and path.\nTry very hard to emit colors. This includes emitting ANSI …\nAlwaysAnsi is like Always, except it never tries to use …\nSatisfies <code>WriteColor</code> using standard ANSI escape sequences.\nTry to use colors, but don’t force the issue. If the …\nWrite colored text to memory.\nWrites colored buffers to stdout or stderr.\nLike <code>StandardStream</code>, but does buffered writing.\nThe set of available colors for the terminal …\nColorChoice represents the color preferences of an end …\nAn error that occurs when parsing a <code>ColorChoice</code> fails.\nA color specification.\nA hyperlink specification.\nNever emit colors.\nSatisfies <code>WriteColor</code> but ignores all color options.\nAn error from parsing an invalid color specification.\nSatisfies <code>io::Write</code> and <code>WriteColor</code>, and supports optional …\n<code>StandardStreamLock</code> is a locked reference to a …\nThis trait describes the behavior of writers that support …\nCreate a buffer that uses ANSI escape sequences.\nReturn the underlying data of the buffer as a mutable …\nReturn the underlying data of the buffer.\nGet the background color.\nGet whether this is bold or not.\nCreates a new <code>Buffer</code> with the current color preferences.\nClears this buffer.\nClears this color specification so that it has no …\nCreates a hyperlink specification representing no …\nGet whether this is dimmed or not.\nGet the foreground color.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn a mutable reference to the inner writer.\nReturn a mutable reference to the inner writer.\nReturn a reference to the inner writer.\nReturn a reference to the inner writer.\nGet whether this is intense or not.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume this buffer and return the underlying raw data.\nConsume this <code>NoColor</code> value and return the inner writer.\nConsume this <code>Ansi</code> value and return the inner writer.\nReturn the string that couldn’t be parsed as a valid …\nReturns true if and only if this buffer is empty.\nReturns true if this color specification has no colors or …\nReturns true if and only if the underlying writer must …\nGet whether this is italic or not.\nReturns the length of this buffer in bytes.\nLock the underlying writer.\nCreate a new writer that satisfies <code>WriteColor</code> but drops …\nCreate a new writer that satisfies <code>WriteColor</code> using …\nCreate a new color specification that has no colors or …\nCreate a buffer that drops all color information.\nCreates a new hyperlink specification.\nPrints the contents of the given buffer.\nReset the current color settings to their original …\nGet whether reset is enabled or not.\nIf set, the separator given is printed between buffers. By …\nSet the background color.\nSet whether the text is bolded or not.\nSet the color settings of the writer.\nSet whether the text is dimmed or not.\nSet the foreground color.\nSet the current hyperlink of the writer.\nSet whether the text is intense or not.\nSet whether the text is italicized or not.\nSet whether to reset the terminal whenever color settings …\nSet whether the text is strikethrough or not.\nSet whether the text is underlined or not.\nCreate a new <code>StandardStream</code> with the given color …\nCreate a new <code>BufferedStandardStream</code> with the given color …\nCreate a new <code>BufferWriter</code> that writes to stderr with the …\nCreate a new <code>StandardStream</code> with the given color …\nCreate a new <code>BufferedStandardStream</code> with the given color …\nCreate a new <code>BufferWriter</code> that writes to stdout with the …\nGet whether this is strikethrough or not.\nReturns true if and only if the underlying writer supports …\nReturns true if and only if the underlying writer supports …\nGet whether this is underline or not.\nReturns the URI of the hyperlink if one is attached to …\nLook for all things.\nAllocation Error.\nThe found entry is a benchmark.\nThe found entry is a binary.\nA prepared build.\nFailed to build workspace.\nCodespan reporting error.\nA single workspace diagnostic.\nDiagnostics emitted about a workspace.\nErrors that can be raised when formatting diagnostics.\nThe found entry is an example.\nAn error in a workspace.\nA fatal diagnostic in a workspace.\nA filesystem-based source loader.\nA found item in the workspace.\nThe kind of a found entry.\nA found item in the workspace associated with a package.\nSource Error.\nThe name of the toplevel manifest <code>Rune.toml</code>.\nThe manifest of a workspace.\nLook for one specific named thing.\nA single package.\nA source loader.\nThe found entry is a test.\nAn error raised when interacting with workspaces.\nA workspace filter which in combination with functions …\nAutomatically detect benches.\nAutomatically detect binaries.\nAutomatically detect examples.\nAutomatically detect tests.\nPerform the build.\nAccess underlying diagnostics.\nGenerate formatted diagnostics capable of referencing …\nAccess the underlying workspace error.\nFind every single entrypoint available.\nFind every single entrypoint available.\nFind all benches matching the given name in the workspace.\nFind all benches matching the given name in the workspace.\nFind all binaries matching the given name in the workspace.\nFind all binaries matching the given name in the workspace.\nFind all examples matching the given name in the workspace.\nFind all examples matching the given name in the workspace.\nFind all tests associated with the given base name.\nFind all tests associated with the given base name.\nA found path that can be built.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTest if diagnostics has errors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if diagnostics is empty.\nThe kind found.\nLoad the given path.\nConstruct a custom message as an error.\nName of the found thing.\nThe name of the package.\nConstruct an empty diagnostics container.\nConstruct a new filesystem-based source loader.\nIndex of the package build belongs to.\nList of packages found.\nA found path that can be built.\nPrepare a workspace build.\nThe root of the package.\nGet source id of the diagnostic.\nThe version of the package..\nAssociate a specific diagnostic with the build.\nAssociate a specific source loader with the build.")