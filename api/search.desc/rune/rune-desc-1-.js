searchState.loadedDescShard("rune", 1, "Access the value at the given frame offset.\nGet a value mutable at the given index from the stack …\nGet a value mutable at the given index from the stack …\nConstruct an instruction to push a boolean.\nBorrow the value as a mutable typed reference.\nBorrow the value as a typed reference.\nCoerce into <code>bool</code>.\nCoerce into <code>bool</code>.\nCoerce into <code>u8</code> byte.\nCoerce into <code>u8</code> byte.\nCoerce into <code>Bytes</code>.\nCoerce into <code>Bytes</code>.\nCoerce into <code>char</code>.\nCoerce into <code>char</code>.\nCoerce into a <code>ControlFlow</code>.\nCoerce into a <code>ControlFlow</code>.\nCoerce into <code>f64</code> float.\nCoerce into <code>f64</code> float.\nCoerce into a <code>Format</code>.\nCoerce into a <code>Format</code>.\nCoerce into a <code>Function</code>.\nCoerce into a <code>Function</code>.\nCoerce into a <code>Future</code>.\nCoerce into a <code>Future</code>.\nCoerce into a <code>Generator</code>.\nCoerce into a <code>Generator</code>.\nCoerce into a <code>GeneratorState</code>.\nCoerce into a <code>GeneratorState</code>.\nCoerce into <code>i64</code> integer.\nCoerce into <code>i64</code> integer.\nCoerce into a <code>Object</code>.\nCoerce into a <code>Object</code>.\nCoerce into <code>Option</code>.\nCoerce into <code>Option</code>.\nCoerce into <code>Ordering</code>.\nCoerce into <code>Ordering</code>.\nCoerce into a <code>RangeFrom</code>.\nCoerce into a <code>RangeFrom</code>.\nCoerce into a <code>RangeFull</code>.\nCoerce into a <code>RangeFull</code>.\nCoerce into a <code>RangeInclusive</code>.\nCoerce into a <code>RangeInclusive</code>.\nCoerce into a <code>Range</code>.\nCoerce into a <code>Range</code>.\nCoerce into a <code>RangeToInclusive</code>.\nCoerce into a <code>RangeToInclusive</code>.\nCoerce into a <code>RangeTo</code>.\nCoerce into a <code>RangeTo</code>.\nCoerce into <code>Result</code>.\nCoerce into <code>Result</code>.\nCoerce into a <code>Stream</code>.\nCoerce into a <code>Stream</code>.\nBorrow the value of a string as a reference.\nCoerce into <code>Struct</code>\nCoerce into <code>Struct</code>\nCoerce into <code>Tuple</code>.\nCoerce into <code>Tuple</code>.\nCoerce into <code>Type</code>.\nCoerce into <code>Type</code>.\nCoerce into <code>Vec</code>.\nCoerce into <code>Vec</code>.\nBudgeting module for Runestick.\nConstruct an instruction to push a byte.\nPerform a call over the function represented by this …\nPerform a call over the function represented by this …\nCall the given function immediately, returning the …\nGet the stack.\nCall the given function immediately, returning the …\nGet the capacity of the bytes collection.\nReturns the number of elements in the dynamic vector, also …\nGet the full backtrace of errors and their corresponding …\nConstruct an instruction to push a character.\nGet the bytes collection.\nClears the object, removing all key-value pairs. Keeps the …\nClears the vector, removing all values.\nReset this virtual machine, freeing all memory used.\nPerform a shallow clone of the value using the <code>CLONE</code> …\nTest the range for total ordering.\nTest the range for total ordering.\nTest the range for total ordering.\nTest the range for total ordering.\nTest the range for total ordering.\nPerform a total ordering comparison between two values.\nComplete the current execution without support for async …\nRun the given vm to completion.\nComplete the current execution without support for async …\nRead a constant value from the unit.\nReturns <code>true</code> if the map contains a value for the specified …\nAccess the context related to the virtual machine.\nAccess the context related to the virtual machine mutably.\nThe number of arguments.\nThe number of arguments.\nAccess underlying data.\nAccess underlying data.\nAccess the underlying variant data.\nAccess underlying data mutably.\nAccess underlying data mutably.\nAccess the underlying variant data mutably.\nDebug information for units.\nDebug format the current any type.\nReturns stored value if it is of type <code>T</code>, or <code>None</code> if it isn…\nReturns some mutable reference to the boxed value if it is …\nReturns some reference to the boxed value if it is of type …\nGenerate formatted diagnostics capable of referencing …\nConstruct an empty.\nThe end value of the range.\nThe end value of the range.\nThe end value of the range.\nThe to value of the range.\nThe type hash of the enum.\nTest the range for total equality.\nTest the range for total equality.\nTest the range for total equality.\nTest the range for total equality.\nTest the range for total equality.\nPerform a total equality test between two values.\nCall the function identified by the given name.\nExpect a value or panic.\nConstruct an expectation error. The actual type received …\nConstruct an expectation error. The actual type received …\nExtend these bytes with another collection of bytes.\nExtend this vector with something that implements the …\nConstruct a hash.\nGet the first byte.\nGet the first error location.\nConstruct an instruction to push a float.\nTypes for dealing with formatting specifications.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct from an atomically reference-counted value.\nConstruct from an atomically reference-counted value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct an Any that wraps a Deref type, behaving as the …\nConstruct an Any that wraps a DerefMut type, behaving as …\nLook up protocol for the given hash.\nConstruct an Any that wraps a mutable pointer.\nConstruct a value that wraps a mutable pointer.\nConvert a raw reference and guard into a regular reference.\nConvert a raw mutable reference and guard into a regular …\nConstruct an Any that wraps a pointer.\nConstruct an Any that wraps a pointer.\nConvert a slice into bytes.\nConstruct a static reference.\nConstruct a static mutable reference.\nConstruct from a static string.\nConvert something into the dynamic <code>Value</code>.\nTry to convert to the given type, from the given value.\nConvert a byte array into bytes.\nSee <code>Function::new</code>.\nLookup the given native function handler in the context.\nReturns a reference to the value corresponding to the key.\nGet the value at the given index in the tuple.\nGet the given key in the object.\nGet the value at the given index.\nReturns a mutable reference to the value corresponding to …\nGet the mutable value at the given index in the tuple.\nGet the given mutable value by key in the object.\nGet the mutable value at the given index.\nGet the given value at the given index.\nGet the given value at the given index.\nGet the given value at the given index.\nGet the hash of the string.\nHash the current value.\nThe hash of the builtin function.\nThe type hash of the item.\nThe type variant hash.\nThe type hash of the type.\nInserts a key-value pair into the map.\nInserts an element at position index within the vector, …\nInserts a key-value pair into the dynamic object, …\nConstruct an instruction to push an integer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to coerce value into a typed value.\nTry to coerce value into a typed mutable reference.\nCoerce into an <code>AnyObj</code>.\nTry to coerce value into a typed reference.\nEncode arguments as array.\nTry to coerce into boolean.\nCoerce into <code>bool</code>.\nCoerce into <code>bool</code>.\nCoerce into <code>u8</code> byte.\nCoerce into <code>u8</code> byte.\nCoerce into <code>Bytes</code>.\nCoerce into <code>Bytes</code>.\nCoerce into <code>Bytes</code>.\nCoerce into <code>char</code>.\nCoerce into <code>char</code>.\nCoerce into a <code>ControlFlow</code>.\nCoerce into a <code>ControlFlow</code>.\nCoerce into a <code>ControlFlow</code>.\nCoerce into <code>f64</code> float.\nCoerce into <code>f64</code> float.\nCoerce into a <code>Format</code>.\nCoerce into a <code>Format</code>.\nCoerce into a <code>Format</code>.\nCoerce into a <code>Function</code>.\nCoerce into a <code>Function</code>.\nCoerce into a <code>Function</code>.\nCoerce into a future, or convert into a future using the …\nCoerce into a <code>Future</code>.\nCoerce into a <code>Future</code>.\nCoerce the current execution into a generator if …\nCoerce into a <code>Generator</code>.\nCoerce into a <code>Generator</code>.\nCoerce into a <code>Generator</code>.\nCoerce into a <code>GeneratorState</code>.\nCoerce into a <code>GeneratorState</code>.\nCoerce into a <code>GeneratorState</code>.\nCoerce into inner type hash.\nConvert into inner std boxed slice.\nConvert into inner.\nConvert into inner rune alloc vector.\nCoerce into <code>i64</code> integer.\nCoerce into <code>i64</code> integer.\nCreates a consuming iterator, that is, one that moves each …\nBuild an iterator over the range.\nIterate over the range.\nIterate over the range.\nConvert value into an iterator using the …\nCoerce into a <code>Object</code>.\nCoerce into a <code>Object</code>.\nCoerce into a <code>Object</code>.\nCoerce into <code>Option</code>.\nCoerce into <code>Option</code>.\nCoerce into <code>Ordering</code>.\nCoerce into <code>Ordering</code>.\nCoerce the current value into an output.\nConvert the current execution into one which owns its …\nConvert the current generator into one which owns its …\nConvert the current stream into one which owns its virtual …\nCoerce into a <code>Range</code>.\nCoerce into a <code>RangeFrom</code>.\nCoerce into a <code>RangeFrom</code>.\nCoerce into a <code>RangeFrom</code>.\nCoerce into a <code>RangeFull</code>.\nCoerce into a <code>RangeFull</code>.\nCoerce into a <code>RangeFull</code>.\nCoerce into a <code>RangeInclusive</code>.\nCoerce into a <code>RangeInclusive</code>.\nCoerce into a <code>RangeInclusive</code>.\nCoerce into a <code>Range</code>.\nCoerce into a <code>Range</code>.\nCoerce into a <code>RangeTo</code>.\nCoerce into a <code>RangeToInclusive</code>.\nCoerce into a <code>RangeToInclusive</code>.\nCoerce into a <code>RangeToInclusive</code>.\nCoerce into a <code>RangeTo</code>.\nCoerce into a <code>RangeTo</code>.\nConvert into a raw pointer and associated raw access guard.\nConvert into a raw pointer and associated raw access guard.\nConvert a <code>VmResult</code> into a <code>Result</code>.\nCoerce into <code>Result</code>.\nCoerce into <code>Result</code>.\nEncode arguments onto a stack.\nCoerce the current execution into a stream if appropriate.\nCoerce into a <code>Stream</code>.\nCoerce into a <code>Stream</code>.\nCoerce into a <code>Stream</code>.\nTake the current value as a string.\nCoerce into <code>Struct</code>\nCoerce into <code>Struct</code>\nCoerce into <code>Struct</code>\nTry to convert into a SyncFunction. This might not be …\nCoerce into <code>Tuple</code>.\nCoerce into <code>Tuple</code>.\nCoerce into <code>Tuple</code>.\nCoerce into <code>Type</code>.\nRetrieves a human readable type name for the current value.\nCoerce into <code>Type</code>.\nCoerce into a unit.\nConvert into a value that can be pushed onto the stack.\nConvert the byte array into a vector of bytes.\nCoerce into <code>Vec</code>.\nCoerce into <code>Vec</code>.\nCoerce into <code>Vec</code>.\nAccess the current instruction pointer.\nThe stored instruction pointer.\nReturns <code>true</code> if the boxed type is the same as <code>T</code>.\nTest if the state is complete.\nCheck if future is completed.\nTest if the collection is empty.\nReturns <code>true</code> if the object is empty.\nReturns <code>true</code> if the vector contains no elements.\nTest if the result is an error.\nTest if the result is an ok.\nTest if the value is readable.\nTest if the virtual machine is the same context and unit …\nTest if the virtual machine is the same context.\nTest if the virtual machine is the same context.\nTest if the value is writable.\nTest if the state is yielded.\nIndicates that the call frame is isolated and should force …\nThe name of the variant.\nThe item of the type.\nAn iterator visiting all key-value pairs in arbitrary …\nIterate over the range.\nIterate over the range.\nIterate over the range.\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all keys in arbitrary order. The …\nGet the last byte.\nAccess the last instruction that was executed.\nGet the length of the bytes collection.\nReturns the number of elements in the object.\nReturns the number of elements in the dynamic vector, also …\nLook up a function in the virtual machine by its name.\nMap the reference.\nMap the mutable reference.\nMap the interior reference of an owned mutable value.\nMap the interior reference of an owned mutable value.\nType information for the given type.\nThe name of the builtin function.\nThe name of the type.\nConstruct a new any from the original any.\nConstruct a new empty tuple.\nConstruct a new byte array.\nConstruct a Function from a Rust closure.\nConstruct a new wrapped future.\nConstruct a new object.\nConstruct a new range.\nConstruct a new range.\nConstruct a new range.\nConstruct a new range.\nConstruct a new range.\nConstruct a new range.\nConstruct a new static string.\nConstruct a new tuple slice from a reference.\nConstructs a new, empty dynamic <code>Vec</code>.\nConstruct a new vector tuple for serializing values.\nConstruct a new virtual machine.\nConstruct a new empty formatter.\nConstruct a new tuple slice from a mutable reference.\nConstruct a new any with the specified raw components.\nGet the next value produced by this stream.\nGet the next value produced by this stream.\nKeep the value produced from the call frame.\nConstruct an overflow error.\nConstruct an error containing a panic.\nConstruct a result containing a panic.\nTest the range for partial ordering.\nTest the range for partial ordering.\nTest the range for partial ordering.\nTest the range for partial ordering.\nTest the range for partial ordering.\nPerform a partial ordering comparison between two values.\nTest the range for partial equality.\nTest the range for partial equality.\nTest the range for partial equality.\nTest the range for partial equality.\nTest the range for partial equality.\nPerform a partial equality test between two values.\nPop the last byte.\nRemoves the last element from a dynamic vector and returns …\nAppends an element to the back of a dynamic vector.\nAppends an element to the back of a dynamic vector, …\nRemoves a key from the map, returning the value at the key …\nRemoves the element at the specified index from a dynamic …\nReserve additional space.\nResever additional space to the exact amount specified.\nResume the current execution without support for async …\nResume the generator with a value and get the next …\nGet the next value produced by this stream.\nResume the current execution with the given value and …\nResume the current execution without support for async …\nAccess runtime type information.\nAccess runtime type information.\nAccess runtime type information.\nAccess the rtti of the variant.\nConvert into iterator\nAn iterator visiting all keys and values in arbitrary …\nIterate over the vector.\nAn iterator visiting all keys in arbitrary order.\nAn iterator visiting all values in arbitrary order.\nAn <code>execute</code> variant that returns an execution which …\nSet by index\nSet  the current instruction pointer.\nShrink to fit the amount of bytes in the container.\nTypes for working with slices.\nGet the slice at the given address with the given length.\nGet the slice at the given address with the given length.\nGet the mutable slice at the given address with the given …\nGet snapshot of value.\nSort the vector with the given comparison function.\nGet the stack.\nGet the stack mutably.\nThe start value of the range.\nThe start value of the range.\nThe start value of the range.\nStep the single execution for one step without support for …\nWrite output using the provided <code>IntoOutput</code> implementation …\nDebug format the value using the <code>STRING_DEBUG</code> protocol.\nFormat the value using the Protocol::STRING_DISPLAY …\nConstruct a struct variant.\nConvert something into the dynamic <code>Value</code>.\nConvert into a value.\nThe top of the stack at the time of the call to ensure …\nTry to coerce the current value as the specified integer <code>T</code>.\nConvert arguments into a vector.\nTry to map the reference to a projection.\nTry to map the mutable reference to a projection.\nTry to map the reference to a projection.\nTry to map the mutable reference to a projection.\nConstruct a tuple.\nConstruct a tuple variant.\nConstruct a typed tuple.\nConstruct a tuple variant.\nGet full type hash, including type parameters.\nAccess the underlying type id for the data.\nType Hash of the underlying function.\nType Hash of the underlying function.\nGet the type hash of the object.\nGet the type hash for the current value.\nAccess diagnostical information on the value type.\nAccess full type info for type.\nGet the type information of the value.\nGet type info for the typed tuple.\nGet type info for the typed tuple.\nGet type info for the typed object.\nGet the type information for the current value.\nGet type info for the variant.\nAccess the underlying type name for the data.\nHash of type parameters.\nHash of type parameters.\nA single execution unit in the rune virtual machine.\nConstruct an instruction to push a unit.\nConstruct a unit variant.\nAccess the underlying unit of the virtual machine.\nAccess the underlying unit of the virtual machine mutably.\nConstruct an empty variant.\nCoerce the output of an unsafe from value into the final …\nConvert the given reference using unsafe assumptions to a …\nEncode arguments onto a stack.\nSafety\nSafety\nConvert into a value.\nUnwrap the interior value.\nAn iterator visiting all values in arbitrary order. The …\nConstruct a vector.\nGet a reference to the current virtual machine.\nGet a mutable reference the current virtual machine.\nCall the provided closure within the context of this …\nConstruct a byte array with the given preallocated …\nConstruct a new object with the given capacity.\nConstruct a new dynamic vector guaranteed to have at least …\nConstruct a new virtual machine with a custom stack.\nConstruct a vm with a default empty RuntimeContext. This …\nOffset to the first value.\nThe address of the first argument.\nThe operand to negate.\nThe operand to negate.\nAddress of the future being awaited.\nThe tuple to push.\nThe address of the value to test.\nAddress of the value being yielded.\nWhere to load captured values from.\nThe address where the arguments are stored.\nThe address of the arguments being passed.\nThe address of arguments being passed.\nThe address of the instance for which the function is …\nThe address of the arguments being passed.\nThe address where the tuple we are getting from is stored.\nThe address where the object is stored.\nThe base address of futures being waited on.\nAddress of the value being copied.\nAddress of the value being moved.\nAddress of the value being dropped.\nThe address of the value to return.\nWhere the arguments to the vector are stored.\nWhere the arguments to the tuple are stored.\nWhere the arguments to the tuple are stored.\nWhere the arguments of the range are stored.\nThe address to load fields from.\nThe address to load fields from.\nWhere the strings to concatenate are stored.\nAddress of the value being formatted.\nAddress of value to try.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nAddress of the value to compare.\nThe address of the value to test.\nThe address of the value to test.\nThe address of the value to test.\nThe address of the value to test.\nThe address of the value to test.\nWhere the arguments to construct the variant are stored.\nThe address of the iterator to advance.\nThe number of arguments passed in at <code>addr</code>.\nThe number of arguments passed in at <code>addr</code>.\nThe number of arguments passed in at <code>addr</code>.\nThe number of arguments passed in at <code>addr</code>.\nFirst element of the tuple.\nTuple arguments.\nTuple arguments.\nTuple arguments.\nOffset to the second value.\nThe address of the second argument.\nThe calling convention to use.\nThe address of the condition for the jump.\nThe address of the condition for the jump.\nThe expected size of the tuple.\nThe number of captured values to store in the environment.\nThe number of elements in the vector.\nThe number of elements in the tuple.\nThe container type.\nWhether the operation should check exact <code>true</code> or minimum …\nWhether the operation should check exact <code>true</code> or minimum …\nThe address of the function being called.\nThe hash of the internally stored closure function.\nThe hash of the function to call.\nThe hash of the name of the function to call.\nThe name hash of the instance function.\nThe hash of the function to push.\nThe type of the object to construct.\nThe type of the object to construct.\nThe type hash of the object variant to construct.\nThe type hash to match against.\nThe index to set.\nHow the index is addressed.\nThe index to set.\nThe index to fetch.\nThe index of the variant.\nOffset to jump to.\nOffset to jump to.\nThe offset to jump if the condition is true.\nA relative jump to perform if the iterator could not be …\nThe number of futures to poll.\nThe number of items to pop from the stack.\nThe minimum length to test for.\nThe offset of the function being called in the same unit.\nThe actual operation.\nThe actual operation.\nWhether the produced value from the not should be kept or …\nWhether the produced value from the negation should be …\nWhether the produced value from the await should be kept …\nWhere to unpack the environment.\nWhere to store the output.\nWhere to store the produced resume value.\nWhere to store the produced resume value.\nWhere to store the produced closure.\nWhether the return value should be kept or not.\nWhether the return value should be kept or not.\nWhether the return value should be kept or not.\nWhere to store the loaded instance function.\nWhether the returned value from calling the function …\nWhether the produced value should be kept or not.\nWhether the produced value should be kept or not.\nWhere to store the fetched value.\nWhere to store the loaded function.\nWhere the value is being copied to.\nWhere the value is being copied to.\nWhere the value is being moved to.\nWhere to store the produced vector.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced tuple.\nWhere to store the produced range.\nWhere to write the empty struct.\nWhere to write the constructed struct.\nWhere to write the constructed variant.\nWhere to store the string.\nWhere to store the bytes.\nWhere to store the produced string.\nWhere to store the produced format.\nWhere to store the value in case there is a continuation.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the result of the comparison.\nWhere to store the output.\nWhere to store the output.\nWhere to store the output.\nWhere to store the output.\nWhere to store the output.\nWhere to store the variant.\nWhether the produced value from the operation should be …\nWhere to store the produced value from the iterator.\nThe kind of the range, which determines the number of …\nThe reason for the panic.\nThe size of the memory region to allocate.\nThe minimum string size used.\nThe static string slot corresponding to the index to set.\nThe static string slot corresponding to the index to fetch.\nThe static slot of the object keys.\nThe static slot of the object keys.\nThe static slot of the object keys.\nThe static string slot to load the string from.\nThe static byte string slot to load the string from.\nThe slot to test against.\nThe slot to test against.\nThe slot of object keys to use.\nThe format specification to use.\nThe object being assigned to.\nHow the target is addressed.\nThe object being assigned to.\nThe object being assigned to.\nThe target of the operation.\nThe type to check for.\nType constraints that the sequence must match.\nThe value being assigned.\nThe value being assigned.\nThe value being assigned.\nWhere to store the value produced by the future that …\nThe value to push.\nThe byte to test against.\nThe character to test against.\nThe value to test against.\nThe value to test against.\nThe value being assigned.\nThe kind of built-in variant to construct.\nThe exact type hash of the variant.\nWrapper for something being budgeted.\nA locally acquired budget.\nAcquire the current budget.\nCall the budgeted function.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake a ticker from the budget.\nWrap the given value with a budget.\nDebug information on function arguments.\nDebug information about a unit.\nDebug information for every instruction.\nA description of a function signature.\nAn empty, with not arguments.\nA collection of named arguments.\nA tuple, with the given number of arguments.\nThe number of arguments expected in the function.\nThe comment for the line.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the function corresponding to the given instruction …\nFunction signatures.\nReverse lookup of a function.\nHash to identifier.\nAccess an identifier for the given hash - if it exists.\nGet debug instruction at the given instruction pointer.\nDebug information on each instruction.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLabel associated with the location.\nConstruct a new debug instruction.\nConstruct a new function signature.\nThe path of the function.\nThe file by id the instruction belongs to.\nThe span of the instruction.\nThe alignment requested.\nError raised when trying to parse an alignment string and …\nAlternate specifier <code>#</code>.\nBinary formatting type.\nCenter alignment.\nDebug type.\nDisplay type (default).\nA single flag for format spec.\nFormat specification flags.\nA format specification, wrapping an inner value.\nA format specification.\nLeft alignment.\nUpper hex type.\nPointer formatting type.\nRight alignment.\nSign-aware zero pad <code>0</code>.\nMinus sign <code>-</code>.\nPlus sign <code>+</code>.\nThe type of formatting requested.\nError raised when trying to parse a type string and it …\nUpper hex type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the flags as a number. This representation is not …\nCheck if the set of flags is empty.\nConstruct a new format specification.\nSet the given flag.\nTest the given flag.\nUnit stored as array of instructions.\nUnit stored as byte code, which is a more compact …\nDefault storage implementation to use.\nInstructions from a single source file.\nInstructions and debug info from a single source file.\nBuilder trait for unit storage.\nInstruction storage used by a <code>Unit</code>.\nAccess debug information for the given location if it is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a new unit from a pair of data and debug info.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccess unit data.\nError raised when constructing a source.\nA single source file.\nReturns the argument unchanged.\nRead and load a source from the given filesystem path.\nCalls <code>U::from(self)</code>.\nConstruct a new anonymously named <code>&lt;memory&gt;</code> source.\nGet the name of the source.\nConstruct a new source with the given name.\nGet the path associated with the source.\nConvert the given offset to a utf-16 line and character.\nConstruct a new source with the given content and path.\nTry very hard to emit colors. This includes emitting ANSI …\nAlwaysAnsi is like Always, except it never tries to use …\nSatisfies <code>WriteColor</code> using standard ANSI escape sequences.\nTry to use colors, but don’t force the issue. If the …\nWrite colored text to memory.\nWrites colored buffers to stdout or stderr.\nLike <code>StandardStream</code>, but does buffered writing.\nThe set of available colors for the terminal …\nColorChoice represents the color preferences of an end …\nAn error that occurs when parsing a <code>ColorChoice</code> fails.\nA color specification.\nA hyperlink specification.\nNever emit colors.\nSatisfies <code>WriteColor</code> but ignores all color options.\nAn error from parsing an invalid color specification.\nSatisfies <code>io::Write</code> and <code>WriteColor</code>, and supports optional …\n<code>StandardStreamLock</code> is a locked reference to a …\nThis trait describes the behavior of writers that support …\nCreate a buffer that uses ANSI escape sequences.\nReturn the underlying data of the buffer as a mutable …\nReturn the underlying data of the buffer.\nGet the background color.\nGet whether this is bold or not.\nCreates a new <code>Buffer</code> with the current color preferences.\nClears this buffer.\nClears this color specification so that it has no …\nCreates a hyperlink specification representing no …\nGet whether this is dimmed or not.\nGet the foreground color.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn a mutable reference to the inner writer.\nReturn a mutable reference to the inner writer.\nReturn a reference to the inner writer.\nReturn a reference to the inner writer.\nGet whether this is intense or not.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume this buffer and return the underlying raw data.\nConsume this <code>NoColor</code> value and return the inner writer.\nConsume this <code>Ansi</code> value and return the inner writer.\nReturn the string that couldn’t be parsed as a valid …\nReturns true if and only if this buffer is empty.\nReturns true if this color specification has no colors or …\nReturns true if and only if the underlying writer must …\nGet whether this is italic or not.\nReturns the length of this buffer in bytes.\nLock the underlying writer.\nCreate a new writer that satisfies <code>WriteColor</code> but drops …\nCreate a new writer that satisfies <code>WriteColor</code> using …\nCreate a new color specification that has no colors or …\nCreate a buffer that drops all color information.\nCreates a new hyperlink specification.\nPrints the contents of the given buffer.\nReset the current color settings to their original …\nGet whether reset is enabled or not.\nIf set, the separator given is printed between buffers. By …\nSet the background color.\nSet whether the text is bolded or not.\nSet the color settings of the writer.\nSet whether the text is dimmed or not.\nSet the foreground color.\nSet the current hyperlink of the writer.\nSet whether the text is intense or not.\nSet whether the text is italicized or not.\nSet whether to reset the terminal whenever color settings …\nSet whether the text is strikethrough or not.\nSet whether the text is underlined or not.\nCreate a new <code>StandardStream</code> with the given color …\nCreate a new <code>BufferedStandardStream</code> with the given color …\nCreate a new <code>BufferWriter</code> that writes to stderr with the …\nCreate a new <code>StandardStream</code> with the given color …\nCreate a new <code>BufferedStandardStream</code> with the given color …\nCreate a new <code>BufferWriter</code> that writes to stdout with the …\nGet whether this is strikethrough or not.\nReturns true if and only if the underlying writer supports …\nReturns true if and only if the underlying writer supports …\nGet whether this is underline or not.\nReturns the URI of the hyperlink if one is attached to …\nLook for all things.\nAllocation Error.\nThe found entry is a benchmark.\nThe found entry is a binary.\nA prepared build.\nFailed to build workspace.\nCodespan reporting error.\nA single workspace diagnostic.\nDiagnostics emitted about a workspace.\nErrors that can be raised when formatting diagnostics.\nThe found entry is an example.\nAn error in a workspace.\nA fatal diagnostic in a workspace.\nA filesystem-based source loader.\nA found item in the workspace.\nThe kind of a found entry.\nA found item in the workspace associated with a package.\nSource Error.\nThe name of the toplevel manifest <code>Rune.toml</code>.\nThe manifest of a workspace.\nLook for one specific named thing.\nA single package.\nA source loader.\nThe found entry is a test.\nAn error raised when interacting with workspaces.\nA workspace filter which in combination with functions …\nAutomatically detect benches.\nAutomatically detect binaries.\nAutomatically detect examples.\nAutomatically detect tests.\nPerform the build.\nAccess underlying diagnostics.\nGenerate formatted diagnostics capable of referencing …\nAccess the underlying workspace error.\nFind every single entrypoint available.\nFind every single entrypoint available.\nFind all benches matching the given name in the workspace.\nFind all benches matching the given name in the workspace.\nFind all binaries matching the given name in the workspace.\nFind all binaries matching the given name in the workspace.\nFind all examples matching the given name in the workspace.\nFind all examples matching the given name in the workspace.\nFind all tests associated with the given base name.\nFind all tests associated with the given base name.\nA found path that can be built.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTest if diagnostics has errors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if diagnostics is empty.\nThe kind found.\nLoad the given path.\nConstruct a custom message as an error.\nName of the found thing.\nThe name of the package.\nConstruct an empty diagnostics container.\nConstruct a new filesystem-based source loader.\nIndex of the package build belongs to.\nList of packages found.\nA found path that can be built.\nPrepare a workspace build.\nThe root of the package.\nGet source id of the diagnostic.\nThe version of the package..\nAssociate a specific diagnostic with the build.\nAssociate a specific source loader with the build.")