<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Deriving `Encode` and `Decode`."><title>musli::help::derives - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-d10b2a06af903387.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="musli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (e57f3090a 2024-08-05)" data-channel="nightly" data-search-js="search-ef54e092fea9c776.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-9345f17bf569ecba.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../musli/index.html">musli</a><span class="version">0.0.121</span></h2></div><h2 class="location"><a href="#">Module derives</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In musli::<wbr>help</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">musli</a>::<wbr><a href="../index.html">help</a>::<wbr><a class="mod" href="#">derives</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/musli/help/derives.rs.html#1-1052">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Deriving <a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a>.</p>
<p>The <a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a> derives allows for automatically implementing
<a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a>.</p>
<p>They come with a number of options for customizing their implementation,
detailed below. But first we need to talk about <em>modes</em>.</p>
 <br>
<h5 id="modes"><a class="doc-anchor" href="#modes">§</a>Modes</h5>
<p>If you’ve paid close attention to the <a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a> traits you
might notive that they have an extra parameter called <code>M</code>. This stands for
“mode”.</p>
<p>This parameter allows us to have different implementations of these traits
for the same type.</p>
<p>By default we implements two modes, which each have subtly different default
behaviors:</p>
<ul>
<li><a href="../../mode/enum.Binary.html" title="enum musli::mode::Binary"><code>Binary</code></a> - which uses indexed fields, the equivalent of
<code>#[musli(name_type = usize)]</code>.</li>
<li><a href="../../mode/enum.Text.html" title="enum musli::mode::Text"><code>Text</code></a> - which uses literally text fields by their name, the equivalent
of <code>#[musli(name_type = str)]</code>.</li>
</ul>
<p>When it comes to deriving these traits you can scope attributes to apply to
any mode including custom local ones. This is done using the <code>#[musli(mode =  ..)]</code> meta attribute like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};
<span class="kw">use </span>musli::mode::Binary;
<span class="kw">use </span>musli::json::Encoding;

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person&lt;<span class="lifetime">'a</span>&gt; {
    <span class="attr">#[musli(mode = Text, name = <span class="string">"name"</span>)]
    </span>not_name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    age: u32,
}

<span class="kw">const </span>TEXT: Encoding = Encoding::new();
<span class="kw">const </span>BINARY: Encoding&lt;Binary&gt; = Encoding::new().with_mode();

<span class="kw">let </span>named = TEXT.to_vec(<span class="kw-2">&amp;</span>Person { not_name: <span class="string">"Aristotle"</span>, age: <span class="number">62 </span>})<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(named.as_slice(), <span class="string">br#"{"name":"Aristotle","age":62}"#</span>);

<span class="kw">let </span>indexed = BINARY.to_vec(<span class="kw-2">&amp;</span>Person { not_name: <span class="string">"Plato"</span>, age: <span class="number">84 </span>})<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(indexed.as_slice(), <span class="string">br#"{"0":"Plato","1":84}"#</span>);</code></pre></div>
<p>So the <code>#[musli(mode)]</code> atttribute is supported in any position. And any of
its sibling attributes will be added to the given <em>alternative</em> mode, rather
the <a href="../../mode/enum.Binary.html" title="enum musli::mode::Binary">default mode</a>.</p>
 <br>
<h5 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h5>
<ul>
<li>
<p><a href="#meta-attributes"><em>Meta attributes</em></a> which apply to the attribute itself.
It is used to filter what scope the current attribute applies to, such as
only applying to an <code>Encode</code> derive using <code>#[musli(encode_only, ..)]</code> or a
specific mode such as <code>#[musli(mode = Json, ..)]</code>.</p>
</li>
<li>
<p><a href="#container-attributes"><em>Container attributes</em></a> are attributes which apply
to the <code>struct</code> or <code>enum</code>.</p>
</li>
<li>
<p><a href="#variant-attributes"><em>Variant attributes</em></a> are attributes which apply to
each individual variant in an <code>enum</code>.</p>
</li>
<li>
<p><a href="#field-attributes"><em>Field attributes</em></a> are attributes which apply to each
individual field either in a <code>struct</code> or an <code>enum</code> variant.</p>
</li>
</ul>
 <br>
<h3 id="meta-attributes"><a class="doc-anchor" href="#meta-attributes">§</a>Meta attributes</h3>
<p>Certain attributes affect which other attributes apply to a given context.
These are called <em>meta</em> attributes.</p>
<p>Meta attributes are applicable to any context, and can be used on
containers, variants, and fields.</p>
 <br>
<h5 id="muslimode--path"><a class="doc-anchor" href="#muslimode--path">§</a><code>#[musli(mode = &lt;path&gt;)]</code></h5>
<p>The attributes only apply to the given <code>mode</code>.</p>
<p>The <code>Person</code> struct below uses string field names by default when the <code>Text</code>
mode is enabled, but we can change this behavior only for that particular
mode like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};
<span class="kw">use </span>musli::mode::Text;

<span class="attr">#[derive(Encode, Decode)]
#[musli(mode = Text, name_type = usize)]
</span><span class="kw">struct </span>Person&lt;<span class="lifetime">'a</span>&gt; {
    name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    age: u32,
}</code></pre></div>
 <br>
<h5 id="musliencode_only"><a class="doc-anchor" href="#musliencode_only">§</a><code>#[musli(encode_only)]</code></h5>
<p>The attributes only apply when implementing the <code>Encode</code> trait.</p>
<p>An example where this is useful is if you want to apply <code>#[musli(packed)]</code>
in a different mode, but only for encoding, since decoding packed types is
not supported for enums.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::mode::Binary;
<span class="kw">use </span>musli::{Decode, Encode};

<span class="kw">enum </span>Packed {}

<span class="attr">#[derive(Encode, Decode)]
#[musli(mode = Packed, encode_only, packed)]
</span><span class="kw">enum </span>Name&lt;<span class="lifetime">'a</span>&gt; {
    Full(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>str),
    Given(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>str),
}</code></pre></div>
 <br>
<h5 id="muslidecode_only"><a class="doc-anchor" href="#muslidecode_only">§</a><code>#[musli(decode_only)]</code></h5>
<p>The attributes only apply when implementing the <code>Decode</code> trait.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>)]
</span><span class="kw">struct </span>Name&lt;<span class="lifetime">'a</span>&gt; {
    sur_name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    <span class="attr">#[musli(decode_only, name = <span class="string">"last"</span>)]
    </span>last_name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
}</code></pre></div>
 <br>
<h3 id="container-attributes"><a class="doc-anchor" href="#container-attributes">§</a>Container attributes</h3>
<p>Container attributes apply to the container, such as directly on the
<code>struct</code> or <code>enum</code>. Like the uses of <code>#[musli(packed)]</code> and
<code>#[musli(name_all = "name")]</code> here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    <span class="comment">/* the body of the struct */
</span>}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>)]
</span><span class="kw">enum </span>Enum {
    <span class="comment">/* the body of the enum */
</span>}</code></pre></div>
 <br>
<h5 id="musliname_all--"><a class="doc-anchor" href="#musliname_all--">§</a><code>#[musli(name_all = "..")]</code></h5>
<p>Allos for renaming every field in the container. It can take any of the
following values:</p>
<ul>
<li><code>index</code> (default) - the index of the field will be used.</li>
<li><code>name</code> - the literal name of the field will be used.</li>
<li><code>PascalCase</code> - the field will be converted to pascal case.</li>
<li><code>camelCase</code> - the field will be converted to camel case.</li>
<li><code>snake_case</code> - the field will be converted to snake case.</li>
<li><code>SCREAMING_SNAKE_CASE</code> - the field will be converted to screaming snake case.</li>
<li><code>kebab-case</code> - the field will be converted to kebab case.</li>
<li><code>SCREAMING-KEBAB-CASE</code> - the field will be converted to screaming kebab case.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"PascalCase"</span>)]
</span><span class="kw">struct </span>PascalCaseStruct {
    field_name: u32,
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>)]
</span><span class="kw">struct </span>NamedStruct {
    field1: u32,
    field2: u32,
}</code></pre></div>
<p>If applied to an enum, it will instead rename all variants:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"PascalCase"</span>)]
</span><span class="kw">enum </span>PascalCaseEnum {
    VariantName {
        field_name: u32,
    }
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>)]
</span><span class="kw">enum </span>NamedEnum {
    Variant1 {
        field1: u32,
    },
    Variant2 {
        field1: u32,
    },
}</code></pre></div>
 <br>
<h5 id="muslitransparent"><a class="doc-anchor" href="#muslitransparent">§</a><code>#[musli(transparent)]</code></h5>
<p>This can only be used on types which have a single field. It will cause that
field to define how that variant is encoded or decoded transparently without
being treated as a field.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode)]
#[musli(transparent)]
</span><span class="kw">struct </span>Struct(u32);

<span class="kw">let </span>data = musli::wire::to_vec(<span class="kw-2">&amp;</span>Struct(<span class="number">42</span>))<span class="question-mark">?</span>;
<span class="kw">let </span>actual: u32 = musli::wire::from_slice(<span class="kw-2">&amp;</span>data)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(actual, <span class="number">42u32</span>);</code></pre></div>
 <br>
<h5 id="muslipacked"><a class="doc-anchor" href="#muslipacked">§</a><code>#[musli(packed)]</code></h5>
<p>This attribute will disable all <em>tagging</em> and the structure will simply be
encoded with one field following another in the order in which they are
defined.</p>
<p>A caveat of <em>packed</em> structures is that they cannot be safely versioned and
the two systems communicating through them need to be using strictly
synchronized representations.</p>
<p>This attribute is useful for performing simple decoding over “raw” bytes
when combined with an encoder which does minimal prefixing and packs fields.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    field1: u32,
    field2: u32,
    field3: u32,
}

<span class="kw">let </span>data = musli::storage::to_vec(<span class="kw-2">&amp;</span>Struct {
    field1: <span class="number">1</span>,
    field2: <span class="number">2</span>,
    field3: <span class="number">3</span>,
})<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(data.as_slice(), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre></div>
 <br>
<h5 id="musliname_type--"><a class="doc-anchor" href="#musliname_type--">§</a><code>#[musli(name_type = ..)]</code></h5>
<p>This indicates which type any contained <code>#[musli(name = ..)]</code> attributes
should have. Tags can usually be inferred, but specifying this field ensures
that all tags have a single well-defined type.</p>
<p>The following values are treated specially:</p>
<ul>
<li><code>str</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
<li><code>[u8]</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::fmt;

<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Eq, Encode, Decode)]
#[musli(transparent)]
</span><span class="kw">struct </span>CustomTag&lt;<span class="lifetime">'a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>[u8]);

<span class="kw">impl </span>fmt::Display <span class="kw">for </span>CustomTag&lt;<span class="lifetime">'_</span>&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; fmt::Result {
        fmt::Debug::fmt(<span class="self">self</span>.<span class="number">0</span>, f)
    }
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_type = CustomTag)]
</span><span class="kw">struct </span>Struct {
    <span class="attr">#[musli(name = CustomTag(<span class="string">b"name in bytes"</span>))]
    </span>name: String,
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_type = CustomTag)]
</span><span class="kw">enum </span>EnumWithCustomTag {
    <span class="attr">#[musli(name = CustomTag(<span class="string">b"variant one"</span>))]
    </span>Variant1 {
        <span class="comment">/* .. */
    </span>},
}</code></pre></div>
 <br>
<h5 id="musliname_method--"><a class="doc-anchor" href="#musliname_method--">§</a><code>#[musli(name_method = ..)]</code></h5>
<p>This allows for explicitly setting which method should be used to decode
names. Available options are:</p>
<ul>
<li><code>"value"</code> (default) - the name is decoded as a value.</li>
<li><code>"unsized"</code> - the name is decoded as an unsized value, this is the default
if for example <code>#[musli(name_type = str)]</code> is used.</li>
<li><code>"unsized_bytes"</code> - the name is decoded as a unsized bytes, this is the
default if for example <code>#[musli(name_type = [u8])]</code> is used.</li>
</ul>
<p>This can be overrided for values which are unsized, but cannot be determined
through heuristics. Such a type must also implement <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a> (for
<code>"value"</code>), <code>DecodeUnsized</code>, or <code>DecodeUnsizedBytes</code> as appropriate.</p>
 <br>
<h5 id="muslibound---and-muslidecode_bound--"><a class="doc-anchor" href="#muslibound---and-muslidecode_bound--">§</a><code>#[musli(bound = {..})]</code> and <code>#[musli(decode_bound = {..})]</code></h5>
<p>These attributes can be used to apply bounds to an <a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> or <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a>
implementation.</p>
<p>These are necessary to use when a generic container is used to ensure that
the given parameter implements the necessary bounds.</p>
<p><code>#[musli(bound = {..})]</code> applies to all implementations while
<code>#[musli(decode_bound = {..})]</code> only applies to the <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a>
implementation. The latter allows for using the decode lifetime parameter
(which defaults to <code>'de</code>).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Decode, Encode};
<span class="kw">use </span>musli::mode::{Binary, Text};

<span class="attr">#[derive(Clone, Debug, PartialEq, Encode, Decode)]
#[musli(mode = Binary, bound = {T: Encode&lt;Binary&gt;}, decode_bound = {T: Decode&lt;<span class="lifetime">'de</span>, Binary&gt;})]
#[musli(mode = Text, bound = {T: Encode&lt;Text&gt;}, decode_bound = {T: Decode&lt;<span class="lifetime">'de</span>, Text&gt;})]
</span><span class="kw">pub struct </span>GenericWithBound&lt;T&gt; {
    value: T,
}</code></pre></div>
 <br>
<h3 id="enum-attributes"><a class="doc-anchor" href="#enum-attributes">§</a>Enum attributes</h3> <br>
<h5 id="muslitag--"><a class="doc-anchor" href="#muslitag--">§</a><code>#[musli(tag = ..)]</code></h5>
<p>This attribute causes the enum to be internally tagged, with the given tag.
See <a href="#enum-representations">enum representations</a> for details on this
representation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>, tag = <span class="string">"type"</span>)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}</code></pre></div>
 <br>
<h3 id="variant-attributes"><a class="doc-anchor" href="#variant-attributes">§</a>Variant attributes</h3>
<p><em>Variant attributes</em> are attributes which apply to each individual variant
in an <code>enum</code>. Like the use of <code>#[musli(name = ..)]</code> here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>)]
</span><span class="kw">enum </span>Enum {
    Variant {
        <span class="comment">/* variant body */
    </span>},
    <span class="attr">#[musli(name = <span class="string">"Other"</span>)]
    </span>Something {
        <span class="comment">/* variant body */
    </span>},
}</code></pre></div>
 <br>
<h5 id="musliname--"><a class="doc-anchor" href="#musliname--">§</a><code>#[musli(name = ..)]</code></h5>
<p>This allows for renaming a variant from its default value. It can take any
value (including complex ones) that can be serialized with the current
encoding, such as:</p>
<ul>
<li><code>#[musli(name = 1)]</code></li>
<li><code>#[musli(name = "Hello World")]</code></li>
<li><code>#[musli(name = b"box\0")]</code></li>
<li><code>#[musli(name = SomeStruct { field: 42 })]</code> (if <code>SomeStruct</code> implements
<a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a> as appropriate).</li>
</ul>
<p>If the type of the tag is ambiguous it can be explicitly specified through
the <code>#[musli(name_type)]</code> attribute.</p>
 <br>
<h5 id="muslipattern--"><a class="doc-anchor" href="#muslipattern--">§</a><code>#[musli(pattern = ..)]</code></h5>
<p>A pattern to match for decoding a variant.</p>
<p>This allows for more flexibility when decoding variants.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>Enum {
    Variant1,
    Variant2,
    <span class="attr">#[musli(mode = Binary, pattern = <span class="number">2</span>..=<span class="number">4</span>)]
    </span>Deprecated,
}</code></pre></div>
 <br>
<h5 id="musliname_all---1"><a class="doc-anchor" href="#musliname_all---1">§</a><code>#[musli(name_all = "..")]</code></h5>
<p>Allos for renaming every field in the variant. It can take any of the
following values:</p>
<ul>
<li><code>index</code> (default) - the index of the field will be used.</li>
<li><code>name</code> - the literal name of the field will be used.</li>
<li><code>PascalCase</code> - the field will be converted to pascal case.</li>
<li><code>camelCase</code> - the field will be converted to camel case.</li>
<li><code>snake_case</code> - the field will be converted to snake case.</li>
<li><code>SCREAMING_SNAKE_CASE</code> - the field will be converted to screaming snake case.</li>
<li><code>kebab-case</code> - the field will be converted to kebab case.</li>
<li><code>SCREAMING-KEBAB-CASE</code> - the field will be converted to screaming kebab case.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>PascalCaseEnum {
    <span class="attr">#[musli(name_all = <span class="string">"PascalCase"</span>)]
    </span>Variant {
        field_name: u32,
    }
}

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>NamedEnum {
    <span class="attr">#[musli(name_all = <span class="string">"name"</span>)]
    </span>Variant {
        field1: u32,
    },
    Variant2 {
        field1: u32,
    },
}</code></pre></div>
 <br>
<h5 id="musliname_type---1"><a class="doc-anchor" href="#musliname_type---1">§</a><code>#[musli(name_type = ..)]</code></h5>
<p>This indicates which type any contained <code>#[musli(tag = ..)]</code> attributes
should have. Tags can usually be inferred, but specifying this field ensures
that all tags have a well-defined type.</p>
<p>The following values are treated specially:</p>
<ul>
<li><code>str</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
<li><code>[u8]</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::fmt;

<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Eq, Encode, Decode)]
#[musli(transparent)]
</span><span class="kw">struct </span>CustomTag&lt;<span class="lifetime">'a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>[u8]);

<span class="kw">impl </span>fmt::Display <span class="kw">for </span>CustomTag&lt;<span class="lifetime">'_</span>&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; fmt::Result {
        fmt::Debug::fmt(<span class="self">self</span>.<span class="number">0</span>, f)
    }
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_type = usize)]
</span><span class="kw">enum </span>Enum {
    <span class="attr">#[musli(name = <span class="number">0usize</span>, name_type = CustomTag)]
    </span>Variant {
        <span class="attr">#[musli(name = CustomTag(<span class="string">b"field1"</span>))]
        </span>field1: u32,
        <span class="attr">#[musli(name = CustomTag(<span class="string">b"field2"</span>))]
        </span>field2: u32,
    },
    <span class="attr">#[musli(name = <span class="number">1usize</span>, name_all = <span class="string">"name"</span>)]
    </span>Variant2 {
        <span class="attr">#[musli(name = <span class="string">"field1"</span>)]
        </span>field1: u32,
        <span class="attr">#[musli(name = <span class="string">"field2"</span>)]
        </span>field2: u32,
    },
}</code></pre></div>
 <br>
<h5 id="musliname_method---1"><a class="doc-anchor" href="#musliname_method---1">§</a><code>#[musli(name_method = ..)]</code></h5>
<p>This allows for explicitly setting which method should be used to decode
field names. Available options are:</p>
<ul>
<li><code>"value"</code> (default) - the name is decoded as a value.</li>
<li><code>"unsized"</code> - the name is decoded as an unsized value, this is the default
if for example <code>#[musli(name_type = str)]</code> is used.</li>
<li><code>"unsized_bytes"</code> - the name is decoded as a unsized bytes, this is the
default if for example <code>#[musli(name_type = [u8])]</code> is used.</li>
</ul>
<p>This can be overrided for values which are unsized, but cannot be determined
through heuristics. Such a type must also implement <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a> (for
<code>"value"</code>), <code>DecodeUnsized</code>, or <code>DecodeUnsizedBytes</code> as appropriate.</p>
 <br>
<h5 id="muslitransparent-1"><a class="doc-anchor" href="#muslitransparent-1">§</a><code>#[musli(transparent)]</code></h5>
<p>This can only be used on variants which have a single field. It will cause
that field to define how that variant is encoded or decoded transparently
without being treated as a field.</p>
 <br>
<h5 id="muslidefault"><a class="doc-anchor" href="#muslidefault">§</a><code>#[musli(default)]</code></h5>
<p>This defines the variant that will be used in case no other variant matches.
Only one such variant can be defined.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Eq, Encode, Decode)]
#[musli(name_all = <span class="string">"kebab-case"</span>)]
</span><span class="kw">enum </span>Animal {
    Cat,
    Dog,
    <span class="attr">#[musli(default)]
    </span>Unknown,
}</code></pre></div>
 <br>
<h3 id="field-attributes"><a class="doc-anchor" href="#field-attributes">§</a>Field attributes</h3>
<p><em>Field attributes</em> are attributes which apply to each individual field
either in a <code>struct</code> or an <code>enum</code> variant. Like the uses of <code>#[musli(all)]</code>
here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>)]
</span><span class="kw">struct </span>Struct {
    <span class="attr">#[musli(name = <span class="string">"other"</span>)]
    </span>something: String,
    <span class="attr">#[musli(skip, default = default_field)]
    </span>skipped_field: u32,
}

<span class="kw">fn </span>default_field() -&gt; u32 {
    <span class="number">42
</span>}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>)]
</span><span class="kw">enum </span>Enum {
    <span class="attr">#[musli(name_all = <span class="string">"name"</span>)]
    </span>Variant {
        <span class="attr">#[musli(name = <span class="string">"other"</span>)]
        </span>something: String,
    }
}</code></pre></div>
 <br>
<h5 id="musliskip"><a class="doc-anchor" href="#musliskip">§</a><code>#[musli(skip)]</code></h5>
<p>This attribute means that the entire field is skipped. If a field is decoded
it uses <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" title="associated function core::default::Default::default"><code>Default::default</code></a> to construct the value. Other defaults can be
specified with [<code>#[musli(default = &lt;path&gt;)]</code>][#muslidefault–path].</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person {
    name: String,
    <span class="attr">#[musli(skip)]
    </span>age: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="attr">#[musli(skip, default = default_country)]
    </span>country: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>default_country() -&gt; <span class="prelude-ty">Option</span>&lt;String&gt; {
    <span class="prelude-val">Some</span>(String::from(<span class="string">"Earth"</span>))
}</code></pre></div>
 <br>
<h5 id="muslidefault--path"><a class="doc-anchor" href="#muslidefault--path">§</a><code>#[musli(default [= &lt;path&gt;])]</code></h5>
<p>When a field is absent or disabled with <code>#[musli(skip)]</code>, this attribute
specifies that a default value should be used instead.</p>
<p>If <code>#[musli(default)]</code> is specified, the default value is constructed using
<a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" title="associated function core::default::Default::default"><code>Default::default</code></a>.</p>
<p>If <code>#[musli(default = &lt;path&gt;)]</code> is specified, the default value is
constructed by calling the function at <code>&lt;path&gt;</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person {
    name: String,
    <span class="attr">#[musli(default)]
    </span>age: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="attr">#[musli(default = default_height)]
    </span>height: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="attr">#[musli(skip, default = default_meaning)]
    </span>meaning: u32,
}

<span class="kw">fn </span>default_height() -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    <span class="prelude-val">Some</span>(<span class="number">180</span>)
}

<span class="kw">fn </span>default_meaning() -&gt; u32 {
    <span class="number">42
</span>}</code></pre></div>
 <br>
<h5 id="musliname---1"><a class="doc-anchor" href="#musliname---1">§</a><code>#[musli(name = ..)]</code></h5>
<p>This allows for renaming a field from its default value. It can take any
value (including complex ones) that can be serialized with the current
encoding, such as:</p>
<ul>
<li><code>#[musli(name = 1)]</code></li>
<li><code>#[musli(name = "Hello World")]</code></li>
<li><code>#[musli(name = b"box\0")]</code></li>
<li><code>#[musli(name = SomeStruct { field: 42 })]</code> (if <code>SomeStruct</code> implements
<a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a> as appropriate).</li>
</ul>
<p>If the type of the tag is ambiguous it can be explicitly specified through
the <code>#[musli(name_type)]</code> variant or container attributes.</p>
 <br>
<h5 id="muslipattern---1"><a class="doc-anchor" href="#muslipattern---1">§</a><code>#[musli(pattern = ..)]</code></h5>
<p>A pattern to match for decoding the given field.</p>
<p>This allows for more flexibility when decoding fields.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Struct {
    field1: u32,
    field2: u32,
    <span class="attr">#[musli(mode = Binary, pattern = <span class="number">2</span>..=<span class="number">4</span>)]
    </span>other: u32,
}</code></pre></div>
 <br>
<h5 id="muslipacked-1"><a class="doc-anchor" href="#muslipacked-1">§</a><code>#[musli(packed)]</code></h5>
<p>This specifies that encoding and decoding should happen through the
<a href="../../en/trait.EncodePacked.html" title="trait musli::en::EncodePacked"><code>EncodePacked</code></a> and <a href="../../de/trait.DecodePacked.html" title="trait musli::de::DecodePacked"><code>DecodePacked</code></a> traits, instead of the default
<a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a>.</p>
<p>These traits contained implementations which are biased towards encoding the
field as a compact, non-future compatible pack. In essense, the fields are
encoded “one after another” without any metadata separating them. So for
packed fields, the order, types and number of the fields are important.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::VecDeque;

<span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Decode, Encode)]
</span><span class="kw">struct </span>Container {
    <span class="attr">#[musli(packed)]
    </span>tuple: (u32, u64),
    <span class="attr">#[musli(packed)]
    </span>array: [u32; <span class="number">4</span>],
}</code></pre></div>
 <br>
<h5 id="muslibytes"><a class="doc-anchor" href="#muslibytes">§</a><code>#[musli(bytes)]</code></h5>
<p>This specifies that encoding and decoding should happen through the
<a href="../../en/trait.EncodeBytes.html" title="trait musli::en::EncodeBytes"><code>EncodeBytes</code></a> and <a href="../../de/trait.DecodeBytes.html" title="trait musli::de::DecodeBytes"><code>DecodeBytes</code></a> traits, instead of the default
<a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> and <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a>.</p>
<p>These traits contained implementations which are biased towards encoding the
field as an array of bytes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::VecDeque;

<span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Decode, Encode)]
</span><span class="kw">struct </span>Container&lt;<span class="lifetime">'de</span>&gt; {
    <span class="attr">#[musli(bytes)]
    </span>vec: Vec&lt;u8&gt;,
    <span class="attr">#[musli(bytes)]
    </span>vec_deque: VecDeque&lt;u8&gt;,
    <span class="attr">#[musli(bytes)]
    </span>bytes: <span class="kw-2">&amp;</span><span class="lifetime">'de </span>[u8],
}</code></pre></div>
 <br>
<h5 id="musliwith--path"><a class="doc-anchor" href="#musliwith--path">§</a><code>#[musli(with = &lt;path&gt;)]</code></h5>
<p>This specifies the path to a module to use instead of the fields default
<a href="../../trait.Encode.html" title="trait musli::Encode"><code>Encode</code></a> or <a href="../../trait.Decode.html" title="trait musli::Decode"><code>Decode</code></a> implementations.</p>
<p>It expects <code>encode</code> and <code>decode</code> and decodee function to be defined in the path being specified, like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Decode, Encode)]
</span><span class="kw">struct </span>Container {
    <span class="attr">#[musli(with = <span class="self">self</span>::module)]
    </span>field: Field,
}

<span class="kw">struct </span>Field {
    <span class="comment">/* internal */
</span>}

<span class="kw">mod </span>module {
    <span class="kw">use </span>musli::{Decoder, Encoder};

    <span class="kw">use </span><span class="kw">super</span>::Field;

    <span class="kw">pub fn </span>encode&lt;E&gt;(field: <span class="kw-2">&amp;</span>Field, cx: <span class="kw-2">&amp;</span>E::Cx, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;E::Ok, E::Error&gt;
    <span class="kw">where
        </span>E: Encoder,

    <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D&gt;(cx: <span class="kw-2">&amp;</span>D::Cx, decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;Field, D::Error&gt;
    <span class="kw">where
        </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
}</code></pre></div>
<p>This can also be generic such as:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Decode, Encode)]
</span><span class="kw">struct </span>Container {
    <span class="attr">#[musli(with = <span class="self">self</span>::module)]
    </span>field: Field&lt;u32&gt;,
}

<span class="kw">struct </span>Field&lt;T&gt; {
    <span class="comment">/* internal */
</span>}

<span class="kw">mod </span>module {
    <span class="kw">use </span>musli::{Decoder, Encoder};

    <span class="kw">use </span><span class="kw">super</span>::Field;

    <span class="kw">pub fn </span>encode&lt;E, T&gt;(field: <span class="kw-2">&amp;</span>Field&lt;T&gt;, cx: <span class="kw-2">&amp;</span>E::Cx, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;E::Ok, E::Error&gt;
    <span class="kw">where
        </span>E: Encoder,

    <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D, T&gt;(cx: <span class="kw-2">&amp;</span>D::Cx, decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;Field&lt;T&gt;, D::Error&gt;
    <span class="kw">where
        </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
}</code></pre></div>
<p>More complete example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::HashSet;
<span class="kw">use </span>musli::{Encode, Decode};

<span class="kw">pub struct </span>CustomUuid(u128);

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Struct {
    <span class="attr">#[musli(with = <span class="self">self</span>::custom_uuid)]
    </span>id: CustomUuid,
    <span class="attr">#[musli(with = <span class="self">self</span>::custom_set)]
    </span>numbers: HashSet&lt;u32&gt;,
}

<span class="kw">mod </span>custom_uuid {
    <span class="kw">use </span>musli::{Context, Decode, Decoder, Encode, Encoder};

    <span class="kw">use </span><span class="kw">super</span>::CustomUuid;

    <span class="kw">pub fn </span>encode&lt;E&gt;(uuid: <span class="kw-2">&amp;</span>CustomUuid, cx: <span class="kw-2">&amp;</span>E::Cx, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;E::Ok, E::Error&gt;
    <span class="kw">where
        </span>E: Encoder,
    {
        uuid.<span class="number">0</span>.encode(cx, encoder)
    }

    <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D&gt;(cx: <span class="kw-2">&amp;</span>D::Cx, decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;CustomUuid, D::Error&gt;
    <span class="kw">where
        </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
    {
        <span class="prelude-val">Ok</span>(CustomUuid(decoder.decode()<span class="question-mark">?</span>))
    }
}

<span class="kw">mod </span>custom_set {
    <span class="kw">use </span>std::collections::HashSet;
    <span class="kw">use </span>std::hash::Hash;

    <span class="kw">use </span>musli::{Context, Decode, Decoder, Encode, Encoder};

    <span class="kw">pub fn </span>encode&lt;E, T&gt;(set: <span class="kw-2">&amp;</span>HashSet&lt;T&gt;, cx: <span class="kw-2">&amp;</span>E::Cx, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;E::Ok, E::Error&gt;
    <span class="kw">where
        </span>E: Encoder,
        T: Encode&lt;E::Mode&gt; + Eq + Hash,
    {
        encoder.encode(set)
    }

    <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D, T&gt;(cx: <span class="kw-2">&amp;</span>D::Cx, decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;HashSet&lt;T&gt;, D::Error&gt;
    <span class="kw">where
        </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
        T: Decode&lt;<span class="lifetime">'de</span>, D::Mode&gt; + Eq + Hash,
    {
        decoder.decode()
    }
}</code></pre></div>
 <br>
<h5 id="musliskip_encoding_if--path"><a class="doc-anchor" href="#musliskip_encoding_if--path">§</a><code>#[musli(skip_encoding_if = &lt;path&gt;)]</code></h5>
<p>This adds a condition to skip encoding a field entirely if the condition is
true. This is very commonly used to skip over encoding <code>Option&lt;T&gt;</code> fields.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person {
    name: String,
    <span class="attr">#[musli(skip_encoding_if = Option::is_none)]
    </span>age: <span class="prelude-ty">Option</span>&lt;u32&gt;,
}</code></pre></div>
<h5 id="muslitrace"><a class="doc-anchor" href="#muslitrace">§</a><code>#[musli(trace)]</code></h5>
<p>This causes the field to use the <a href="../../de/trait.DecodeTrace.html" title="trait musli::de::DecodeTrace"><code>DecodeTrace</code></a> / <a href="../../en/trait.EncodeTrace.html" title="trait musli::en::EncodeTrace"><code>EncodeTrace</code></a> when
encoding the field. This is left optional for types where enabling tracing
for the field requires extra traits to be implemented, such as <code>HashMap&lt;K,  V&gt;</code> where we’d need <code>K</code> to implement <code>fmt::Display</code>.</p>
<p>Without using the <code>trace</code> attribute below, the keys in the <code>values</code> field
would not be instrumented, so with a decoding error you’d see this:</p>
<div class="example-wrap"><pre class="language-text"><code>.values: not numeric (at bytes 15-16)
</code></pre></div>
<p>Instead of this (where <code>#[musli(trace)]</code> is enabled):</p>
<div class="example-wrap"><pre class="language-text"><code>.values[Hello]: not numeric (at bytes 15-16)
</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::HashMap;

<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Collection {
    <span class="attr">#[musli(trace)]
    </span>values: HashMap&lt;String, u32&gt;,
}</code></pre></div>
 <br>
<h2 id="enum-representations"><a class="doc-anchor" href="#enum-representations">§</a>Enum representations</h2>
<p>Müsli supports the following enum representations, which mimics the ones
supported by <em>serde</em>:</p>
<ul>
<li>Externally tagged (<em>default</em>).</li>
<li>Internally tagged when <code>#[musli(tag = ..)]</code> is specified on the enum.</li>
<li>Adjacently tagged when both <code>#[musli(tag = ..)]</code> and <code>#[musli(content)]</code>
are specified.</li>
</ul>
 <br>
<h3 id="externally-tagged"><a class="doc-anchor" href="#externally-tagged">§</a>Externally tagged</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}</code></pre></div>
<p>When an enum is externally tagged it is represented by a single field
indicating the variant of the enum.</p>
<div class="example-wrap"><pre class="language-json"><code>{&quot;Request&quot;: {&quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}}
</code></pre></div>
<p>This is the most portable representation and is supported by most formats.
It has special support in the <a href="../../trait.Encoder.html" title="trait musli::Encoder"><code>Encoder</code></a> and <a href="../../trait.Decoder.html" title="trait musli::Decoder"><code>Decoder</code></a> traits through
<a href="../../trait.Encoder.html#method.encode_variant" title="method musli::Encoder::encode_variant"><code>Encoder::encode_variant</code></a> and <a href="../../trait.Decoder.html#method.decode_variant" title="method musli::Decoder::decode_variant"><code>Decoder::decode_variant</code></a>.</p>
<p>Conceptually this can be considered as a “pair”, where the variant tag can
be extracted from the format before the variant is decoded.</p>
 <br>
<h3 id="internally-tagged"><a class="doc-anchor" href="#internally-tagged">§</a>Internally tagged</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"name"</span>, tag = <span class="string">"type"</span>)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}</code></pre></div>
<p>In JSON, the <code>Message::Request</code> would be represented as:</p>
<div class="example-wrap"><pre class="language-json"><code>{&quot;type&quot;: &quot;Request&quot;, &quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}
</code></pre></div>
<p>This is only supported by formats which are <em>self descriptive</em>, which is a
requirement for the format to be buffered through <a href="../../trait.Decoder.html#method.decode_buffer" title="method musli::Decoder::decode_buffer"><code>Decoder::decode_buffer</code></a>.</p>
<p>It is necessary to buffer the value, since we need to inspect the fields of
a map for the field corresponding to the <code>tag</code>, and then use this to
determine which decoder implementation to call.</p>
</div></details></section></div></main></body></html>