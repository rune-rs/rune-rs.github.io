<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="  "><title>musli - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="musli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-nightly (878c8a2a6 2024-02-29)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../musli/index.html">musli</a><span class="version">0.0.42</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../musli/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">musli</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/musli/lib.rs.html#1-313">source</a> ¬∑ <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="https://github.com/udoprog/musli"><img alt="github" src="https://img.shields.io/badge/github-udoprog/musli-8da0cb?style=for-the-badge&logo=github" height="20"></a>
<a href="https://crates.io/crates/musli"><img alt="crates.io" src="https://img.shields.io/crates/v/musli.svg?style=for-the-badge&color=fc8d62&logo=rust" height="20"></a>
<a href="https://docs.rs/musli"><img alt="docs.rs" src="https://img.shields.io/badge/docs.rs-musli-66c2a5?style=for-the-badge&logoColor=white&logo=data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDUxMiA1MTIiPjxwYXRoIGZpbGw9IiNmNWY1ZjUiIGQ9Ik00ODguNiAyNTAuMkwzOTIgMjE0VjEwNS41YzAtMTUtOS4zLTI4LjQtMjMuNC0zMy43bC0xMDAtMzcuNWMtOC4xLTMuMS0xNy4xLTMuMS0yNS4zIDBsLTEwMCAzNy41Yy0xNC4xIDUuMy0yMy40IDE4LjctMjMuNCAzMy43VjIxNGwtOTYuNiAzNi4yQzkuMyAyNTUuNSAwIDI2OC45IDAgMjgzLjlWMzk0YzAgMTMuNiA3LjcgMjYuMSAxOS45IDMyLjJsMTAwIDUwYzEwLjEgNS4xIDIyLjEgNS4xIDMyLjIgMGwxMDMuOS01MiAxMDMuOSA1MmMxMC4xIDUuMSAyMi4xIDUuMSAzMi4yIDBsMTAwLTUwYzEyLjItNi4xIDE5LjktMTguNiAxOS45LTMyLjJWMjgzLjljMC0xNS05LjMtMjguNC0yMy40LTMzLjd6TTM1OCAyMTQuOGwtODUgMzEuOXYtNjguMmw4NS0zN3Y3My4zek0xNTQgMTA0LjFsMTAyLTM4LjIgMTAyIDM4LjJ2LjZsLTEwMiA0MS40LTEwMi00MS40di0uNnptODQgMjkxLjFsLTg1IDQyLjV2LTc5LjFsODUtMzguOHY3NS40em0wLTExMmwtMTAyIDQxLjQtMTAyLTQxLjR2LS42bDEwMi0zOC4yIDEwMiAzOC4ydi42em0yNDAgMTEybC04NSA0Mi41di03OS4xbDg1LTM4Ljh2NzUuNHptMC0xMTJsLTEwMiA0MS40LTEwMi00MS40di0uNmwxMDItMzguMiAxMDIgMzguMnYuNnoiPjwvcGF0aD48L3N2Zz4K" height="20"></a></p>
<p>M√ºsli is a flexible and generic binary serialization framework.</p>
<p>The central components of the framework are the <a href="https://docs.rs/musli/latest/musli/trait.Encode.html">Encode</a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html">Decode</a>
derives. They are thoroughly documented in the <a href="https://docs.rs/musli/latest/musli/derives/">derives</a> module.</p>
<p>I‚Äôve chosen to internally use the term ‚Äúencoding‚Äù, ‚Äúencode‚Äù, and ‚Äúdecode‚Äù
because it‚Äôs common terminology when talking about binary formats. It‚Äôs also
distinct from <a href="https://serde.rs">serde</a>‚Äôs use of ‚Äúserialization‚Äù allowing for the ease of
using both libraries side by side if desired.</p>
<br>
<h3 id="design"><a class="doc-anchor" href="#design">¬ß</a>Design</h3>
<p>M√ºsli is designed with similar principles as <a href="https://serde.rs">serde</a>. Relying on Rust‚Äôs
powerful trait system to generate code which can largely be optimized away.
The end result should be very similar to a handwritten encoding.</p>
<p>The heavy lifting in user code is done through the <a href="https://docs.rs/musli/latest/musli/trait.Encode.html">Encode</a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html">Decode</a>
derives. They are both documented in the <a href="https://docs.rs/musli/latest/musli/derives/">derives</a> module.</p>
<p>Where M√ºsli differs in approach is that we don‚Äôt make as heavy use of the
visitor pattern. Instead the encoding interacts with the framework through
encoding interfaces that describe ‚Äúwhat it wants‚Äù and leverages GATs to make
the API efficient and ergonomic.</p>
<p>Another major aspect where M√ºsli differs is in the conept of
<a href="#modes">modes</a>. This is a larger topic and is covered further down.</p>
<br>
<h3 id="usage"><a class="doc-anchor" href="#usage">¬ß</a>Usage</h3>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>musli = &quot;0.0.42&quot;
musli-wire = &quot;0.0.42&quot;
</code></pre></div><br>
<h3 id="formats"><a class="doc-anchor" href="#formats">¬ß</a>Formats</h3>
<p>Formats are currently distinguished by supporting various degrees of
<em>upgrade stability</em>. A fully upgrade stable encoding format must tolerate
that one model can add fields that an older version of the model should be
capable of ignoring.</p>
<p>Partial upgrade stability can still be useful as is the case of the
<em>musli-storage</em> format below, because reading from storage only requires
decoding to be upgrade stable. So if correctly managed with
<code>#[musli(default)]</code> this will never result in any readers seeing unknown
fields.</p>
<p>The available formats and their capabilities are:</p>
<div><table><thead><tr><th></th><th>reorder?</th><th>missing?</th><th>unknown?</th><th>self?</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/musli-storage">musli-storage</a> <code>#[musli(packed)]</code></td><td>‚úó</td><td>‚úó</td><td>‚úó</td><td>‚úó</td></tr>
<tr><td><a href="https://docs.rs/musli-storage">musli-storage</a></td><td>‚úî</td><td>‚úî</td><td>‚úó</td><td>‚úó</td></tr>
<tr><td><a href="https://docs.rs/musli-wire">musli-wire</a></td><td>‚úî</td><td>‚úî</td><td>‚úî</td><td>‚úó</td></tr>
<tr><td><a href="https://docs.rs/musli-descriptive">musli-descriptive</a></td><td>‚úî</td><td>‚úî</td><td>‚úî</td><td>‚úî</td></tr>
</tbody></table>
</div>
<p><code>reorder?</code> determines whether fields must occur in exactly the order in
which they are specified. So reordering fields in such a struct would cause
either an error or some kind of undefined behavior. This is only suitable
for byte-oriented IPC where data models are strictly synchronized.</p>
<p><code>missing?</code> determines if reading can handle missing fields, as exemplified
above. This is suitable for on-disk storage.</p>
<p><code>unknown?</code> determines if the format can skip over unknown fields. This is
suitable for network communication. At this point you‚Äôve reached <em>upgrade
stability</em>. Some level of introspection is possible on this level, because
it must contain enough information about fields to know what to skip which
usually allows for reasoning about basic types.</p>
<p><code>self?</code> determines if the format is self-descriptive. Allowing field names
and variants to be fully reconstructed from the serialized data. These
formats do not require models to decode, and can make use of generic
containers such as <a href="https://docs.rs/musli-value">musli-value</a>.</p>
<p>For every feature you drop, the format becomes more compact and efficient.
<code>musli-storage</code> <code>#[musli(packed)]</code> for example is roughly as compact and
efficient as <a href="https://docs.rs/bincode">bincode</a> while <a href="https://docs.rs/musli-wire">musli-wire</a> is comparable to something like
<a href="https://developers.google.com/protocol-buffers">protobuf</a>*.</p>
<br>
<h3 id="examples"><a class="doc-anchor" href="#examples">¬ß</a>Examples</h3>
<p>The following is an example of <em>full upgrade stability</em> using <a href="https://docs.rs/musli-wire">musli-wire</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Encode, Decode)]
</span><span class="kw">struct </span>Version1 {
    name: String,
}

<span class="attr">#[derive(Debug, PartialEq, Encode, Decode)]
</span><span class="kw">struct </span>Version2 {
    name: String,
    <span class="attr">#[musli(default)]
    </span>age: <span class="prelude-ty">Option</span>&lt;u32&gt;,
}

<span class="kw">let </span>version2 = musli_wire::to_buffer(<span class="kw-2">&amp;</span>Version2 {
    name: String::from(<span class="string">"Aristotle"</span>),
    age: <span class="prelude-val">Some</span>(<span class="number">62</span>),
})<span class="question-mark">?</span>;

<span class="kw">let </span>version1: Version1 = musli_wire::decode(version2.as_slice())<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(version1, Version1 {
    name: String::from(<span class="string">"Aristotle"</span>),
});</code></pre></div>
<p>The following is an example of <em>partial upgrade stability</em> using
<a href="https://docs.rs/musli-storage">musli-storage</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="kw">let </span>version2 = musli_storage::to_buffer(<span class="kw-2">&amp;</span>Version2 {
    name: String::from(<span class="string">"Aristotle"</span>),
    age: <span class="prelude-val">Some</span>(<span class="number">62</span>),
})<span class="question-mark">?</span>;

<span class="macro">assert!</span>(musli_storage::decode::&lt;<span class="kw">_</span>, Version1&gt;(version2.as_slice()).is_err());

<span class="kw">let </span>version1 = musli_storage::to_buffer(<span class="kw-2">&amp;</span>Version1 {
    name: String::from(<span class="string">"Aristotle"</span>),
})<span class="question-mark">?</span>;

<span class="kw">let </span>version2: Version2 = musli_storage::decode(version1.as_slice())<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(version2, Version2 {
    name: String::from(<span class="string">"Aristotle"</span>),
    age: <span class="prelude-val">None</span>,
});</code></pre></div>
<br>
<h3 id="modes"><a class="doc-anchor" href="#modes">¬ß</a>Modes</h3>
<p>In M√ºsli the same model can be serialized in different ways. Instead of
requiring the use of multiple models, we instead support each model
implementing different <em>modes</em>.</p>
<p>A mode allows for different encoding attributes to apply depending on which
mode something is performed in. A mode can apply to <em>any</em> musli parameter
giving you a lot of flexibility.</p>
<p>If a mode is not specified, an implementation will apply to all modes (<code>M: Mode</code>), if at least one mode is specified it will be implemented for all
modes which are present in a model and <a href="https://docs.rs/musli/latest/musli/mode/enum.DefaultMode.html"><code>DefaultMode</code></a>. This way, an
encoding which uses <code>DefaultMode</code> (which it does by default) should always
work.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::mode::{DefaultMode, Mode};
<span class="kw">use </span>musli::{Decode, Encode};
<span class="kw">use </span>musli_json::Encoding;

<span class="kw">enum </span>Alt {}
<span class="kw">impl </span>Mode <span class="kw">for </span>Alt {}

<span class="attr">#[derive(Debug, PartialEq, Decode, Encode)]
#[musli(mode = Alt, packed)]
#[musli(default_field_name = <span class="string">"name"</span>)]
</span><span class="kw">struct </span>Word&lt;<span class="lifetime">'a</span>&gt; {
    text: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    teineigo: bool,
}

<span class="kw">let </span>CONFIG: Encoding&lt;DefaultMode&gt; = Encoding::new();
<span class="kw">let </span>ALT_CONFIG: Encoding&lt;Alt&gt; = Encoding::new();

<span class="kw">let </span>word = Word {
    text: <span class="string">"„ÅÇ„Çä„Åæ„Åô"</span>,
    teineigo: <span class="bool-val">true</span>,
};

<span class="kw">let </span>out = CONFIG.to_string(<span class="kw-2">&amp;</span>word)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(out, <span class="string">r#"{"text":"„ÅÇ„Çä„Åæ„Åô","teineigo":true}"#</span>);
<span class="kw">let </span>word2 = CONFIG.from_str(<span class="kw-2">&amp;</span>out[..])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(word, word2);

<span class="kw">let </span>out = ALT_CONFIG.to_string(<span class="kw-2">&amp;</span>word)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(out, <span class="string">r#"["„ÅÇ„Çä„Åæ„Åô",true]"#</span>);
<span class="kw">let </span>word2 = ALT_CONFIG.from_str(<span class="kw-2">&amp;</span>out[..])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(word, word2);
</code></pre></div>
<br>
<h3 id="unsafety"><a class="doc-anchor" href="#unsafety">¬ß</a>Unsafety</h3>
<p>This library currently has two instances of unsafe:</p>
<ul>
<li>
<p>A <code>mem::transcode</code> in <code>Tag::kind</code>. Which guarantees that converting into
the <code>Kind</code> enum which is <code>#[repr(u8)]</code> is as efficient as possible. (Soon
to be replaced with an equivalent safe variant).</p>
</li>
<li>
<p>A largely unsafe <code>SliceReader</code> which provides more efficient reading than
the default <code>Reader</code> impl for <code>&amp;[u8]</code> does (which uses split_at). Since it
can perform most of the necessary comparisons directly on the pointers.</p>
</li>
</ul>
<br>
<h3 id="performance"><a class="doc-anchor" href="#performance">¬ß</a>Performance</h3>
<blockquote>
<p>The following are the results of preliminary benchmarking and should be
taken with a big grain of üßÇ.</p>
</blockquote>
<p>Preliminary benchmarking indicates that M√ºsli roundtrip encodings for large
objects are about 10x faster than using JSON through serde, 5x faster than
<code>serde_cbor</code>, and 12% faster than bincode. Note that the JSON comparison
obviously isn‚Äôt apples-to-apples since the M√ºsli encoding isn‚Äôt
self-descriptive, but it‚Äôs included here to give a general idea of how it
compares. CBOR and bincode on the other hand have <em>comparable</em>
configurations.</p>
<p>For small objects the difference in encoding performance is even more
significant. M√ºsli producing code that‚Äôs 100x faster than JSON <strong>and</strong> CBOR,
20x faster than bincode (despite doing similarly oversized pre-allocation).
This holds for both the wire and storage format.</p>
<div class="example-wrap"><pre class="language-text"><code>json/roundtrip-large    time:   [91.263 us 91.756 us 92.239 us]
cbor/roundtrip-large    time:   [51.289 us 51.696 us 52.215 us]
bincode/roundtrip-large time:   [10.225 us 10.328 us 10.431 us]
musli-storage/roundtrip-large
                        time:   [9.0467 us 9.0881 us 9.1329 us]
musli-wire/roundtrip-large
                        time:   [11.906 us 11.933 us 11.964 us]

cbor/roundtrip-small    time:   [138.40 ns 147.94 ns 158.60 ns]
json/roundtrip-small    time:   [137.06 ns 137.93 ns 139.16 ns]
bincode/roundtrip-small time:   [16.978 ns 17.425 ns 18.057 ns]
musli-wire/roundtrip-small
                        time:   [1.0177 ns 1.0227 ns 1.0277 ns]
musli-storage/roundtrip-small
                        time:   [802.38 ps 803.95 ps 805.65 ps]
</code></pre></div>
<p>Note that these bencmarks include no ‚Äúwaste‚Äù, like extra unrecognized
fields. This is an area where M√ºsli‚Äôs current encoding indeed is expected to
lag behind since it needs to perform a fair bit of work to walk over
unrecognized data.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Decode"><code>pub use self::de::<a class="trait" href="de/trait.Decode.html" title="trait musli::de::Decode">Decode</a>;</code></div></li><li><div class="item-name" id="reexport.Decoder"><code>pub use self::de::<a class="trait" href="de/trait.Decoder.html" title="trait musli::de::Decoder">Decoder</a>;</code></div></li><li><div class="item-name" id="reexport.Encode"><code>pub use self::en::<a class="trait" href="en/trait.Encode.html" title="trait musli::en::Encode">Encode</a>;</code></div></li><li><div class="item-name" id="reexport.Encoder"><code>pub use self::en::<a class="trait" href="en/trait.Encoder.html" title="trait musli::en::Encoder">Encoder</a>;</code></div></li><li><div class="item-name" id="reexport.Mode"><code>pub use self::mode::<a class="trait" href="mode/trait.Mode.html" title="trait musli::mode::Mode">Mode</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="compat/index.html" title="mod musli::compat">compat</a></div><div class="desc docblock-short">Wrapper types which ensures that a given field is encoded or decoded as a
certain kind of value.</div></li><li><div class="item-name"><a class="mod" href="de/index.html" title="mod musli::de">de</a></div><div class="desc docblock-short">Traits for generically dealing with a decoding framework.</div></li><li><div class="item-name"><a class="mod" href="derives/index.html" title="mod musli::derives">derives</a></div><div class="desc docblock-short">The <a href="en/trait.Encode.html" title="trait musli::en::Encode"><code>Encode</code></a> and <a href="de/trait.Decode.html" title="trait musli::de::Decode"><code>Decode</code></a> derives</div></li><li><div class="item-name"><a class="mod" href="en/index.html" title="mod musli::en">en</a></div><div class="desc docblock-short">Traits for generically dealing with an encoding framework.</div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod musli::error">error</a></div><div class="desc docblock-short">Trait governing what error types associated with the encoding framework must
support.</div></li><li><div class="item-name"><a class="mod" href="mode/index.html" title="mod musli::mode">mode</a></div><div class="desc docblock-short">Type that describe a mode of encoding.</div></li><li><div class="item-name"><a class="mod" href="never/index.html" title="mod musli::never">never</a></div><div class="desc docblock-short">Module that provides a never type which conveniently implements all the
encoder and decoder traits so that it can be used as a placeholder.</div></li><li><div class="item-name"><a class="mod" href="utils/index.html" title="mod musli::utils">utils</a></div><div class="desc docblock-short">Utility functions for when interacting with <a href="https://docs.rs/musli">M√ºsli</a>.</div></li></ul><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.Decode.html" title="derive musli::Decode">Decode</a></div><div class="desc docblock-short">Please refer to the main <a href="https://docs.rs/musli">musli documentation</a>.</div></li><li><div class="item-name"><a class="derive" href="derive.Encode.html" title="derive musli::Encode">Encode</a></div><div class="desc docblock-short">Please refer to the main <a href="https://docs.rs/musli">musli documentation</a>.</div></li></ul></section></div></main></body></html>