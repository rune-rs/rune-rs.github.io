<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Deriving `Encode` and `Decode` in Müsli"><title>musli::_help::derives - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="musli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0-nightly (70b3f4666 2025-05-30)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../musli/index.html">musli</a><span class="version">0.0.131</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module derives</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#deriving-encode-and-decode-in-müsli" title="Deriving `Encode` and `Decode` in Müsli">Deriving <code>Encode</code> and <code>Decode</code> in Müsli</a></li><li><a href="#attributes" title="Attributes">Attributes</a></li><li><a href="#meta-attributes" title="Meta attributes">Meta attributes</a><ul><li><a href="#muslibinary-muslitext-or-muslimode--path" title="`#[musli(Binary)]`, `#[musli(Text)]`, or `#[musli(mode = &#60;path&#62;)]`"><code>#[musli(Binary)]</code>, <code>#[musli(Text)]</code>, or <code>#[musli(mode = &lt;path&gt;)]</code></a></li><li><a href="#musliencode_only" title="`#[musli(encode_only)]`"><code>#[musli(encode_only)]</code></a></li><li><a href="#muslidecode_only" title="`#[musli(decode_only)]`"><code>#[musli(decode_only)]</code></a></li></ul></li><li><a href="#container-attributes" title="Container attributes">Container attributes</a><ul><li><a href="#musliname_all--" title="`#[musli(name_all = &#34;..&#34;)]`"><code>#[musli(name_all = "..")]</code></a></li><li><a href="#muslitransparent" title="`#[musli(transparent)]`"><code>#[musli(transparent)]</code></a></li><li><a href="#muslipacked" title="`#[musli(packed)]`"><code>#[musli(packed)]</code></a></li><li><a href="#muslinametype--type" title="`#[musli(name(type = &#60;type&#62;))]`"><code>#[musli(name(type = &lt;type&gt;))]</code></a></li><li><a href="#muslinameformat_with--path" title="`#[musli(name(format_with = &#60;path&#62;))]`"><code>#[musli(name(format_with = &lt;path&gt;))]</code></a></li><li><a href="#muslinamemethod--sized--unsized--unsized_bytes" title="`#[musli(name(method = &#34;sized&#34; | &#34;unsized&#34; | &#34;unsized_bytes&#34;))]`"><code>#[musli(name(method = "sized" | "unsized" | "unsized_bytes"))]</code></a></li><li><a href="#muslibound---and-muslidecode_boundde-a--" title="`#[musli(bound = {..})]` and `#[musli(decode_bound&#60;&#39;de, A&#62; = {..})]`"><code>#[musli(bound = {..})]</code> and <code>#[musli(decode_bound&lt;'de, A&gt; = {..})]</code></a></li></ul></li><li><a href="#enum-attributes" title="Enum attributes">Enum attributes</a><ul><li><a href="#muslitag--" title="`#[musli(tag = ..)]`"><code>#[musli(tag = ..)]</code></a></li><li><a href="#muslitag---content--" title="`#[musli(tag = .., content = ..)]`"><code>#[musli(tag = .., content = ..)]</code></a></li><li><a href="#musliuntagged" title="`#[musli(untagged)]`"><code>#[musli(untagged)]</code></a></li></ul></li><li><a href="#variant-attributes" title="Variant attributes">Variant attributes</a><ul><li><a href="#musliname--" title="`#[musli(name = ..)]`"><code>#[musli(name = ..)]</code></a></li><li><a href="#muslipattern---or-muslipattern--pat--pat2--" title="`#[musli(pattern = ..)]` or `#[musli(pattern = (&#60;pat&#62; | &#60;pat2&#62; | ..))]`"><code>#[musli(pattern = ..)]</code> or <code>#[musli(pattern = (&lt;pat&gt; | &lt;pat2&gt; | ..))]</code></a></li><li><a href="#musliname_all---1" title="`#[musli(name_all = &#34;..&#34;)]`"><code>#[musli(name_all = "..")]</code></a></li><li><a href="#muslinametype--type-1" title="`#[musli(name(type = &#60;type&#62;))]`"><code>#[musli(name(type = &lt;type&gt;))]</code></a></li><li><a href="#muslinamemethod--sized--unsized--unsized_bytes-1" title="`#[musli(name(method = &#34;sized&#34; | &#34;unsized&#34; | &#34;unsized_bytes&#34;))]`"><code>#[musli(name(method = "sized" | "unsized" | "unsized_bytes"))]</code></a></li><li><a href="#muslitransparent-1" title="`#[musli(transparent)]`"><code>#[musli(transparent)]</code></a></li><li><a href="#muslidefault" title="`#[musli(default)]`"><code>#[musli(default)]</code></a></li></ul></li><li><a href="#field-attributes" title="Field attributes">Field attributes</a><ul><li><a href="#musliskip" title="`#[musli(skip)]`"><code>#[musli(skip)]</code></a></li><li><a href="#muslidefault--path" title="`#[musli(default [= &#60;path&#62;])]`"><code>#[musli(default [= &lt;path&gt;])]</code></a></li><li><a href="#musliname---1" title="`#[musli(name = ..)]`"><code>#[musli(name = ..)]</code></a></li><li><a href="#muslipattern---or-muslipattern--pat--pat2---1" title="`#[musli(pattern = ..)]` or `#[musli(pattern = (&#60;pat&#62; | &#60;pat2&#62; | ..))]`"><code>#[musli(pattern = ..)]</code> or <code>#[musli(pattern = (&lt;pat&gt; | &lt;pat2&gt; | ..))]</code></a></li><li><a href="#muslipacked-1" title="`#[musli(packed)]`"><code>#[musli(packed)]</code></a></li><li><a href="#muslibytes" title="`#[musli(bytes)]`"><code>#[musli(bytes)]</code></a></li><li><a href="#musliwith--path" title="`#[musli(with = &#60;path&#62;)]`"><code>#[musli(with = &lt;path&gt;)]</code></a></li><li><a href="#musliskip_encoding_if--path" title="`#[musli(skip_encoding_if = &#60;path&#62;)]`"><code>#[musli(skip_encoding_if = &lt;path&gt;)]</code></a></li><li><a href="#muslitrace" title="`#[musli(trace)]`"><code>#[musli(trace)]</code></a></li></ul></li><li><a href="#modes" title="Modes">Modes</a></li><li><a href="#enum-representations" title="Enum representations">Enum representations</a><ul><li><a href="#externally-tagged" title="Externally tagged">Externally tagged</a></li><li><a href="#internally-tagged" title="Internally tagged">Internally tagged</a></li><li><a href="#adjacently-tagged" title="Adjacently tagged">Adjacently tagged</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In musli::<wbr>_<wbr>help</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">musli</a>::<wbr><a href="../index.html">_help</a></div><h1>Module <span>derives</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/musli/lib.rs.html#527">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h3 id="deriving-encode-and-decode-in-müsli"><a class="doc-anchor" href="#deriving-encode-and-decode-in-müsli">§</a>Deriving <a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> in Müsli</h3>
<p>The <a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> traits can be automatically implemented through
derives.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person {
    name: String,
    age: u32,
}</code></pre></div>
<p>These derives come with a number of options for customizing the implementation
being generated documented below.</p>
<br>
<h3 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h3>
<ul>
<li>
<p><a href="#meta-attributes"><em>Meta attributes</em></a> which apply to the attribute itself. It
is used to filter what scope the current attribute applies to, such as only
applying to an <code>Encode</code> derive using <code>#[musli(encode_only, ..)]</code> or a specific
mode such as <code>#[musli(mode = Json, ..)]</code>.</p>
</li>
<li>
<p><a href="#container-attributes"><em>Container attributes</em></a> are attributes which apply to
the <code>struct</code> or <code>enum</code>.</p>
</li>
<li>
<p><a href="#variant-attributes"><em>Variant attributes</em></a> are attributes which apply to each
individual variant in an <code>enum</code>.</p>
</li>
<li>
<p><a href="#field-attributes"><em>Field attributes</em></a> are attributes which apply to each
individual field either in a <code>struct</code> or an <code>enum</code> variant.</p>
</li>
</ul>
<br>
<h3 id="meta-attributes"><a class="doc-anchor" href="#meta-attributes">§</a>Meta attributes</h3>
<p>Certain attributes affect which other attributes apply to a given context. These
are called <em>meta</em> attributes.</p>
<p>Meta attributes are applicable to any context, and can be used on containers,
variants, and fields.</p>
<br>
<h5 id="muslibinary-muslitext-or-muslimode--path"><a class="doc-anchor" href="#muslibinary-muslitext-or-muslimode--path">§</a><code>#[musli(Binary)]</code>, <code>#[musli(Text)]</code>, or <code>#[musli(mode = &lt;path&gt;)]</code></h5>
<p>Any sibling attributes only apply to the given <code>mode</code>. For <code>binary</code> the mode
will be <a href="https://docs.rs/musli/latest/musli/mode/enum.Binary.html"><code>Binary</code></a>. For <code>text</code> the mode will be <a href="https://docs.rs/musli/latest/musli/mode/enum.Text.html"><code>Text</code></a>. Custom modes can be
specified with <code>#[musli(mode = &lt;path&gt;)]</code>.</p>
<p>This allows for building multiple distinct implementations of <code>Encode</code> and
<code>Decode</code> in parallel which has different behaviors. See <a href="#modes">modes</a> for more
information.</p>
<br>
<h6 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h6>
<p>The <code>Person</code> struct below uses string field names by default when the <code>Text</code>
mode is enabled, but we can change this behavior only for that particular mode
like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(Text, name(<span class="kw">type </span>= usize))]
</span><span class="kw">struct </span>Person&lt;<span class="lifetime">'a</span>&gt; {
    name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    age: u32,
}</code></pre></div>
<br>
<h5 id="musliencode_only"><a class="doc-anchor" href="#musliencode_only">§</a><code>#[musli(encode_only)]</code></h5>
<p>The attributes only apply when implementing the <code>Encode</code> trait.</p>
<p>An example where this is useful is if you want to apply <code>#[musli(packed)]</code> in a
different mode, but only for encoding, since decoding packed types is not
supported for enums.</p>
<br>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::mode::Binary;
<span class="kw">use </span>musli::{Decode, Encode};

<span class="kw">enum </span>Packed {}

<span class="attr">#[derive(Encode, Decode)]
#[musli(mode = Packed, encode_only, untagged)]
</span><span class="kw">enum </span>Name&lt;<span class="lifetime">'a</span>&gt; {
    Full(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>str),
    Given(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>str),
}</code></pre></div>
<br>
<h5 id="muslidecode_only"><a class="doc-anchor" href="#muslidecode_only">§</a><code>#[musli(decode_only)]</code></h5>
<p>The attributes only apply when implementing the <code>Decode</code> trait.</p>
<br>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Name&lt;<span class="lifetime">'a</span>&gt; {
    sur_name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    <span class="attr">#[musli(Text, decode_only, name = <span class="string">"last"</span>)]
    </span>last_name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
}</code></pre></div>
<br>
<h3 id="container-attributes"><a class="doc-anchor" href="#container-attributes">§</a>Container attributes</h3>
<p>Container attributes apply to the container, such as directly on the <code>struct</code> or
<code>enum</code>. Like the uses of <code>#[musli(packed)]</code> and <code>#[musli(name_all = "PascalCase")]</code> here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    <span class="comment">/* the body of the struct */
</span>}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"PascalCase"</span>)]
</span><span class="kw">enum </span>Enum {
    <span class="comment">/* the body of the enum */
</span>}</code></pre></div>
<br>
<h5 id="musliname_all--"><a class="doc-anchor" href="#musliname_all--">§</a><code>#[musli(name_all = "..")]</code></h5>
<p>Allows for renaming every field or variant in the container. It can take any of
the following values:</p>
<ul>
<li><code>"index"</code> - the index starting at <code>0</code> of the field or variant will be used.
This is the default for the <a href="https://docs.rs/musli/latest/musli/mode/enum.Binary.html"><code>Binary</code></a> mode.</li>
<li><code>"name"</code> - the literal name of the field or variant will be used. This is the
default for the <a href="https://docs.rs/musli/latest/musli/mode/enum.Text.html"><code>Text</code></a> mode.</li>
<li><code>"PascalCase"</code> - the literal name of the field or variant will be converted to
pascal case.</li>
<li><code>"camelCase"</code> - the literal name of the field or variant will be converted to
camel case.</li>
<li><code>"snake_case"</code> - the literal name of the field or variant will be converted to
snake case.</li>
<li><code>"SCREAMING_SNAKE_CASE"</code> - the literal name of the field or variant will be
converted to screaming snake case.</li>
<li><code>"kebab-case"</code> - the literal name of the field or variant will be converted to
kebab case.</li>
<li><code>"SCREAMING-KEBAB-CASE"</code> - the literal name of the field or variant will be
converted to screaming kebab case.</li>
</ul>
<br>
<h6 id="renaming-struct-fields"><a class="doc-anchor" href="#renaming-struct-fields">§</a>Renaming struct fields</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"PascalCase"</span>)]
</span><span class="kw">struct </span>PascalCaseStruct {
    <span class="comment">// This will be named `FieldName`.
    </span>field_name: u32,
}</code></pre></div>
<br>
<h6 id="renaming-enum-variants"><a class="doc-anchor" href="#renaming-enum-variants">§</a>Renaming enum variants</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name_all = <span class="string">"kebab-case"</span>)]
</span><span class="kw">enum </span>KebabCase {
    <span class="comment">// This will be named `first-variant`.
    </span>FirstVariant {
        field_name: u32,
    },
    <span class="comment">// This will be named `second-variant`.
    </span>SecondVariant {
        field_name: u32,
    },
}</code></pre></div>
<br>
<h5 id="muslitransparent"><a class="doc-anchor" href="#muslitransparent">§</a><code>#[musli(transparent)]</code></h5>
<p>This can only be used on types which have a single field. It will cause that
field to define how that variant is encoded or decoded transparently without
being treated as a field.</p>
<br>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode)]
#[musli(transparent)]
</span><span class="kw">struct </span>Struct(u32);

<span class="kw">let </span>data = musli::wire::to_vec(<span class="kw-2">&amp;</span>Struct(<span class="number">42</span>))<span class="question-mark">?</span>;
<span class="kw">let </span>actual: u32 = musli::wire::from_slice(<span class="kw-2">&amp;</span>data)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(actual, <span class="number">42u32</span>);
<span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, musli::wire::Error&gt;(())</code></pre></div>
<br>
<h5 id="muslipacked"><a class="doc-anchor" href="#muslipacked">§</a><code>#[musli(packed)]</code></h5>
<p>This attribute will disable all <em>tagging</em> and the structure will simply be
encoded with one field following another in the order in which they are defined.</p>
<p>Structures which are <em>packed</em> cannot be easily versioned and the two systems
communicating using them need to handle field versioning out of bounds.</p>
<p>This attribute is useful for performing simple decoding over “raw” bytes when
combined with an encoder which does minimal prefixing and packs fields. Using a
packed format is typically also the most efficient mode of operation in Müsli.</p>
<br>
<h6 id="bitwise-optimizations"><a class="doc-anchor" href="#bitwise-optimizations">§</a>Bitwise optimizations</h6>
<p>If a struct is tagged with <code>#[musli(packed)]</code>, and the bitwise pattern of a
given serialization is <em>identical</em> to the bitwise memory pattern of the struct,
then serialization and deserialization can be made more efficient.</p>
<p>Note that since <a href="https://doc.rust-lang.org/nomicon/repr-rust.html"><code>#[repr(Rust)]</code></a> is not strictly defined, it might
be necessary to mark the struct with <code>#[repr(C)]</code> to benefit from this
optimization. But this has no safety implications.</p>
<p>If the bitwise optimizations does not work. You can test if bitwise
optimizations are possible through <a href="https://docs.rs/musli/latest/musli/fn.is_bitwise_encode.html"><code>musli::is_bitwise_encode</code></a> and
<a href="https://docs.rs/musli/latest/musli/fn.is_bitwise_decode.html"><code>musli::is_bitwise_decode</code></a>.</p>
<p>Bitwise optimizations are disabled if:</p>
<ul>
<li>Any of the field uses a custom encoding method through for example
<a href="#musliwith--path"><code>#[musli(with = &lt;path&gt;)]</code></a>.</li>
<li>If the type implements <code>Drop</code>.</li>
</ul>
<br>
<h6 id="packed-struct"><a class="doc-anchor" href="#packed-struct">§</a>Packed struct</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    field1: u32,
    field2: u64,
}

<span class="kw">let </span>data = musli::storage::to_vec(<span class="kw-2">&amp;</span>Struct {
    field1: <span class="number">1</span>,
    field2: <span class="number">2</span>,
})<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(data.as_slice(), [<span class="number">1</span>, <span class="number">2</span>]);
<span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, musli::storage::Error&gt;(())</code></pre></div>
<br>
<h6 id="bitwise-encoded-fields"><a class="doc-anchor" href="#bitwise-encoded-fields">§</a>Bitwise encoded fields</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    a: u32,
    b: u32,
}

<span class="kw">const _</span>: () = <span class="macro">assert!</span>(musli::is_bitwise_encode::&lt;Struct&gt;());
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(musli::is_bitwise_decode::&lt;Struct&gt;());</code></pre></div>
<p>Note that some combinations of fields currently only support encoding in one
direction. This is the case for <code>NonZero</code> types, since they cannot inhabit all
possible bit patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::num::NonZero;
<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    a: NonZero&lt;u32&gt;,
    b: u32,
}

<span class="kw">const _</span>: () = <span class="macro">assert!</span>(musli::is_bitwise_encode::&lt;Struct&gt;());
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!musli::is_bitwise_decode::&lt;Struct&gt;());</code></pre></div>
<p>Bitwise optimizations are disabled if custom encoding is specified:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    a: u32,
    <span class="attr">#[musli(with = musli::serde)]
    </span>b: u32,
}

<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!musli::is_bitwise_encode::&lt;Struct&gt;());
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!musli::is_bitwise_decode::&lt;Struct&gt;());</code></pre></div>
<p>Bitwise optimizations are disabled if the type implements <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(packed)]
</span><span class="kw">struct </span>Struct {
    a: u32,
    b: u32,
}

<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!musli::is_bitwise_encode::&lt;Struct&gt;());
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!musli::is_bitwise_decode::&lt;Struct&gt;());

<span class="kw">impl </span>Drop <span class="kw">for </span>Struct {
    <span class="kw">fn </span>drop(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
    }
}</code></pre></div>
<br>
<h5 id="muslinametype--type"><a class="doc-anchor" href="#muslinametype--type">§</a><code>#[musli(name(type = &lt;type&gt;))]</code></h5>
<p>This indicates which type any contained <code>#[musli(name = ..)]</code> attributes should
have. Tags can usually be inferred, but specifying this field ensures that all
tags have a single well-defined type.</p>
<p>The following values are treated specially:</p>
<ul>
<li><code>str</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
<li><code>[u8]</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
</ul>
<p>Apart from those two types, the <code>name(type)</code> must be a sized type which
implements <a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a>.</p>
<p>The default type depends on the mode in use:</p>
<ul>
<li><a href="https://docs.rs/musli/latest/musli/mode/enum.Binary.html"><code>Binary</code></a> and any other custom mode uses indexed fields, the equivalent of
<code>#[musli(name(type = usize))]</code>.</li>
<li><a href="https://docs.rs/musli/latest/musli/mode/enum.Text.html"><code>Text</code></a> uses literal text fields by their name, the equivalent of
<code>#[musli(name(type = str))]</code>.</li>
</ul>
<br>
<h6 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::fmt;

<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Eq, Encode, Decode)]
#[musli(transparent)]
</span><span class="kw">struct </span>CustomTag&lt;<span class="lifetime">'a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>[u8]);

<span class="kw">impl </span>fmt::Display <span class="kw">for </span>CustomTag&lt;<span class="lifetime">'_</span>&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; fmt::Result {
        fmt::Debug::fmt(<span class="self">self</span>.<span class="number">0</span>, f)
    }
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name(<span class="kw">type </span>= CustomTag))]
</span><span class="kw">struct </span>Struct {
    <span class="attr">#[musli(name = CustomTag(<span class="string">b"name in bytes"</span>))]
    </span>name: String,
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name(<span class="kw">type </span>= CustomTag))]
</span><span class="kw">enum </span>EnumWithCustomTag {
    <span class="attr">#[musli(name = CustomTag(<span class="string">b"variant one"</span>))]
    </span>Variant1 {
        <span class="comment">/* .. */
    </span>},
}</code></pre></div>
<br>
<h5 id="muslinameformat_with--path"><a class="doc-anchor" href="#muslinameformat_with--path">§</a><code>#[musli(name(format_with = &lt;path&gt;))]</code></h5>
<p>This indicates the method which should be used to format <code>#[musli(name = ..)]</code>
attributes for diagnostics.</p>
<p>This can be useful if the default <a href="https://doc.rust-lang.org/nightly/core/fmt/macros/derive.Debug.html" title="derive core::fmt::macros::Debug"><code>Debug</code></a> implementation might not be
particularly helpful, one example is <code>#[musli(name(type = [u8]))]</code> which formats
the value as an array of numbers. Here <code>#[musli(name(format_with = BStr::new))]</code>
might be more helpful.</p>
<br>
<h6 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::BStr;
<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name(<span class="kw">type </span>= [u8]</span>, format_with = BStr::new))]
<span class="kw">struct </span>StructBytesArray {
    <span class="attr">#[musli(name = <span class="string">b"field1"</span>)]
    </span>field1: u32,
    <span class="attr">#[musli(name = <span class="string">b"field2"</span>)]
    </span>field2: u32,
}
</code></pre></div>
<br>
<h5 id="muslinamemethod--sized--unsized--unsized_bytes"><a class="doc-anchor" href="#muslinamemethod--sized--unsized--unsized_bytes">§</a><code>#[musli(name(method = "sized" | "unsized" | "unsized_bytes"))]</code></h5>
<p>This allows for explicitly setting which method should be used to decode names.
Available options are:</p>
<ul>
<li><code>"sized"</code> (default) - decode as a sized value.</li>
<li><code>"unsized"</code> - the name is decoded as an unsized value, this is the default if
for example <code>#[musli(name(type = str))]</code> is used.</li>
<li><code>"unsized_bytes"</code> - the name is decoded as a unsized bytes, this is the
default if for example <code>#[musli(name(type = [u8]))]</code> is used.</li>
</ul>
<p>This can be overrided for values which are unsized, but cannot be determined
through heuristics. Such a type must also implement <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> (for <code>"sized"</code>),
<code>DecodeUnsized</code>, or <code>DecodeUnsizedBytes</code> as appropriate.</p>
<br>
<h5 id="muslibound---and-muslidecode_boundde-a--"><a class="doc-anchor" href="#muslibound---and-muslidecode_boundde-a--">§</a><code>#[musli(bound = {..})]</code> and <code>#[musli(decode_bound&lt;'de, A&gt; = {..})]</code></h5>
<p>These attributes can be used to apply bounds to an <a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> or <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a>
implementation.</p>
<p>These are necessary to use when a generic container is used to ensure that the
given parameter implements the necessary bounds.</p>
<p><code>#[musli(bound = {..})]</code> applies to all implementations while
<code>#[musli(decode_bound&lt;'de, A&gt; = {..})]</code> only applies to the <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a>
implementation. The latter allows for using the decode lifetime and allocator
parameter. If these parameters are not part of the type signature, they can be
specified in the <code>decode_bound</code> parameter directly like
<code>#[musli(decode_bound&lt;'de, A&gt; = {..})]</code>.</p>
<p>An HRTB can also be used like <code>#[musli(decode_bound&lt;A&gt; = {T: for&lt;'de&gt; Decode&lt;'de, Binary, A&gt;})]</code>.</p>
<p>By default, a bound is added for every type parameter allowing types like these
to compile without additional specification:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Debug, Clone, Encode, Decode)]
</span><span class="kw">pub struct </span>Mesh&lt;V: AsRef&lt;[u32]&gt; = Vec&lt;u32&gt;&gt; {
    <span class="kw">pub </span>triangles: V,
}</code></pre></div>
<p>Note that any identifier mentioned in a bound configuration will cause the
default bound to be excluded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::marker::PhantomData;
<span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Debug, Clone, Encode, Decode)]
#[musli(Binary, bound = {T}, decode_bound = {T})]
</span><span class="kw">pub struct </span>Ignore&lt;T&gt; {
    <span class="attr">#[musli(default)]
    </span><span class="kw">pub </span>_marker: PhantomData&lt;T&gt;,
}</code></pre></div>
<br>
<h6 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Decode, Encode};
<span class="kw">use </span>musli::mode::{Binary, Text};

<span class="attr">#[derive(Clone, Debug, PartialEq, Encode, Decode)]
#[musli(Binary, bound = {T: Encode&lt;Binary&gt;}, decode_bound&lt;<span class="lifetime">'de</span>, A&gt; = {T: Decode&lt;<span class="lifetime">'de</span>, Binary, A&gt;})]
#[musli(Text, bound = {T: Encode&lt;Text&gt;}, decode_bound&lt;<span class="lifetime">'de</span>, A&gt; = {T: Decode&lt;<span class="lifetime">'de</span>, Text, A&gt;})]
</span><span class="kw">pub struct </span>GenericWithBound&lt;T&gt; {
    value: T,
}</code></pre></div>
<br>
<h3 id="enum-attributes"><a class="doc-anchor" href="#enum-attributes">§</a>Enum attributes</h3><br>
<h5 id="muslitag--"><a class="doc-anchor" href="#muslitag--">§</a><code>#[musli(tag = ..)]</code></h5>
<p>This attribute causes the enum to be internally tagged, with the given tag. See
<a href="#enum-representations">enum representations</a> for details on this
representation.</p>
<p>The value of the attributes specifies the name of the tag to use for this.</p>
<p>The <code>tag</code> attribute supports the same options such as <code>name</code>, which are:</p>
<ul>
<li><code>#[tag(value = ..)]</code> - Specify the value of the tag when list options are
used.</li>
<li><code>#[tag(type = ..)]</code> - Specify the type of the tag.</li>
<li><code>#[tag(format_with = ..)]</code> - Specify how to format the tag for diagnostics.</li>
</ul>
<br>
<h6 id="using-a-string-tag"><a class="doc-anchor" href="#using-a-string-tag">§</a>Using a string tag</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(tag = <span class="string">"type"</span>)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String },
    Reply { id: String, body: Vec&lt;u8&gt; },
}</code></pre></div>
<br>
<h5 id="muslitag---content--"><a class="doc-anchor" href="#muslitag---content--">§</a><code>#[musli(tag = .., content = ..)]</code></h5>
<p>This attribute causes the enum to be adjacently tagged, with the given tag. See
<a href="#enum-representations">enum representations</a> for details on this
representation.</p>
<p>The value of the attributes specifies the name of the tag to use and the content
where the data will be stored.</p>
<p>The <code>tag</code> and <code>content</code> attributes support the same options such as <code>name</code>,
which are:</p>
<ul>
<li><code>#[tag(value = ..)]</code> or <code>#[content(value = ..)]</code> - Specify the value of the
tag or content when list options are used.</li>
<li><code>#[tag(type = ..)]</code> or <code>#[content(type = ..)]</code> - Specify the type of the tag
or content.</li>
<li><code>#[tag(format_with = ..)]</code> or <code>#[content(format?with = ..)]</code> - Specify how to
format the tag or content for diagnostics.</li>
</ul>
<br>
<h6 id="using-a-string-tag-1"><a class="doc-anchor" href="#using-a-string-tag-1">§</a>Using a string tag</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(tag = <span class="string">"type"</span>, content = <span class="string">"data"</span>)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String },
    Reply { id: String, body: Vec&lt;u8&gt; },
}</code></pre></div>
<h6 id="using-a-tag-with-custom-formatting"><a class="doc-anchor" href="#using-a-tag-with-custom-formatting">§</a>Using a tag with custom formatting</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::BStr;
<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(tag(value = <span class="string">b"type"</span>, format_with = BStr::new), content(value = <span class="string">b"data"</span>, format_with = BStr::new))]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String },
    Reply { id: String, body: Vec&lt;u8&gt; },
}</code></pre></div>
<br>
<h6 id="using-a-numerical-tag"><a class="doc-anchor" href="#using-a-numerical-tag">§</a>Using a numerical tag</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
#[musli(name(<span class="kw">type </span>= usize), tag = <span class="number">10</span>)]
</span><span class="kw">enum </span>Message {
    <span class="attr">#[musli(name = <span class="number">1</span>)]
    </span>Request { id: String, method: String },
    <span class="attr">#[musli(name = <span class="number">2</span>)]
    </span>Reply { id: String, body: Vec&lt;u8&gt; },
}</code></pre></div>
<br>
<h5 id="musliuntagged"><a class="doc-anchor" href="#musliuntagged">§</a><code>#[musli(untagged)]</code></h5>
<p>The <code>#[musli(untagged)]</code> attribute results in variants being encoded as-is
without any information about which variant is being encoded. When decoding,
variants will be decoded one after another in declaration order. The first one
to be successfully decoded is the one which will be used.</p>
<p>Note that this <em>can</em> result in encoding being assymetric. And exactly which
variant is being decoded depends on the format.</p>
<p>Note that a decoder must implement <a href="https://docs.rs/musli/latest/musli/trait.Decoder.html#method.try_clone"><code>Decoder::try_clone</code></a> for untagged enums to
be decoded. If this is not implemented, the decoder must support
<a href="https://docs.rs/musli/latest/musli/trait.Decoder.html#method.decode_buffer"><code>Decoder::decode_buffer</code></a> instead.</p>
<p>Note that standard decoders do not support <a href="https://docs.rs/musli/latest/musli/trait.Decoder.html#method.try_clone"><code>Decoder::try_clone</code></a> when decoding
<code>&amp;mut &amp;[u8]</code>. The root cause of this is that exclusive references cannot be
cloned. This limitation might be lifted in the future:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>require_clone(<span class="kw">_</span>: <span class="kw">impl </span>Clone) {}

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>value: [u8; <span class="number">4</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
    require_clone(<span class="kw-2">&amp;</span>value[..]);
    require_clone(<span class="kw-2">&amp;mut &amp;</span>value[..]); <span class="comment">// the trait `Clone` is not implemented for `&amp;mut &amp;[u8]`
</span>}</code></pre></div>
<br>
<h6 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Encode, Decode)]
</span><span class="kw">pub struct </span>Numbers {
    foo: u32,
    bar: u32,
    baz: u32,
}

<span class="attr">#[derive(Debug, PartialEq, Encode, Decode)]
#[musli(untagged)]
</span><span class="kw">pub enum </span>Untagged {
    Person {
        name: String,
        age: u32,
    },
    <span class="attr">#[musli(transparent)]
    </span>Numbers(Numbers),
}</code></pre></div>
<br>
<h3 id="variant-attributes"><a class="doc-anchor" href="#variant-attributes">§</a>Variant attributes</h3>
<p><em>Variant attributes</em> are attributes which apply to each individual variant in an
<code>enum</code>. Like the use of <code>#[musli(name = ..)]</code> here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>Enum {
    <span class="attr">#[musli(transparent)]
    </span>Variant(Variant),
    <span class="attr">#[musli(Text, name = <span class="string">"Other"</span>)]
    </span>Something {
        <span class="comment">/* variant body */
    </span>},
}

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Variant {
    field: String,
}</code></pre></div>
<br>
<h5 id="musliname--"><a class="doc-anchor" href="#musliname--">§</a><code>#[musli(name = ..)]</code></h5>
<p>This allows for renaming a variant from its default value. It can take any value
(including complex ones) that can be serialized with the current encoding, such
as:</p>
<ul>
<li><code>#[musli(name = 1)]</code></li>
<li><code>#[musli(name = "Hello World")]</code></li>
<li><code>#[musli(name = b"box\0")]</code></li>
<li><code>#[musli(name = SomeStruct { field: 42 })]</code> (if <code>SomeStruct</code> implements
<a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> as appropriate).</li>
</ul>
<p>If the type of the tag is ambiguous it can be explicitly specified through the
<code>#[musli(name_type)]</code> attribute.</p>
<br>
<h5 id="muslipattern---or-muslipattern--pat--pat2--"><a class="doc-anchor" href="#muslipattern---or-muslipattern--pat--pat2--">§</a><code>#[musli(pattern = ..)]</code> or <code>#[musli(pattern = (&lt;pat&gt; | &lt;pat2&gt; | ..))]</code></h5>
<p>A pattern to match for decoding a variant.</p>
<p>This allows for more flexibility when decoding variants.</p>
<br>
<h6 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>Enum {
    Variant1,
    Variant2,
    <span class="attr">#[musli(Binary, pattern = <span class="number">2</span>..=<span class="number">4</span>)]
    </span>Deprecated,
}</code></pre></div>
<p>Multiple patterns are supported with parenthesis:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>Enum {
    Variant1,
    Variant2,
    <span class="attr">#[musli(Binary, pattern = (<span class="number">2</span>..=<span class="number">4 </span>| <span class="number">10</span>..=<span class="number">20</span>))]
    </span>Deprecated,
}</code></pre></div>
<br>
<h5 id="musliname_all---1"><a class="doc-anchor" href="#musliname_all---1">§</a><code>#[musli(name_all = "..")]</code></h5>
<p>Allows for renaming every field in a variant. It can take any of the following
values:</p>
<ul>
<li><code>"index"</code> - the index starting at <code>0</code> of the field will be used. This is the
default for the <a href="https://docs.rs/musli/latest/musli/mode/enum.Binary.html"><code>Binary</code></a> mode.</li>
<li><code>"name"</code> - the literal name of the field will be used. This is the default for
the <a href="https://docs.rs/musli/latest/musli/mode/enum.Text.html"><code>Text</code></a> mode.</li>
<li><code>"PascalCase"</code> - the literal name of the field will be converted to pascal
case.</li>
<li><code>"camelCase"</code> - the literal name of the field will be converted to camel case.</li>
<li><code>"snake_case"</code> - the literal name of the field will be converted to snake
case.</li>
<li><code>"SCREAMING_SNAKE_CASE"</code> - the literal name of the field will be converted to
screaming snake case.</li>
<li><code>"kebab-case"</code> - the literal name of the field will be converted to kebab
case.</li>
<li><code>"SCREAMING-KEBAB-CASE"</code> - the literal name of the field will be converted to
screaming kebab case.</li>
</ul>
<br>
<h6 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>PascalCaseEnum {
    <span class="attr">#[musli(name_all = <span class="string">"PascalCase"</span>)]
    </span>Variant {
        <span class="comment">// This field will be named `FieldName`.
        </span>field_name: u32,
    }
}</code></pre></div>
<br>
<h5 id="muslinametype--type-1"><a class="doc-anchor" href="#muslinametype--type-1">§</a><code>#[musli(name(type = &lt;type&gt;))]</code></h5>
<p>This indicates which type any contained <code>#[musli(tag = ..)]</code> attributes should
have. Tags can usually be inferred, but specifying this field ensures that all
tags have a well-defined type.</p>
<p>The following values are treated specially:</p>
<ul>
<li><code>str</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
<li><code>[u8]</code> applies <code>#[musli(name_all = "name")]</code> by default.</li>
</ul>
<br>
<h6 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::fmt;

<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Eq, Encode, Decode)]
#[musli(transparent)]
</span><span class="kw">struct </span>CustomTag&lt;<span class="lifetime">'a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>[u8]);

<span class="kw">impl </span>fmt::Display <span class="kw">for </span>CustomTag&lt;<span class="lifetime">'_</span>&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; fmt::Result {
        fmt::Debug::fmt(<span class="self">self</span>.<span class="number">0</span>, f)
    }
}

<span class="attr">#[derive(Encode, Decode)]
#[musli(name(<span class="kw">type </span>= usize))]
</span><span class="kw">enum </span>Enum {
    <span class="attr">#[musli(name = <span class="number">0</span>, name(<span class="kw">type </span>= CustomTag))]
    </span>Variant {
        <span class="attr">#[musli(name = CustomTag(<span class="string">b"field1"</span>))]
        </span>field1: u32,
        <span class="attr">#[musli(name = CustomTag(<span class="string">b"field2"</span>))]
        </span>field2: u32,
    },
    <span class="attr">#[musli(name = <span class="number">1</span>, name_all = <span class="string">"name"</span>)]
    </span>Variant2 {
        field1: u32,
        field2: u32,
    },
}</code></pre></div>
<br>
<h5 id="muslinamemethod--sized--unsized--unsized_bytes-1"><a class="doc-anchor" href="#muslinamemethod--sized--unsized--unsized_bytes-1">§</a><code>#[musli(name(method = "sized" | "unsized" | "unsized_bytes"))]</code></h5>
<p>This allows for explicitly setting which method should be used to decode field
names. Available options are:</p>
<ul>
<li><code>"sized"</code> (default) - the name is decoded as a sized value.</li>
<li><code>"unsized"</code> - the name is decoded as an unsized value, this is the default if
for example <code>#[musli(name(type = str))]</code> is used.</li>
<li><code>"unsized_bytes"</code> - the name is decoded as a unsized bytes, this is the
default if for example <code>#[musli(name(type = [u8]))]</code> is used.</li>
</ul>
<p>This can be overrided for values which are unsized, but cannot be determined
through heuristics. Such a type must also implement <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> (for <code>"sized"</code>),
<code>DecodeUnsized</code>, or <code>DecodeUnsizedBytes</code> as appropriate.</p>
<br>
<h6 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::BStr;
<span class="kw">use </span>musli::{Encode, Decode};
<span class="kw">use </span>musli::de::{Decoder, DecodeUnsized};

<span class="kw">use </span>core::fmt;
<span class="kw">use </span>core::ops::Deref;

<span class="attr">#[derive(Debug, PartialEq, Encode, Decode)]
#[musli(name(<span class="kw">type </span>= UnsizedBytes, method = <span class="string">"unsized"</span>))]
</span><span class="kw">pub struct </span>StructWithUnsizedBytes {
    <span class="attr">#[musli(name = UnsizedBytes::new(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span>), pattern = UnsizedBytes([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))]
    field1: u32,
    <span class="attr">#[musli(name = UnsizedBytes::new(<span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span>), pattern = UnsizedBytes([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))]
    field2: u32,
}

<span class="attr">#[derive(Encode)]
#[repr(transparent)]
#[musli(transparent)]
</span><span class="kw">struct </span>UnsizedBytes(<span class="attr">#[musli(bytes)] </span>[u8]);

<span class="kw">impl</span>&lt;<span class="lifetime">'de</span>, M&gt; DecodeUnsized&lt;<span class="lifetime">'de</span>, M&gt; <span class="kw">for </span>UnsizedBytes {
    <span class="kw">fn </span>decode_unsized&lt;D, F, O&gt;(decoder: D, f: F) -&gt; <span class="prelude-ty">Result</span>&lt;O, D::Error&gt;
    <span class="kw">where
        </span>D: Decoder&lt;<span class="lifetime">'de</span>, Mode = M&gt;,
        F: FnOnce(<span class="kw-2">&amp;</span><span class="self">Self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;O, D::Error&gt;,
    {
        decoder.decode_unsized_bytes(|bytes: <span class="kw-2">&amp;</span>[u8]| f(UnsizedBytes::new(bytes)))
    }
}

<span class="kw">impl </span>UnsizedBytes {
    <span class="kw">const fn </span>new(data: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="kw-2">&amp;</span><span class="self">Self </span>{
        <span class="comment">// SAFETY: `UnsizedBytes` is a transparent wrapper around `[u8]`.
        </span><span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>(data <span class="kw">as </span><span class="kw-2">*const </span>[u8] <span class="kw">as </span><span class="kw-2">*const </span>UnsizedBytes) }
    }
}

<span class="kw">impl </span>Deref <span class="kw">for </span>UnsizedBytes {
    <span class="kw">type </span>Target = [u8];

    <span class="kw">fn </span>deref(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span>::Target {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0
    </span>}
}

<span class="kw">impl </span>fmt::Display <span class="kw">for </span>UnsizedBytes {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; fmt::Result {
        BStr::new(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0</span>).fmt(f)
    }
}

<span class="kw">impl </span>fmt::Debug <span class="kw">for </span>UnsizedBytes {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; fmt::Result {
        BStr::new(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0</span>).fmt(f)
    }
}</code></pre></div>
<br>
<h5 id="muslitransparent-1"><a class="doc-anchor" href="#muslitransparent-1">§</a><code>#[musli(transparent)]</code></h5>
<p>This can only be used on variants which have a single field. It will cause that
field to define how that variant is encoded or decoded transparently without
being treated as a field.</p>
<br>
<h5 id="muslidefault"><a class="doc-anchor" href="#muslidefault">§</a><code>#[musli(default)]</code></h5>
<p>This defines the variant that will be used in case no other variant matches.
Only one such variant can be defined.</p>
<br>
<h6 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Debug, PartialEq, Eq, Encode, Decode)]
</span><span class="kw">enum </span>Animal {
    Cat,
    Dog,
    <span class="attr">#[musli(default)]
    </span>Unknown,
}</code></pre></div>
<br>
<h3 id="field-attributes"><a class="doc-anchor" href="#field-attributes">§</a>Field attributes</h3>
<p><em>Field attributes</em> are attributes which apply to each individual field either in
a <code>struct</code> or an <code>enum</code> variant. Like the uses of <code>#[musli(all)]</code> here:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Struct {
    <span class="attr">#[musli(Text, name = <span class="string">"other"</span>)]
    </span>something: String,
    <span class="attr">#[musli(skip, default = default_field)]
    </span>skipped_field: u32,
}

<span class="kw">fn </span>default_field() -&gt; u32 {
    <span class="number">42
</span>}

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>Enum {
    Variant {
        <span class="attr">#[musli(Text, name = <span class="string">"other"</span>)]
        </span>something: String,
    }
}</code></pre></div>
<br>
<h5 id="musliskip"><a class="doc-anchor" href="#musliskip">§</a><code>#[musli(skip)]</code></h5>
<p>This attribute means that the entire field is skipped. If a field is decoded it
uses <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" title="associated function core::default::Default::default"><code>Default::default</code></a> to construct the value. Other defaults can be
specified with [<code>#[musli(default = &lt;path&gt;)]</code>][#muslidefault–path].</p>
<br>
<h6 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person {
    name: String,
    <span class="attr">#[musli(skip)]
    </span>age: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="attr">#[musli(skip, default = default_country)]
    </span>country: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>default_country() -&gt; <span class="prelude-ty">Option</span>&lt;String&gt; {
    <span class="prelude-val">Some</span>(String::from(<span class="string">"Earth"</span>))
}</code></pre></div>
<br>
<h5 id="muslidefault--path"><a class="doc-anchor" href="#muslidefault--path">§</a><code>#[musli(default [= &lt;path&gt;])]</code></h5>
<p>When a field is absent or disabled with <code>#[musli(skip)]</code>, this attribute
specifies that a default value should be used instead.</p>
<p>If <code>#[musli(default)]</code> is specified, the default value is constructed using
<a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" title="associated function core::default::Default::default"><code>Default::default</code></a>.</p>
<p>If <code>#[musli(default = &lt;path&gt;)]</code> is specified, the default value is constructed
by calling the function at <code>&lt;path&gt;</code>.</p>
<br>
<h6 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person {
    name: String,
    <span class="attr">#[musli(default)]
    </span>age: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="attr">#[musli(default = default_height)]
    </span>height: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="attr">#[musli(skip, default = default_meaning)]
    </span>meaning: u32,
}

<span class="kw">fn </span>default_height() -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    <span class="prelude-val">Some</span>(<span class="number">180</span>)
}

<span class="kw">fn </span>default_meaning() -&gt; u32 {
    <span class="number">42
</span>}</code></pre></div>
<br>
<h5 id="musliname---1"><a class="doc-anchor" href="#musliname---1">§</a><code>#[musli(name = ..)]</code></h5>
<p>This allows for renaming a field from its default value. It can take any value
(including complex ones) that can be serialized with the current encoding, such
as:</p>
<ul>
<li><code>#[musli(name = 1)]</code></li>
<li><code>#[musli(name = "Hello World")]</code></li>
<li><code>#[musli(name = b"box\0")]</code></li>
<li><code>#[musli(name = SomeStruct { field: 42 })]</code> (if <code>SomeStruct</code> implements
<a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> as appropriate).</li>
</ul>
<p>If the type of the tag is ambiguous it can be explicitly specified through the
<code>#[musli(name(type))]</code> variant or container attributes.</p>
<br>
<h5 id="muslipattern---or-muslipattern--pat--pat2---1"><a class="doc-anchor" href="#muslipattern---or-muslipattern--pat--pat2---1">§</a><code>#[musli(pattern = ..)]</code> or <code>#[musli(pattern = (&lt;pat&gt; | &lt;pat2&gt; | ..))]</code></h5>
<p>A pattern to match for decoding the given field.</p>
<p>This allows for more flexibility when decoding fields.</p>
<br>
<h6 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Struct {
    field1: u32,
    field2: u32,
    <span class="attr">#[musli(Binary, pattern = <span class="number">2</span>..=<span class="number">4</span>)]
    </span>other: u32,
}</code></pre></div>
<p>Multiple patterns are supported with parenthesis:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Struct {
    field1: u32,
    field2: u32,
    <span class="attr">#[musli(Binary, pattern = (<span class="number">2</span>..=<span class="number">4 </span>| <span class="number">10</span>..=<span class="number">20</span>))]
    </span>other: u32,
}</code></pre></div>
<br>
<h5 id="muslipacked-1"><a class="doc-anchor" href="#muslipacked-1">§</a><code>#[musli(packed)]</code></h5>
<p>This specifies that encoding and decoding should happen through the
<a href="https://docs.rs/musli/latest/musli/en/trait.EncodePacked.html"><code>EncodePacked</code></a> and <a href="https://docs.rs/musli/latest/musli/de/trait.DecodePacked.html"><code>DecodePacked</code></a> traits, instead of the default <a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a>
and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a>.</p>
<p>These traits contained implementations which are biased towards encoding the
field as a compact, non-future compatible pack. In essense, the fields are
encoded “one after another” without any metadata separating them. So for packed
fields, the order, types and number of the fields are important.</p>
<br>
<h6 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::VecDeque;

<span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Decode, Encode)]
</span><span class="kw">struct </span>Container {
    <span class="attr">#[musli(packed)]
    </span>tuple: (u32, u64),
    <span class="attr">#[musli(packed)]
    </span>array: [u32; <span class="number">4</span>],
}</code></pre></div>
<br>
<h5 id="muslibytes"><a class="doc-anchor" href="#muslibytes">§</a><code>#[musli(bytes)]</code></h5>
<p>This specifies that encoding and decoding should happen through the
<a href="https://docs.rs/musli/latest/musli/en/trait.EncodeBytes.html"><code>EncodeBytes</code></a> and <a href="https://docs.rs/musli/latest/musli/de/trait.DecodeBytes.html"><code>DecodeBytes</code></a> traits, instead of the default <a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a>
and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a>.</p>
<p>These traits contained implementations which are biased towards encoding the
field as an array of bytes.</p>
<br>
<h6 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::VecDeque;

<span class="kw">use </span>musli::{Decode, Encode};

<span class="attr">#[derive(Decode, Encode)]
</span><span class="kw">struct </span>Container&lt;<span class="lifetime">'de</span>&gt; {
    <span class="attr">#[musli(bytes)]
    </span>vec: Vec&lt;u8&gt;,
    <span class="attr">#[musli(bytes)]
    </span>vec_deque: VecDeque&lt;u8&gt;,
    <span class="attr">#[musli(bytes)]
    </span>bytes: <span class="kw-2">&amp;</span><span class="lifetime">'de </span>[u8],
}</code></pre></div>
<br>
<h5 id="musliwith--path"><a class="doc-anchor" href="#musliwith--path">§</a><code>#[musli(with = &lt;path&gt;)]</code></h5>
<p>This specifies the path to a module to use instead of the fields default
<a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> or <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> implementations.</p>
<p>It expects <code>encode</code> and <code>decode</code> function to be defined in the path being
specified.</p>
<br>
<h6 id="basic-example"><a class="doc-anchor" href="#basic-example">§</a>Basic example</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>example {
    <span class="kw">use </span>musli::{Decode, Encode};

    <span class="attr">#[derive(Decode, Encode)]
    </span><span class="kw">struct </span>Container {
        <span class="attr">#[musli(with = <span class="self">self</span>::module)]
        </span>field: Field,
    }

    <span class="kw">struct </span>Field {
        <span class="comment">/* internal */
    </span>}

    <span class="kw">mod </span>module {
        <span class="kw">use </span>musli::{Decoder, Encoder};

        <span class="kw">use </span><span class="kw">super</span>::Field;

        <span class="kw">pub fn </span>encode&lt;E&gt;(field: <span class="kw-2">&amp;</span>Field, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;(), E::Error&gt;
        <span class="kw">where
            </span>E: Encoder,
        {
            <span class="macro">todo!</span>()
        }

        <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D&gt;(decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;Field, D::Error&gt;
        <span class="kw">where
            </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
        {
            <span class="macro">todo!</span>()
        }
    }
}</code></pre></div>
<br>
<h6 id="generic-implementation"><a class="doc-anchor" href="#generic-implementation">§</a>Generic implementation</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>example {
    <span class="kw">use </span>musli::{Decode, Encode};

    <span class="attr">#[derive(Decode, Encode)]
    </span><span class="kw">struct </span>Container {
        <span class="attr">#[musli(with = <span class="self">self</span>::module)]
        </span>field: Field&lt;u32&gt;,
    }

    <span class="kw">struct </span>Field&lt;T&gt; {
        value: T,
    }

    <span class="kw">mod </span>module {
        <span class="kw">use </span>musli::{Decoder, Encoder};

        <span class="kw">use </span><span class="kw">super</span>::Field;

        <span class="kw">pub fn </span>encode&lt;E, T&gt;(field: <span class="kw-2">&amp;</span>Field&lt;T&gt;, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;(), E::Error&gt;
        <span class="kw">where
            </span>E: Encoder,
        {
            <span class="macro">todo!</span>()
        }

        <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D, T&gt;(decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;Field&lt;T&gt;, D::Error&gt;
        <span class="kw">where
            </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
        {
            <span class="macro">todo!</span>()
        }
    }
}</code></pre></div>
<br>
<h6 id="more-complete-example"><a class="doc-anchor" href="#more-complete-example">§</a>More complete example</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>example {
    <span class="kw">use </span>std::collections::HashSet;
    <span class="kw">use </span>musli::{Encode, Decode};

    <span class="kw">pub struct </span>CustomUuid(u128);

    <span class="attr">#[derive(Encode, Decode)]
    </span><span class="kw">struct </span>Struct {
        <span class="attr">#[musli(with = <span class="self">self</span>::custom_uuid)]
        </span>id: CustomUuid,
        <span class="attr">#[musli(with = <span class="self">self</span>::custom_set)]
        </span>numbers: HashSet&lt;u32&gt;,
    }

    <span class="kw">mod </span>custom_uuid {
        <span class="kw">use </span>musli::{Context, Decode, Decoder, Encode, Encoder};

        <span class="kw">use </span><span class="kw">super</span>::CustomUuid;

        <span class="kw">pub fn </span>encode&lt;E&gt;(uuid: <span class="kw-2">&amp;</span>CustomUuid, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;(), E::Error&gt;
        <span class="kw">where
            </span>E: Encoder,
        {
            uuid.<span class="number">0</span>.encode(encoder)
        }

        <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D&gt;(decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;CustomUuid, D::Error&gt;
        <span class="kw">where
            </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
        {
            <span class="prelude-val">Ok</span>(CustomUuid(decoder.decode()<span class="question-mark">?</span>))
        }
    }

    <span class="kw">mod </span>custom_set {
        <span class="kw">use </span>std::collections::HashSet;
        <span class="kw">use </span>std::hash::Hash;

        <span class="kw">use </span>musli::{Context, Decode, Decoder, Encode, Encoder};

        <span class="kw">pub fn </span>encode&lt;E, T&gt;(set: <span class="kw-2">&amp;</span>HashSet&lt;T&gt;, encoder: E) -&gt; <span class="prelude-ty">Result</span>&lt;(), E::Error&gt;
        <span class="kw">where
            </span>E: Encoder,
            T: Encode&lt;E::Mode&gt; + Eq + Hash,
        {
            encoder.encode(set)
        }

        <span class="kw">pub fn </span>decode&lt;<span class="lifetime">'de</span>, D, T&gt;(decoder: D) -&gt; <span class="prelude-ty">Result</span>&lt;HashSet&lt;T&gt;, D::Error&gt;
        <span class="kw">where
            </span>D: Decoder&lt;<span class="lifetime">'de</span>&gt;,
            T: Decode&lt;<span class="lifetime">'de</span>, D::Mode, D::Allocator&gt; + Eq + Hash,
        {
            decoder.decode()
        }
    }
}</code></pre></div>
<br>
<h5 id="musliskip_encoding_if--path"><a class="doc-anchor" href="#musliskip_encoding_if--path">§</a><code>#[musli(skip_encoding_if = &lt;path&gt;)]</code></h5>
<p>This adds a condition to skip encoding a field entirely if the condition is
true. This is very commonly used to skip over encoding <code>Option&lt;T&gt;</code> fields.</p>
<br>
<h6 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person {
    name: String,
    <span class="attr">#[musli(skip_encoding_if = Option::is_none)]
    </span>age: <span class="prelude-ty">Option</span>&lt;u32&gt;,
}</code></pre></div>
<h5 id="muslitrace"><a class="doc-anchor" href="#muslitrace">§</a><code>#[musli(trace)]</code></h5>
<p>This causes the field to use the <a href="https://docs.rs/musli/latest/musli/trait.DecodeTrace.html"><code>DecodeTrace</code></a> / <a href="https://docs.rs/musli/latest/musli/en/trait.EncodeTrace.html"><code>EncodeTrace</code></a> when encoding
the field. This is left optional for types where enabling tracing for the field
requires extra traits to be implemented, such as <code>HashMap&lt;K, V&gt;</code> where we’d need
<code>K</code> to implement <code>fmt::Display</code>.</p>
<p>Without using the <code>trace</code> attribute below, the keys in the <code>values</code> field would
not be instrumented, so with a decoding error you’d see this:</p>
<div class="example-wrap"><pre class="language-text"><code>.values: not numeric (at bytes 15-16)</code></pre></div>
<p>Instead of this (where <code>#[musli(trace)]</code> is enabled):</p>
<div class="example-wrap"><pre class="language-text"><code>.values[Hello]: not numeric (at bytes 15-16)</code></pre></div><br>
<h6 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::HashMap;

<span class="kw">use </span>musli::{Encode, Decode};

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Collection {
    <span class="attr">#[musli(trace)]
    </span>values: HashMap&lt;String, u32&gt;,
}</code></pre></div>
<br>
<h3 id="modes"><a class="doc-anchor" href="#modes">§</a>Modes</h3>
<p>If you’ve paid close attention to the <a href="https://docs.rs/musli/latest/musli/trait.Encode.html"><code>Encode</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decode.html"><code>Decode</code></a> traits you might
notive that they have an extra parameter called <code>M</code>. This stands for “mode”.</p>
<p>This parameter allows us to have different implementations of these traits for
the same type.</p>
<p>By default we implement two special modes, which each have subtly different
default behaviors:</p>
<ul>
<li><a href="https://docs.rs/musli/latest/musli/mode/enum.Binary.html"><code>Binary</code></a> and any other custom mode uses indexed fields, the equivalent of
<code>#[musli(name(type = usize))]</code>.</li>
<li><a href="https://docs.rs/musli/latest/musli/mode/enum.Text.html"><code>Text</code></a> uses literal text fields by their name, the equivalent of
<code>#[musli(name(type = str))]</code>.</li>
</ul>
<p>When it comes to deriving these traits you can scope attributes to apply to any
mode including custom local ones. This is done using the <code>#[musli(mode = ..)]</code>
meta attribute like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>musli::{Encode, Decode};
<span class="kw">use </span>musli::mode::Binary;
<span class="kw">use </span>musli::json::Encoding;

<span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">struct </span>Person&lt;<span class="lifetime">'a</span>&gt; {
    <span class="attr">#[musli(Text, name = <span class="string">"name"</span>)]
    </span>not_name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    age: u32,
}

<span class="kw">const </span>TEXT: Encoding = Encoding::new();
<span class="kw">const </span>BINARY: Encoding&lt;Binary&gt; = Encoding::new().with_mode();

<span class="kw">let </span>named = TEXT.to_vec(<span class="kw-2">&amp;</span>Person { not_name: <span class="string">"Aristotle"</span>, age: <span class="number">61 </span>})<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(named.as_slice(), <span class="string">br#"{"name":"Aristotle","age":61}"#</span>);

<span class="kw">let </span>indexed = BINARY.to_vec(<span class="kw-2">&amp;</span>Person { not_name: <span class="string">"Plato"</span>, age: <span class="number">84 </span>})<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(indexed.as_slice(), <span class="string">br#"{"0":"Plato","1":84}"#</span>);
<span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, musli::json::Error&gt;(())</code></pre></div>
<p>So the <code>#[musli(mode)]</code> atttribute is supported in any position. And any of its
sibling attributes will be added to the given <em>alternative</em> mode, rather the
<a href="https://docs.rs/musli/latest/musli/mode/enum.Binary.html">default mode</a>.</p>
<br>
<h3 id="enum-representations"><a class="doc-anchor" href="#enum-representations">§</a>Enum representations</h3>
<p>Müsli supports the following enum representations, which mimics the ones
supported by <em>serde</em>:</p>
<ul>
<li>Externally tagged (<em>default</em>).</li>
<li>Internally tagged when <code>#[musli(tag = ..)]</code> is specified on the enum.</li>
<li>Adjacently tagged when both <code>#[musli(tag = ..)]</code> and <code>#[musli(content)]</code> are
specified.</li>
</ul>
<br>
<h4 id="externally-tagged"><a class="doc-anchor" href="#externally-tagged">§</a>Externally tagged</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Encode, Decode)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}</code></pre></div>
<p>When an enum is externally tagged it is represented by a single field indicating
the variant of the enum.</p>
<div class="example-wrap"><pre class="language-json"><code>{&quot;Request&quot;: {&quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}}</code></pre></div>
<p>This is the most portable representation and is supported by most formats. It
has special support in the <a href="https://docs.rs/musli/latest/musli/trait.Encoder.html"><code>Encoder</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decoder.html"><code>Decoder</code></a> traits through
<a href="https://docs.rs/musli/latest/musli/trait.Encoder.html#method.encode_variant"><code>Encoder::encode_variant</code></a> and <a href="https://docs.rs/musli/latest/musli/trait.Decoder.html#method.decode_variant"><code>Decoder::decode_variant</code></a>.</p>
<p>Conceptually this can be considered as a “pair”, where the variant tag can be
extracted from the format before the variant is decoded.</p>
<br>
<h4 id="internally-tagged"><a class="doc-anchor" href="#internally-tagged">§</a>Internally tagged</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Encode, Decode)]
#[musli(tag = <span class="string">"type"</span>)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}</code></pre></div>
<p>In JSON, the <code>Message::Request</code> would be represented as:</p>
<div class="example-wrap"><pre class="language-json"><code>{&quot;type&quot;: &quot;Request&quot;, &quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}</code></pre></div>
<p>This is only supported by formats which are <em>self descriptive</em>, which is a
requirement for the format to be buffered through <a href="https://docs.rs/musli/latest/musli/trait.Decoder.html#method.decode_buffer"><code>Decoder::decode_buffer</code></a>.</p>
<p>It is necessary to buffer the value, since we need to inspect the fields of a
map for the field corresponding to the <code>tag</code>, and then use this to determine
which decoder implementation to call.</p>
<br>
<h4 id="adjacently-tagged"><a class="doc-anchor" href="#adjacently-tagged">§</a>Adjacently tagged</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Encode, Decode)]
#[musli(tag = <span class="string">"type"</span>, content = <span class="string">"data"</span>)]
</span><span class="kw">enum </span>Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}</code></pre></div>
<p>In JSON, the <code>Message::Request</code> would be represented as:</p>
<div class="example-wrap"><pre class="language-json"><code>{&quot;type&quot;: &quot;Request&quot;, &quot;data&quot;: {&quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}}</code></pre></div>
<p>This is only supported by formats which are <em>self descriptive</em>, which is a
requirement for the format to be buffered through <a href="https://docs.rs/musli/latest/musli/trait.Decoder.html#method.decode_buffer"><code>Decoder::decode_buffer</code></a>.</p>
<p>It is necessary to buffer the value, since we need to inspect the fields of a
map for the field corresponding to the <code>tag</code>, and then use this to determine
which decoder implementation to call.</p>
</div></details></section></div></main></body></html>