window.INDEX = [["rune.module.html","::rune","module",""],["rune/nbodies.module.html","::rune::nbodies","module",""],["rune/nbodies/offset_momentum.fn.html","::rune::nbodies::offset_momentum","function",""],["rune/nbodies/nbodies_validate.fn.html","::rune::nbodies::nbodies_validate","function",""],["rune/nbodies/nbodies.fn.html","::rune::nbodies::nbodies","function",""],["rune/nbodies/energy.fn.html","::rune::nbodies::energy","function",""],["rune/nbodies/bodies.fn.html","::rune::nbodies::bodies","function",""],["rune/nbodies/advance.fn.html","::rune::nbodies::advance","function",""],["rune/basics.module.html","::rune::basics","module",""],["rune/basics/stack_allocations.fn.html","::rune::basics::stack_allocations","function",""],["rune/basics/local_assignments.fn.html","::rune::basics::local_assignments","function",""],["rune/basics/instance.fn.html","::rune::basics::instance","function",""],["rune/basics/generator.fn.html","::rune::basics::generator","function",""],["rune/basics/call_function.fn.html","::rune::basics::call_function","function",""],["rune/flow_control.module.html","::rune::flow_control","module",""],["rune/flow_control/test_flow_control.fn.html","::rune::flow_control::test_flow_control","function",""],["rune/flow_control/test3.fn.html","::rune::flow_control::test3","function",""],["rune/flow_control/test2.fn.html","::rune::flow_control::test2","function",""],["rune/flow_control/test.fn.html","::rune::flow_control::test","function",""],["rune/flow_control/returns_unit.fn.html","::rune::flow_control::returns_unit","function",""],["rune/flow_control/returns_string.fn.html","::rune::flow_control::returns_string","function",""],["rune/flow_control/from_loop.fn.html","::rune::flow_control::from_loop","function",""],["rune/ifs.module.html","::rune::ifs","module",""],["rune/ifs/test_if_else.fn.html","::rune::ifs::test_if_else","function",""],["rune/ifs/test_control_flow.fn.html","::rune::ifs::test_control_flow","function",""],["rune/for_loops.module.html","::rune::for_loops","module",""],["rune/for_loops/for_shadow_simple.fn.html","::rune::for_loops::for_shadow_simple","function",""],["rune/for_loops/for_shadow_local_range.fn.html","::rune::for_loops::for_shadow_local_range","function",""],["rune/for_loops/for_shadow_local.fn.html","::rune::for_loops::for_shadow_local","function",""],["rune/for_loops/for_return_iter.fn.html","::rune::for_loops::for_return_iter","function",""],["rune/for_loops/for_return_inside.fn.html","::rune::for_loops::for_return_inside","function",""],["rune/for_loops/for_loop_condition_break.fn.html","::rune::for_loops::for_loop_condition_break","function",""],["rune/for_loops/for_loop_accumulate.fn.html","::rune::for_loops::for_loop_accumulate","function",""],["rune/linked_list.module.html","::rune::linked_list","module",""],["rune/linked_list/test_linked_list.fn.html","::rune::linked_list::test_linked_list","function",""],["rune/linked_list/Node.struct.html","::rune::linked_list::Node","struct","<div class=\"docs\"><p>A single node in the linked list.</p></div>"],["rune/linked_list/List.struct.html","::rune::linked_list::List","struct","<div class=\"docs\"><p>The linked list.</p></div>"],["rune/linked_list/Iter.struct.html","::rune::linked_list::Iter","struct",""],["rune/linked_list/Empty.struct.html","::rune::linked_list::Empty","struct","<div class=\"docs\"><p>An empty placeholder in a node.</p></div>"],["rune/types.module.html","::rune::types","module",""],["rune/types/types.fn.html","::rune::types::types","function",""],["rune/modules_inline.module.html","::rune::modules_inline","module",""],["rune/modules_inline/inline_modules.fn.html","::rune::modules_inline::inline_modules","function",""],["rune/modules_inline/foo.module.html","::rune::modules_inline::foo","module",""],["rune/modules_inline/foo/number.fn.html","::rune::modules_inline::foo::number","function",""],["rune/modules_inline/bar.module.html","::rune::modules_inline::bar","module",""],["rune/modules_inline/bar/number.fn.html","::rune::modules_inline::bar::number","function",""],["rune/closures.module.html","::rune::closures","module",""],["rune/closures/work.fn.html","::rune::closures::work","function",""],["rune/closures/test_lowering.fn.html","::rune::closures::test_lowering","function",""],["rune/closures/test_basic_closure.fn.html","::rune::closures::test_basic_closure","function",""],["rune/modules_vis.module.html","::rune::modules_vis","module",""],["rune/modules_vis/second.module.html","::rune::modules_vis::second","module",""],["rune/modules_vis/second/number.fn.html","::rune::modules_vis::second::number","function",""],["rune/modules_vis/number.fn.html","::rune::modules_vis::number","function",""],["rune/modules_vis/item_keywords.fn.html","::rune::modules_vis::item_keywords","function",""],["rune/modules_vis/first.module.html","::rune::modules_vis::first","module",""],["rune/modules_vis/first/number.fn.html","::rune::modules_vis::first::number","function",""],["rune/assign.module.html","::rune::assign","module",""],["rune/assign/inline_assign.fn.html","::rune::assign::inline_assign","function",""],["rune/streams.module.html","::rune::streams","module","<div class=\"docs\"><p>Test that async streams work.</p></div>"],["rune/streams/select_streams.fn.html","::rune::streams::select_streams","function","<div class=\"docs\"><p>Select over two async streams and ensure that the expected numerical value</p></div>"],["rune/streams/foo.fn.html","::rune::streams::foo","function",""],["rune/loops.module.html","::rune::loops","module",""],["rune/loops/loop_break_without_value.fn.html","::rune::loops::loop_break_without_value","function",""],["rune/loops/loop_break_without_label.fn.html","::rune::loops::loop_break_without_label","function",""],["rune/loops/loop_break_value.fn.html","::rune::loops::loop_break_value","function",""],["rune/select.module.html","::rune::select","module",""],["rune/select/select_with_defaults.fn.html","::rune::select::select_with_defaults","function",""],["rune/select/select_branches.fn.html","::rune::select::select_branches","function",""],["rune/select/foo.fn.html","::rune::select::foo","function",""],["rune/iter.module.html","::rune::iter","module",""],["rune/iter/iterator_drop.fn.html","::rune::iter::iterator_drop","function",""],["rune/generators.module.html","::rune::generators","module",""],["rune/generators/test_generators.fn.html","::rune::generators::test_generators","function",""],["rune/generators/count_numbers.fn.html","::rune::generators::count_numbers","function",""],["rune/blocks.module.html","::rune::blocks","module",""],["rune/blocks/block_inner_break2.fn.html","::rune::blocks::block_inner_break2","function",""],["rune/blocks/block_inner_break.fn.html","::rune::blocks::block_inner_break","function",""],["rune/blocks/block_break.fn.html","::rune::blocks::block_break","function",""],["rune/function_pointers.module.html","::rune::function_pointers","module",""],["rune/function_pointers/test_function_pointer.fn.html","::rune::function_pointers::test_function_pointer","function",""],["rune/function_pointers/sub.fn.html","::rune::function_pointers::sub","function",""],["rune/function_pointers/do_thing.fn.html","::rune::function_pointers::do_thing","function",""],["rune/function_pointers/add.fn.html","::rune::function_pointers::add","function",""],["examples.module.html","::examples","module",""],["examples/test.module.html","::examples::test","module",""],["examples/test/module.module.html","::examples::test::module","module",""],["examples/test/module/test.fn.html","::examples::test::module::test","function",""],["examples/test/main.fn.html","::examples::test::main","function",""],["examples/module.module.html","::examples::module","module",""],["examples/module/test.fn.html","::examples::module::test","function",""],["process.module.html","::process","module",""],["process/Output.struct.html","::process::Output","struct",""],["process/ExitStatus.struct.html","::process::ExitStatus","struct",""],["process/ExitStatus.struct.html#method.code","::process::ExitStatus::code","method",""],["process/Command.struct.html","::process::Command","struct",""],["process/Command.struct.html#method.new","::process::Command::new","method","<div class=\"docs\"><p>Construct a new command.</p></div>"],["process/Command.struct.html#method.spawn","::process::Command::spawn","method","<div class=\"docs\"><p>Spawn the command.</p></div>"],["process/Command.struct.html#method.arg","::process::Command::arg","method","<div class=\"docs\"><p>Add an argument.</p></div>"],["process/Command.struct.html#method.args","::process::Command::args","method","<div class=\"docs\"><p>Add arguments.</p></div>"],["process/Child.struct.html","::process::Child","struct",""],["process/Child.struct.html#method.wait_with_output","::process::Child::wait_with_output","method",""],["rand.module.html","::rand","module",""],["rand/int_range.fn.html","::rand::int_range","function",""],["rand/int.fn.html","::rand::int","function",""],["rand/WyRand.struct.html","::rand::WyRand","struct",""],["rand/WyRand.struct.html#method.new","::rand::WyRand::new","method",""],["rand/WyRand.struct.html#method.new_seed","::rand::WyRand::new_seed","method",""],["rand/WyRand.struct.html#method.int","::rand::WyRand::int","method",""],["rand/WyRand.struct.html#method.int_range","::rand::WyRand::int_range","method",""],["rand/Pcg64.struct.html","::rand::Pcg64","struct",""],["rand/Pcg64.struct.html#method.new","::rand::Pcg64::new","method",""],["rand/Pcg64.struct.html#method.new_seed","::rand::Pcg64::new_seed","method",""],["rand/Pcg64.struct.html#method.int","::rand::Pcg64::int","method",""],["rand/Pcg64.struct.html#method.int_range","::rand::Pcg64::int_range","method",""],["toml.module.html","::toml","module",""],["toml/to_string.fn.html","::toml::to_string","function","<div class=\"docs\"><p>Convert any value to a toml string.</p></div>"],["toml/to_bytes.fn.html","::toml::to_bytes","function","<div class=\"docs\"><p>Convert any value to toml bytes.</p></div>"],["toml/ser.module.html","::toml::ser","module",""],["toml/ser/Error.struct.html","::toml::ser::Error","struct",""],["toml/from_string.fn.html","::toml::from_string","function","<div class=\"docs\"><p>Convert a string of TOML into a rune value.</p></div>"],["toml/from_bytes.fn.html","::toml::from_bytes","function","<div class=\"docs\"><p>Convert bytes of TOML into a rune value.</p></div>"],["toml/de.module.html","::toml::de","module",""],["toml/de/Error.struct.html","::toml::de::Error","struct",""],["fs.module.html","::fs","module",""],["fs/read_to_string.fn.html","::fs::read_to_string","function",""],["time.module.html","::time","module",""],["time/sleep.fn.html","::time::sleep","function","<div class=\"docs\"><p>Sleep for the given <a href=\"Duration.struct.html\" title=\"struct Duration\"><code>Duration</code></a>.</p></div>"],["time/Duration.struct.html","::time::Duration","struct",""],["time/Duration.struct.html#method.from_secs","::time::Duration::from_secs","method","<div class=\"docs\"><p>Construct a duration from the given number of seconds.</p></div>"],["std.module.html","::std","module","<div class=\"docs\"><p>Core types and methods in Rune.</p></div>"],["std/vec.module.html","::std::vec","module","<div class=\"docs\"><p>The <a href=\"vec/Vec.struct.html\" title=\"struct Vec\"><code>Vec</code></a> dynamic vector.</p></div>"],["std/vec/Vec.struct.html","::std::vec::Vec","struct","<div class=\"docs\"><p>A dynamic vector.</p></div>"],["std/vec/Vec.struct.html#method.new","::std::vec::Vec::new","method","<div class=\"docs\"><p>Constructs a new, empty dynamic <code>Vec</code>.</p></div>"],["std/vec/Vec.struct.html#method.with_capacity","::std::vec::Vec::with_capacity","method","<div class=\"docs\"><p>Constructs a new, empty dynamic <code>Vec</code> with at least the specified capacity.</p></div>"],["std/vec/Vec.struct.html#method.len","::std::vec::Vec::len","method","<div class=\"docs\"><p>Returns the number of elements in the vector, also referred to as its</p></div>"],["std/vec/Vec.struct.html#method.is_empty","::std::vec::Vec::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the vector contains no elements.</p></div>"],["std/vec/Vec.struct.html#method.capacity","::std::vec::Vec::capacity","method","<div class=\"docs\"><p>Returns the total number of elements the vector can hold without</p></div>"],["std/vec/Vec.struct.html#method.get","::std::vec::Vec::get","method","<div class=\"docs\"><p>Returns a reference to an element or subslice depending on the type of</p></div>"],["std/vec/Vec.struct.html#method.clear","::std::vec::Vec::clear","method","<div class=\"docs\"><p>Clears the vector, removing all values.</p></div>"],["std/vec/Vec.struct.html#method.extend","::std::vec::Vec::extend","method","<div class=\"docs\"><p>Extend these bytes with another collection.</p></div>"],["std/vec/Vec.struct.html#method.iter","::std::vec::Vec::iter","method","<div class=\"docs\"><p>Iterate over the vector.</p></div>"],["std/vec/Vec.struct.html#method.pop","::std::vec::Vec::pop","method","<div class=\"docs\"><p>Removes the last element from a vector and returns it, or [<code>None</code>] if it is</p></div>"],["std/vec/Vec.struct.html#method.push","::std::vec::Vec::push","method","<div class=\"docs\"><p>Appends an element to the back of a collection.</p></div>"],["std/vec/Vec.struct.html#method.remove","::std::vec::Vec::remove","method","<div class=\"docs\"><p>Removes and returns the element at position <code>index</code> within the vector,</p></div>"],["std/vec/Vec.struct.html#method.insert","::std::vec::Vec::insert","method","<div class=\"docs\"><p>Inserts an element at position <code>index</code> within the vector, shifting all</p></div>"],["std/vec/Vec.struct.html#method.sort_by","::std::vec::Vec::sort_by","method","<div class=\"docs\"><p>Sort a vector by the specified comparator function.</p></div>"],["std/vec/Vec.struct.html#method.sort","::std::vec::Vec::sort","method","<div class=\"docs\"><p>Sort the vector.</p></div>"],["std/vec/Vec.struct.html#method.resize","::std::vec::Vec::resize","method","<div class=\"docs\"><p>Resizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p></div>"],["std/u8.type.html","::std::u8","type","<div class=\"docs\"><p>The primitive byte type.</p></div>"],["std/tuple.module.html","::std::tuple","module","<div class=\"docs\"><p>The <a href=\"tuple/Tuple.struct.html\" title=\"struct Tuple\"><code>Tuple</code></a> fixed collection.</p></div>"],["std/tuple/Tuple.struct.html","::std::tuple::Tuple","struct","<div class=\"docs\"><p>The tuple type.</p></div>"],["std/tuple/Tuple.struct.html#method.len","::std::tuple::Tuple::len","method","<div class=\"docs\"><p>Returns the number of elements in the tuple.</p></div>"],["std/tuple/Tuple.struct.html#method.is_empty","::std::tuple::Tuple::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the tuple has a length of 0.</p></div>"],["std/tuple/Tuple.struct.html#method.get","::std::tuple::Tuple::get","method","<div class=\"docs\"><p>Returns a reference to an element or subslice depending on the type of</p></div>"],["std/tuple/Tuple.struct.html#method.iter","::std::tuple::Tuple::iter","method","<div class=\"docs\"><p>Construct an iterator over the tuple.</p></div>"],["std/test.module.html","::std::test","module","<div class=\"docs\"><p>Testing and benchmarking.</p></div>"],["std/test/assert_ne.macro.html","::std::test::assert_ne","macro","<div class=\"docs\"><p>Assert that the two arguments provided are not equal, or cause a vm panic.</p></div>"],["std/test/assert_eq.macro.html","::std::test::assert_eq","macro","<div class=\"docs\"><p>Assert that the two arguments provided are equal, or cause a vm panic.</p></div>"],["std/test/assert.macro.html","::std::test::assert","macro","<div class=\"docs\"><p>Assert that the expression provided as an argument is true, or cause a vm</p></div>"],["std/test/Bencher.struct.html","::std::test::Bencher","struct","<div class=\"docs\"><p>A type to perform benchmarks.</p></div>"],["std/test/Bencher.struct.html#method.iter","::std::test::Bencher::iter","method","<div class=\"docs\"><p>Run a benchmark using the given closure.</p></div>"],["std/stringify.macro.html","::std::stringify","macro","<div class=\"docs\"><p>Stringify the given argument, causing it to expand to its underlying token</p></div>"],["std/string.module.html","::std::string","module","<div class=\"docs\"><p>Strings.</p></div>"],["std/string/String.type.html","::std::string::String","type",""],["std/string/String.type.html#method.from","::std::string::String::from","method","<div class=\"docs\"><p>Constructs a string from another string.</p></div>"],["std/string/String.type.html#method.from_str","::std::string::String::from_str","method",""],["std/string/String.type.html#method.new","::std::string::String::new","method","<div class=\"docs\"><p>Creates a new empty <code>String</code>.</p></div>"],["std/string/String.type.html#method.with_capacity","::std::string::String::with_capacity","method","<div class=\"docs\"><p>Creates a new empty <code>String</code> with at least the specified capacity.</p></div>"],["std/string/String.type.html#method.cmp","::std::string::String::cmp","method",""],["std/string/String.type.html#method.len","::std::string::String::len","method","<div class=\"docs\"><p>Returns the length of <code>self</code>.</p></div>"],["std/string/String.type.html#method.starts_with","::std::string::String::starts_with","method","<div class=\"docs\"><p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p></div>"],["std/string/String.type.html#method.ends_with","::std::string::String::ends_with","method","<div class=\"docs\"><p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p></div>"],["std/string/String.type.html#method.capacity","::std::string::String::capacity","method","<div class=\"docs\"><p>Returns this <code>String</code>'s capacity, in bytes.</p></div>"],["std/string/String.type.html#method.clear","::std::string::String::clear","method","<div class=\"docs\"><p>Truncates this <code>String</code>, removing all contents.</p></div>"],["std/string/String.type.html#method.contains","::std::string::String::contains","method","<div class=\"docs\"><p>Returns <code>true</code> if the given pattern matches a sub-slice of this string</p></div>"],["std/string/String.type.html#method.push","::std::string::String::push","method","<div class=\"docs\"><p>Appends the given [<code>char</code>] to the end of this <code>String</code>.</p></div>"],["std/string/String.type.html#method.push_str","::std::string::String::push_str","method","<div class=\"docs\"><p>Appends a given string slice onto the end of this <code>String</code>.</p></div>"],["std/string/String.type.html#method.reserve","::std::string::String::reserve","method","<div class=\"docs\"><p>Reserves capacity for at least <code>additional</code> bytes more than the current</p></div>"],["std/string/String.type.html#method.reserve_exact","::std::string::String::reserve_exact","method","<div class=\"docs\"><p>Reserves the minimum capacity for at least <code>additional</code> bytes more than the</p></div>"],["std/string/String.type.html#method.from_utf8","::std::string::String::from_utf8","method","<div class=\"docs\"><p>Converts a vector of bytes to a <code>String</code>.</p></div>"],["std/string/String.type.html#method.as_bytes","::std::string::String::as_bytes","method","<div class=\"docs\"><p>Returns a byte slice of this <code>String</code>'s contents.</p></div>"],["std/string/String.type.html#method.into_bytes","::std::string::String::into_bytes","method","<div class=\"docs\"><p>Returns a byte slice of this <code>String</code>'s contents while moving the string.</p></div>"],["std/string/String.type.html#method.shrink_to_fit","::std::string::String::shrink_to_fit","method","<div class=\"docs\"><p>Shrinks the capacity of this <code>String</code> to match its length.</p></div>"],["std/string/String.type.html#method.char_at","::std::string::String::char_at","method","<div class=\"docs\"><p>Access the character at the given byte index.</p></div>"],["std/string/String.type.html#method.split","::std::string::String::split","method","<div class=\"docs\"><p>An iterator over substrings of this string slice, separated by</p></div>"],["std/string/String.type.html#method.split_once","::std::string::String::split_once","method","<div class=\"docs\"><p>Splits the string on the first occurrence of the specified delimiter and</p></div>"],["std/string/String.type.html#method.split_str","::std::string::String::split_str","method",""],["std/string/String.type.html#method.trim","::std::string::String::trim","method","<div class=\"docs\"><p>Returns a string slice with leading and trailing whitespace removed.</p></div>"],["std/string/String.type.html#method.trim_end","::std::string::String::trim_end","method","<div class=\"docs\"><p>Returns a string slice with trailing whitespace removed.</p></div>"],["std/string/String.type.html#method.replace","::std::string::String::replace","method","<div class=\"docs\"><p>Replaces all matches of a pattern with another string.</p></div>"],["std/string/String.type.html#method.is_empty","::std::string::String::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p></div>"],["std/string/String.type.html#method.chars","::std::string::String::chars","method","<div class=\"docs\"><p>Returns an iterator over the [<code>char</code>]s of a string slice.</p></div>"],["std/string/String.type.html#method.get","::std::string::String::get","method","<div class=\"docs\"><p>Returns a subslice of <code>str</code>.</p></div>"],["std/string/String.type.html#method.parse","::std::string::String::parse","method","<div class=\"docs\"><p>Parses this string into an integer.</p></div>"],["std/string/String.type.html#method.parse","::std::string::String::parse","method","<div class=\"docs\"><p>Parses this string into a character.</p></div>"],["std/string/String.type.html#method.to_lowercase","::std::string::String::to_lowercase","method","<div class=\"docs\"><p>Returns the lowercase equivalent of this string slice, as a new [<code>String</code>].</p></div>"],["std/string/String.type.html#method.to_uppercase","::std::string::String::to_uppercase","method","<div class=\"docs\"><p>Returns the uppercase equivalent of this string slice, as a new [<code>String</code>].</p></div>"],["std/string/Split.struct.html","::std::string::Split","struct",""],["std/string/Split.struct.html","::std::string::Split","struct",""],["std/string/Split.struct.html","::std::string::Split","struct",""],["std/string/Chars.struct.html","::std::string::Chars","struct",""],["std/stream.module.html","::std::stream","module","<div class=\"docs\"><p>Asynchronous streams.</p></div>"],["std/stream/Stream.struct.html","::std::stream::Stream","struct","<div class=\"docs\"><p>A stream with a stored virtual machine.</p></div>"],["std/stream/Stream.struct.html#method.next","::std::stream::Stream::next","method",""],["std/stream/Stream.struct.html#method.resume","::std::stream::Stream::resume","method",""],["std/slice.module.html","::std::slice","module","<div class=\"docs\"><p>Types related to working with contiguous slices.</p></div>"],["std/slice/Iter.struct.html","::std::slice::Iter","struct","<div class=\"docs\"><p>An efficient reference counter iterator over a vector.</p></div>"],["std/result.module.html","::std::result","module","<div class=\"docs\"><p>The <a href=\"result/Result.enum.html\" title=\"enum Result\"><code>Result</code></a> type.</p></div>"],["std/result/Result.enum.html","::std::result::Result","enum","<div class=\"docs\"><p>Result is a type that represents either success (Ok) or failure (Err).</p></div>"],["std/result/Result.enum.html#method.ok","::std::result::Result::ok","method","<div class=\"docs\"><p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.</p></div>"],["std/result/Result.enum.html#method.is_ok","::std::result::Result::is_ok","method","<div class=\"docs\"><p>Returns <code>true</code> if the result is [<code>Ok</code>].</p></div>"],["std/result/Result.enum.html#method.is_err","::std::result::Result::is_err","method","<div class=\"docs\"><p>Returns <code>true</code> if the result is [<code>Err</code>].</p></div>"],["std/result/Result.enum.html#method.unwrap","::std::result::Result::unwrap","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value, consuming the <code>self</code> value.</p></div>"],["std/result/Result.enum.html#method.unwrap_or","::std::result::Result::unwrap_or","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value or a provided default.</p></div>"],["std/result/Result.enum.html#method.unwrap_or_else","::std::result::Result::unwrap_or_else","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value or computes it from a closure.</p></div>"],["std/result/Result.enum.html#method.expect","::std::result::Result::expect","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value, consuming the <code>self</code> value.</p></div>"],["std/result/Result.enum.html#method.and_then","::std::result::Result::and_then","method","<div class=\"docs\"><p>Calls <code>op</code> if the result is [<code>Ok</code>], otherwise returns the [<code>Err</code>] value of <code>self</code>.</p></div>"],["std/result/Result.enum.html#method.map","::std::result::Result::map","method","<div class=\"docs\"><p>Maps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code> by applying a function to a</p></div>"],["std/result/Result.enum.html#variant.Ok","::std::result::Result::Ok","variant","<div class=\"docs\"><p>Contains the success value</p></div>"],["std/result/Result.enum.html#variant.Err","::std::result::Result::Err","variant","<div class=\"docs\"><p>Contains the error value</p></div>"],["std/panic.macro.html","::std::panic","macro","<div class=\"docs\"><p>Cause a vm panic with a formatted message.</p></div>"],["std/option.module.html","::std::option","module","<div class=\"docs\"><p>The <a href=\"option/Option.enum.html\" title=\"enum Option\"><code>Option</code></a> type.</p></div>"],["std/option/Option.enum.html","::std::option::Option","enum",""],["std/option/Option.enum.html#method.expect","::std::option::Option::expect","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value, consuming the <code>self</code> value.</p></div>"],["std/option/Option.enum.html#method.unwrap","::std::option::Option::unwrap","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value, consuming the <code>self</code> value.</p></div>"],["std/option/Option.enum.html#method.unwrap_or","::std::option::Option::unwrap_or","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value or a provided <code>default</code>.</p></div>"],["std/option/Option.enum.html#method.unwrap_or_else","::std::option::Option::unwrap_or_else","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value or computes it from a closure.</p></div>"],["std/option/Option.enum.html#method.is_some","::std::option::Option::is_some","method","<div class=\"docs\"><p>Returns <code>true</code> if the option is a [<code>Some</code>] value.</p></div>"],["std/option/Option.enum.html#method.is_none","::std::option::Option::is_none","method","<div class=\"docs\"><p>Returns <code>true</code> if the option is a [<code>None</code>] value.</p></div>"],["std/option/Option.enum.html#method.iter","::std::option::Option::iter","method","<div class=\"docs\"><p>Construct an iterator over an optional value.</p></div>"],["std/option/Option.enum.html#method.and_then","::std::option::Option::and_then","method","<div class=\"docs\"><p>Returns [<code>None</code>] if the option is [<code>None</code>], otherwise calls <code>f</code> with the</p></div>"],["std/option/Option.enum.html#method.map","::std::option::Option::map","method","<div class=\"docs\"><p>Maps an <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code> by applying a function to a contained</p></div>"],["std/option/Option.enum.html#method.take","::std::option::Option::take","method","<div class=\"docs\"><p>Takes the value out of the option, leaving a [<code>None</code>] in its place.</p></div>"],["std/option/Option.enum.html#method.transpose","::std::option::Option::transpose","method","<div class=\"docs\"><p>Transposes an <code>Option</code> of a [<code>Result</code>] into a [<code>Result</code>] of an <code>Option</code>.</p></div>"],["std/option/Option.enum.html#method.ok_or","::std::option::Option::ok_or","method","<div class=\"docs\"><p>Transforms the <code>Option&lt;T&gt;</code> into a [<code>Result&lt;T, E&gt;</code>], mapping [<code>Some(v)</code>] to</p></div>"],["std/option/Option.enum.html#method.ok_or_else","::std::option::Option::ok_or_else","method","<div class=\"docs\"><p>Transforms the <code>Option&lt;T&gt;</code> into a [<code>Result&lt;T, E&gt;</code>], mapping [<code>Some(v)</code>] to</p></div>"],["std/option/Option.enum.html#variant.Some","::std::option::Option::Some","variant",""],["std/option/Option.enum.html#variant.None","::std::option::Option::None","variant",""],["std/option/Iter.struct.html","::std::option::Iter","struct",""],["std/ops.module.html","::std::ops","module","<div class=\"docs\"><p>Overloadable operators and associated types.</p></div>"],["std/ops/partial_eq.fn.html","::std::ops::partial_eq","function","<div class=\"docs\"><p>Perform a partial equality check over two values.</p></div>"],["std/ops/partial_cmp.fn.html","::std::ops::partial_cmp","function","<div class=\"docs\"><p>Perform a partial comparison over two values.</p></div>"],["std/ops/hash.fn.html","::std::ops::hash","function","<div class=\"docs\"><p>Hashes the given value.</p></div>"],["std/ops/generator.module.html","::std::ops::generator","module","<div class=\"docs\"><p>Types related to generators.</p></div>"],["std/ops/generator/Iter.struct.html","::std::ops::generator::Iter","struct",""],["std/ops/generator/GeneratorState.enum.html","::std::ops::generator::GeneratorState","enum","<div class=\"docs\"><p>Enum indicating the state of a generator.</p></div>"],["std/ops/generator/GeneratorState.enum.html#variant.Complete","::std::ops::generator::GeneratorState::Complete","variant",""],["std/ops/generator/GeneratorState.enum.html#variant.Yielded","::std::ops::generator::GeneratorState::Yielded","variant",""],["std/ops/generator/Generator.struct.html","::std::ops::generator::Generator","struct","<div class=\"docs\"><p>The return value of a function producing a generator.</p></div>"],["std/ops/generator/Generator.struct.html#method.next","::std::ops::generator::Generator::next","method","<div class=\"docs\"><p>Advance a generator producing the next value yielded.</p></div>"],["std/ops/generator/Generator.struct.html#method.resume","::std::ops::generator::Generator::resume","method","<div class=\"docs\"><p>Advance a generator producing the next <a href=\"GeneratorState.enum.html\" title=\"enum GeneratorState\"><code>GeneratorState</code></a>.</p></div>"],["std/ops/generator/Generator.struct.html#method.iter","::std::ops::generator::Generator::iter","method","<div class=\"docs\"><p>Convert a generator into an iterator.</p></div>"],["std/ops/eq.fn.html","::std::ops::eq","function","<div class=\"docs\"><p>Perform a partial equality check over two values.</p></div>"],["std/ops/cmp.fn.html","::std::ops::cmp","function","<div class=\"docs\"><p>Perform a total comparison over two values.</p></div>"],["std/ops/RangeToInclusive.struct.html","::std::ops::RangeToInclusive","struct","<div class=\"docs\"><p>Type for an inclusive range expression <code>..=end</code>.</p></div>"],["std/ops/RangeToInclusive.struct.html#method.contains","::std::ops::RangeToInclusive::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeTo.struct.html","::std::ops::RangeTo","struct","<div class=\"docs\"><p>Type for an inclusive range expression <code>..end</code>.</p></div>"],["std/ops/RangeTo.struct.html#method.contains","::std::ops::RangeTo::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeIter.struct.html","::std::ops::RangeIter","struct",""],["std/ops/RangeIter.struct.html","::std::ops::RangeIter","struct",""],["std/ops/RangeIter.struct.html","::std::ops::RangeIter","struct",""],["std/ops/RangeInclusiveIter.struct.html","::std::ops::RangeInclusiveIter","struct",""],["std/ops/RangeInclusiveIter.struct.html","::std::ops::RangeInclusiveIter","struct",""],["std/ops/RangeInclusiveIter.struct.html","::std::ops::RangeInclusiveIter","struct",""],["std/ops/RangeInclusive.struct.html","::std::ops::RangeInclusive","struct","<div class=\"docs\"><p>Type for an inclusive range expression <code>start..=end</code>.</p></div>"],["std/ops/RangeInclusive.struct.html#method.iter","::std::ops::RangeInclusive::iter","method","<div class=\"docs\"><p>Iterate over the range.</p></div>"],["std/ops/RangeInclusive.struct.html#method.contains","::std::ops::RangeInclusive::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeFull.struct.html","::std::ops::RangeFull","struct","<div class=\"docs\"><p>Type for a full range expression <code>..</code>.</p></div>"],["std/ops/RangeFull.struct.html#method.contains","::std::ops::RangeFull::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeFromIter.struct.html","::std::ops::RangeFromIter","struct",""],["std/ops/RangeFromIter.struct.html","::std::ops::RangeFromIter","struct",""],["std/ops/RangeFromIter.struct.html","::std::ops::RangeFromIter","struct",""],["std/ops/RangeFrom.struct.html","::std::ops::RangeFrom","struct","<div class=\"docs\"><p>Type for a from range expression <code>start..</code>.</p></div>"],["std/ops/RangeFrom.struct.html#method.iter","::std::ops::RangeFrom::iter","method","<div class=\"docs\"><p>Iterate over the range.</p></div>"],["std/ops/RangeFrom.struct.html#method.contains","::std::ops::RangeFrom::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/Range.struct.html","::std::ops::Range","struct","<div class=\"docs\"><p>Type for a range expression <code>start..end</code>.</p></div>"],["std/ops/Range.struct.html#method.iter","::std::ops::Range::iter","method","<div class=\"docs\"><p>Iterate over the range.</p></div>"],["std/ops/Range.struct.html#method.contains","::std::ops::Range::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/Function.struct.html","::std::ops::Function","struct","<div class=\"docs\"><p>The type of a function in Rune.</p></div>"],["std/ops/ControlFlow.enum.html","::std::ops::ControlFlow","enum","<div class=\"docs\"><p>Used to tell an operation whether it should exit early or go on as usual.</p></div>"],["std/ops/ControlFlow.enum.html#variant.Continue","::std::ops::ControlFlow::Continue","variant","<div class=\"docs\"><p>Move on to the next phase of the operation as normal.</p></div>"],["std/ops/ControlFlow.enum.html#variant.Break","::std::ops::ControlFlow::Break","variant","<div class=\"docs\"><p>Exit the operation without running subsequent phases.</p></div>"],["std/object.module.html","::std::object","module","<div class=\"docs\"><p>The dynamic <a href=\"object/Object.struct.html\" title=\"struct Object\"><code>Object</code></a> container.</p></div>"],["std/object/Values.struct.html","::std::object::Values","struct",""],["std/object/Object.struct.html","::std::object::Object","struct","<div class=\"docs\"><p>Struct representing a dynamic anonymous object.</p></div>"],["std/object/Object.struct.html#method.new","::std::object::Object::new","method","<div class=\"docs\"><p>Construct a new object.</p></div>"],["std/object/Object.struct.html#method.with_capacity","::std::object::Object::with_capacity","method","<div class=\"docs\"><p>Construct a new object with the given capacity.</p></div>"],["std/object/Object.struct.html#method.len","::std::object::Object::len","method","<div class=\"docs\"><p>Returns the number of elements in the object.</p></div>"],["std/object/Object.struct.html#method.is_empty","::std::object::Object::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the object is empty.</p></div>"],["std/object/Object.struct.html#method.insert","::std::object::Object::insert","method","<div class=\"docs\"><p>Inserts a key-value pair into the map.</p></div>"],["std/object/Object.struct.html#method.remove","::std::object::Object::remove","method","<div class=\"docs\"><p>Removes a key from the map, returning the value at the key if the key was</p></div>"],["std/object/Object.struct.html#method.clear","::std::object::Object::clear","method","<div class=\"docs\"><p>Clears the object, removing all key-value pairs. Keeps the allocated</p></div>"],["std/object/Object.struct.html#method.contains_key","::std::object::Object::contains_key","method","<div class=\"docs\"><p>Returns <code>true</code> if the map contains a value for the specified key.</p></div>"],["std/object/Object.struct.html#method.get","::std::object::Object::get","method","<div class=\"docs\"><p>Returns a reference to the value corresponding to the key.</p></div>"],["std/object/Object.struct.html#method.iter","::std::object::Object::iter","method","<div class=\"docs\"><p>An iterator visiting all keys and values in arbitrary order.</p></div>"],["std/object/Object.struct.html#method.keys","::std::object::Object::keys","method","<div class=\"docs\"><p>An iterator visiting all keys in arbitrary order.</p></div>"],["std/object/Object.struct.html#method.values","::std::object::Object::values","method","<div class=\"docs\"><p>An iterator visiting all values in arbitrary order.</p></div>"],["std/object/Keys.struct.html","::std::object::Keys","struct",""],["std/object/Iter.struct.html","::std::object::Iter","struct",""],["std/num.module.html","::std::num","module","<div class=\"docs\"><p>Working with numbers.</p></div>"],["std/num/ParseIntError.type.html","::std::num::ParseIntError","type",""],["std/num/ParseFloatError.type.html","::std::num::ParseFloatError","type",""],["std/mem.module.html","::std::mem","module","<div class=\"docs\"><p>Working with memory.</p></div>"],["std/mem/snapshot.fn.html","::std::mem::snapshot","function","<div class=\"docs\"><p>Get the usage snapshot of a value.</p></div>"],["std/mem/drop.fn.html","::std::mem::drop","function","<div class=\"docs\"><p>Explicitly drop the given value, freeing up any memory associated with it.</p></div>"],["std/mem/Snapshot.struct.html","::std::mem::Snapshot","struct",""],["std/mem/Snapshot.struct.html#method.shared","::std::mem::Snapshot::shared","method","<div class=\"docs\"><p>The number of shared references to the value.</p></div>"],["std/macros.module.html","::std::macros","module","<div class=\"docs\"><p>Macro support.</p></div>"],["std/macros/builtin.module.html","::std::macros::builtin","module","<div class=\"docs\"><p>Built-in macros.</p></div>"],["std/macros/builtin/line.macro.html","::std::macros::builtin::line","macro","<div class=\"docs\"><p>Return the line in the current file.</p></div>"],["std/macros/builtin/file.macro.html","::std::macros::builtin::file","macro","<div class=\"docs\"><p>Return the name of the current file.</p></div>"],["std/iter.module.html","::std::iter","module","<div class=\"docs\"><p>Rune support for iterators.</p></div>"],["std/iter/range.fn.html","::std::iter::range","function","<div class=\"docs\"><p>Produce an iterator which starts at the range <code>start</code> and ends at the value</p></div>"],["std/iter/once.fn.html","::std::iter::once","function","<div class=\"docs\"><p>Construct an iterator which produces a single <code>value</code> once.</p></div>"],["std/iter/empty.fn.html","::std::iter::empty","function","<div class=\"docs\"><p>Construct an iterator which produces no values.</p></div>"],["std/iter/Take.struct.html","::std::iter::Take","struct",""],["std/iter/Skip.struct.html","::std::iter::Skip","struct",""],["std/iter/Rev.struct.html","::std::iter::Rev","struct",""],["std/iter/Peekable.struct.html","::std::iter::Peekable","struct",""],["std/iter/Peekable.struct.html#method.peek","::std::iter::Peekable::peek","method","<div class=\"docs\"><p>Returns a reference to the <code>next()</code> value without advancing the iterator.</p></div>"],["std/iter/Once.struct.html","::std::iter::Once","struct",""],["std/iter/Map.struct.html","::std::iter::Map","struct",""],["std/iter/Iterator.trait.html","::std::iter::Iterator","trait","<div class=\"docs\"><p>A trait for dealing with iterators.</p></div>"],["std/iter/Iterator.trait.html#method.next","::std::iter::Iterator::next","method","<div class=\"docs\"><p>Advances the iterator and returns the next value.</p></div>"],["std/iter/Iterator.trait.html#method.nth","::std::iter::Iterator::nth","method","<div class=\"docs\"><p>Returns the <code>n</code>th element of the iterator.</p></div>"],["std/iter/Iterator.trait.html#method.size_hint","::std::iter::Iterator::size_hint","method","<div class=\"docs\"><p>Returns the bounds on the remaining length of the iterator.</p></div>"],["std/iter/Iterator.trait.html#method.count","::std::iter::Iterator::count","method","<div class=\"docs\"><p>Consumes the iterator, counting the number of iterations and returning it.</p></div>"],["std/iter/Iterator.trait.html#method.fold","::std::iter::Iterator::fold","method","<div class=\"docs\"><p>Folds every element into an accumulator by applying an operation, returning</p></div>"],["std/iter/Iterator.trait.html#method.reduce","::std::iter::Iterator::reduce","method","<div class=\"docs\"><p>Reduces the elements to a single one, by repeatedly applying a reducing</p></div>"],["std/iter/Iterator.trait.html#method.find","::std::iter::Iterator::find","method","<div class=\"docs\"><p>Searches for an element of an iterator that satisfies a predicate.</p></div>"],["std/iter/Iterator.trait.html#method.any","::std::iter::Iterator::any","method","<div class=\"docs\"><p>Tests if any element of the iterator matches a predicate.</p></div>"],["std/iter/Iterator.trait.html#method.all","::std::iter::Iterator::all","method","<div class=\"docs\"><p>Tests if every element of the iterator matches a predicate.</p></div>"],["std/iter/Iterator.trait.html#method.chain","::std::iter::Iterator::chain","method","<div class=\"docs\"><p>Takes two iterators and creates a new iterator over both in sequence.</p></div>"],["std/iter/Iterator.trait.html#method.enumerate","::std::iter::Iterator::enumerate","method","<div class=\"docs\"><p>Creates an iterator which gives the current iteration count as well as</p></div>"],["std/iter/Iterator.trait.html#method.filter","::std::iter::Iterator::filter","method","<div class=\"docs\"><p>Creates an iterator which uses a closure to determine if an element</p></div>"],["std/iter/Iterator.trait.html#method.map","::std::iter::Iterator::map","method","<div class=\"docs\"><p>Takes a closure and creates an iterator which calls that closure on each</p></div>"],["std/iter/Iterator.trait.html#method.filter_map","::std::iter::Iterator::filter_map","method","<div class=\"docs\"><p>Creates an iterator that both filters and maps.</p></div>"],["std/iter/Iterator.trait.html#method.flat_map","::std::iter::Iterator::flat_map","method","<div class=\"docs\"><p>Creates an iterator that works like map, but flattens nested structure.</p></div>"],["std/iter/Iterator.trait.html#method.peekable","::std::iter::Iterator::peekable","method","<div class=\"docs\"><p>Creates an iterator which can use the [<code>peek</code>] method to look at the next</p></div>"],["std/iter/Iterator.trait.html#method.skip","::std::iter::Iterator::skip","method","<div class=\"docs\"><p>Creates an iterator that skips the first <code>n</code> elements.</p></div>"],["std/iter/Iterator.trait.html#method.take","::std::iter::Iterator::take","method","<div class=\"docs\"><p>Creates an iterator that yields the first <code>n</code> elements, or fewer if the</p></div>"],["std/iter/Iterator.trait.html#method.sum","::std::iter::Iterator::sum","method","<div class=\"docs\"><p>Sums the elements of an iterator.</p></div>"],["std/iter/Iterator.trait.html#method.sum","::std::iter::Iterator::sum","method","<div class=\"docs\"><p>Sums the elements of an iterator.</p></div>"],["std/iter/Iterator.trait.html#method.sum","::std::iter::Iterator::sum","method","<div class=\"docs\"><p>Sums the elements of an iterator.</p></div>"],["std/iter/Iterator.trait.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>Vec</code>].</p></div>"],["std/iter/Iterator.trait.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>VecDeque</code>].</p></div>"],["std/iter/Iterator.trait.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>HashSet</code>].</p></div>"],["std/iter/Iterator.trait.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>HashMap</code>].</p></div>"],["std/iter/Iterator.trait.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as an [<code>Object</code>].</p></div>"],["std/iter/Iterator.trait.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>Tuple</code>].</p></div>"],["std/iter/Iterator.trait.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>String</code>].</p></div>"],["std/iter/Iterator.trait.html#method.product","::std::iter::Iterator::product","method","<div class=\"docs\"><p>Iterates over the entire iterator, multiplying all the elements</p></div>"],["std/iter/Iterator.trait.html#method.product","::std::iter::Iterator::product","method","<div class=\"docs\"><p>Iterates over the entire iterator, multiplying all the elements</p></div>"],["std/iter/Iterator.trait.html#method.product","::std::iter::Iterator::product","method","<div class=\"docs\"><p>Iterates over the entire iterator, multiplying all the elements</p></div>"],["std/iter/FlatMap.struct.html","::std::iter::FlatMap","struct",""],["std/iter/FilterMap.struct.html","::std::iter::FilterMap","struct",""],["std/iter/Filter.struct.html","::std::iter::Filter","struct",""],["std/iter/ExactSizeIterator.trait.html","::std::iter::ExactSizeIterator","trait","<div class=\"docs\"><p>An iterator that knows its exact length.</p></div>"],["std/iter/ExactSizeIterator.trait.html#method.len","::std::iter::ExactSizeIterator::len","method","<div class=\"docs\"><p>Returns the exact remaining length of the iterator.</p></div>"],["std/iter/Enumerate.struct.html","::std::iter::Enumerate","struct",""],["std/iter/Empty.struct.html","::std::iter::Empty","struct",""],["std/iter/DoubleEndedIterator.trait.html","::std::iter::DoubleEndedIterator","trait","<div class=\"docs\"><p>An iterator able to yield elements from both ends.</p></div>"],["std/iter/DoubleEndedIterator.trait.html#method.next_back","::std::iter::DoubleEndedIterator::next_back","method","<div class=\"docs\"><p>Removes and returns an element from the end of the iterator.</p></div>"],["std/iter/DoubleEndedIterator.trait.html#method.rev","::std::iter::DoubleEndedIterator::rev","method","<div class=\"docs\"><p>Reverses an iterator's direction.</p></div>"],["std/iter/Chain.struct.html","::std::iter::Chain","struct",""],["std/is_writable.fn.html","::std::is_writable","function","<div class=\"docs\"><p>Test if the given <code>value</code> is writable.</p></div>"],["std/is_readable.fn.html","::std::is_readable","function","<div class=\"docs\"><p>Test if the given <code>value</code> is readable.</p></div>"],["std/io.module.html","::std::io","module","<div class=\"docs\"><p>The std::io module contains a number of common things</p></div>"],["std/io/println.macro.html","::std::io::println","macro","<div class=\"docs\"><p>Prints to output, with a newline.</p></div>"],["std/io/print.macro.html","::std::io::print","macro","<div class=\"docs\"><p>Prints to output.</p></div>"],["std/io/dbg.macro.html","::std::io::dbg","macro","<div class=\"docs\"><p>Debug print the given argument.</p></div>"],["std/io/Error.type.html","::std::io::Error","type",""],["std/i64.module.html","::std::i64","module","<div class=\"docs\"><p>Integers.</p></div>"],["std/i64/parse.fn.html","::std::i64::parse","function",""],["std/hash.module.html","::std::hash","module","<div class=\"docs\"><p>Hashing types.</p></div>"],["std/hash/Hasher.struct.html","::std::hash::Hasher","struct","<div class=\"docs\"><p>The default hasher used in Rune.</p></div>"],["std/future.module.html","::std::future","module","<div class=\"docs\"><p>Asynchronous computations.</p></div>"],["std/future/join.fn.html","::std::future::join","function","<div class=\"docs\"><p>Waits for a collection of futures to complete and joins their result.</p></div>"],["std/future/Future.struct.html","::std::future::Future","struct","<div class=\"docs\"><p>A type-erased future that can only be unsafely polled in combination with</p></div>"],["std/fmt.module.html","::std::fmt","module","<div class=\"docs\"><p>Formatting text.</p></div>"],["std/fmt/format.macro.html","::std::fmt::format","macro","<div class=\"docs\"><p>Format a string using a format specifier.</p></div>"],["std/fmt/Formatter.struct.html","::std::fmt::Formatter","struct","<div class=\"docs\"><p>A formatter for the rune virtual machine.</p></div>"],["std/fmt/Format.struct.html","::std::fmt::Format","struct","<div class=\"docs\"><p>A format specification, wrapping an inner value.</p></div>"],["std/fmt/Error.type.html","::std::fmt::Error","type",""],["std/f64.module.html","::std::f64","module","<div class=\"docs\"><p>Floating point numbers.</p></div>"],["std/f64/parse.fn.html","::std::f64::parse","function",""],["std/collections.module.html","::std::collections","module","<div class=\"docs\"><p>Module defining collections.</p></div>"],["std/collections/vec_deque.module.html","::std::collections::vec_deque","module","<div class=\"docs\"><p>A dynamic vec deque.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html","::std::collections::vec_deque::VecDeque","struct","<div class=\"docs\"><p>A double-ended queue implemented with a growable ring buffer.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.new","::std::collections::vec_deque::VecDeque::new","method","<div class=\"docs\"><p>Creates an empty deque.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.with_capacity","::std::collections::vec_deque::VecDeque::with_capacity","method","<div class=\"docs\"><p>Creates an empty deque with space for at least <code>capacity</code> elements.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.from","::std::collections::vec_deque::VecDeque::from","method","<div class=\"docs\"><p>Construct a <a href=\"VecDeque.struct.html\" title=\"struct VecDeque\"><code>VecDeque</code></a> from a [<code>Vec</code>].</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.extend","::std::collections::vec_deque::VecDeque::extend","method","<div class=\"docs\"><p>Extend this VecDeque with something that implements the [<code>INTO_ITER</code>]</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.insert","::std::collections::vec_deque::VecDeque::insert","method","<div class=\"docs\"><p>Inserts an element at <code>index</code> within the deque, shifting all elements</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.iter","::std::collections::vec_deque::VecDeque::iter","method","<div class=\"docs\"><p>Returns a front-to-back iterator.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.from_iter","::std::collections::vec_deque::VecDeque::from_iter","method","<div class=\"docs\"><p>Build a <a href=\"VecDeque.struct.html\" title=\"struct VecDeque\"><code>VecDeque</code></a> from an iterator.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.reserve","::std::collections::vec_deque::VecDeque::reserve","method","<div class=\"docs\"><p>Reserves capacity for at least <code>additional</code> more elements to be inserted</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.len","::std::collections::vec_deque::VecDeque::len","method","<div class=\"docs\"><p>Returns the number of elements in the deque.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.capacity","::std::collections::vec_deque::VecDeque::capacity","method","<div class=\"docs\"><p>Returns the number of elements the deque can hold without reallocating.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.front","::std::collections::vec_deque::VecDeque::front","method","<div class=\"docs\"><p>Provides a reference to the front element, or <code>None</code> if the deque is</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.back","::std::collections::vec_deque::VecDeque::back","method","<div class=\"docs\"><p>Provides a reference to the back element, or <code>None</code> if the deque is</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.push_back","::std::collections::vec_deque::VecDeque::push_back","method","<div class=\"docs\"><p>Appends an element to the back of the deque.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.push_front","::std::collections::vec_deque::VecDeque::push_front","method","<div class=\"docs\"><p>Prepends an element to the deque.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.pop_front","::std::collections::vec_deque::VecDeque::pop_front","method","<div class=\"docs\"><p>Removes the first element and returns it, or <code>None</code> if the deque is</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.pop_back","::std::collections::vec_deque::VecDeque::pop_back","method","<div class=\"docs\"><p>Removes the last element from the deque and returns it, or <code>None</code> if it</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.remove","::std::collections::vec_deque::VecDeque::remove","method","<div class=\"docs\"><p>Removes and returns the element at <code>index</code> from the deque.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.rotate_left","::std::collections::vec_deque::VecDeque::rotate_left","method","<div class=\"docs\"><p>Rotates the double-ended queue <code>mid</code> places to the left.</p></div>"],["std/collections/vec_deque/VecDeque.struct.html#method.rotate_right","::std::collections::vec_deque::VecDeque::rotate_right","method","<div class=\"docs\"><p>Rotates the double-ended queue <code>k</code> places to the right.</p></div>"],["std/collections/vec_deque/Iter.struct.html","::std::collections::vec_deque::Iter","struct",""],["std/collections/hash_set.module.html","::std::collections::hash_set","module","<div class=\"docs\"><p>A dynamic hash set.</p></div>"],["std/collections/hash_set/Union.struct.html","::std::collections::hash_set::Union","struct",""],["std/collections/hash_set/Iter.struct.html","::std::collections::hash_set::Iter","struct",""],["std/collections/hash_set/Intersection.struct.html","::std::collections::hash_set::Intersection","struct",""],["std/collections/hash_set/HashSet.struct.html","::std::collections::hash_set::HashSet","struct",""],["std/collections/hash_set/HashSet.struct.html#method.new","::std::collections::hash_set::HashSet::new","method","<div class=\"docs\"><p>Creates an empty <code>HashSet</code>.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.with_capacity","::std::collections::hash_set::HashSet::with_capacity","method","<div class=\"docs\"><p>Creates an empty <code>HashSet</code> with at least the specified capacity.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.len","::std::collections::hash_set::HashSet::len","method","<div class=\"docs\"><p>Returns the number of elements in the set.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.is_empty","::std::collections::hash_set::HashSet::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the set contains no elements.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.capacity","::std::collections::hash_set::HashSet::capacity","method","<div class=\"docs\"><p>Returns the number of elements the set can hold without reallocating.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.insert","::std::collections::hash_set::HashSet::insert","method","<div class=\"docs\"><p>Adds a value to the set.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.remove","::std::collections::hash_set::HashSet::remove","method","<div class=\"docs\"><p>Removes a value from the set. Returns whether the value was present in</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.contains","::std::collections::hash_set::HashSet::contains","method","<div class=\"docs\"><p>Returns <code>true</code> if the set contains a value.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.clear","::std::collections::hash_set::HashSet::clear","method","<div class=\"docs\"><p>Clears the set, removing all values.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.difference","::std::collections::hash_set::HashSet::difference","method","<div class=\"docs\"><p>Visits the values representing the difference, i.e., the values that are</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.extend","::std::collections::hash_set::HashSet::extend","method","<div class=\"docs\"><p>Extend this set from an iterator.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.intersection","::std::collections::hash_set::HashSet::intersection","method","<div class=\"docs\"><p>Visits the values representing the intersection, i.e., the values that</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.union","::std::collections::hash_set::HashSet::union","method","<div class=\"docs\"><p>Visits the values representing the union, i.e., all the values in <code>self</code></p></div>"],["std/collections/hash_set/HashSet.struct.html#method.iter","::std::collections::hash_set::HashSet::iter","method","<div class=\"docs\"><p>Iterate over the hash set.</p></div>"],["std/collections/hash_set/HashSet.struct.html#method.from_iter","::std::collections::hash_set::HashSet::from_iter","method","<div class=\"docs\"><p>Convert a <a href=\"HashSet.struct.html\" title=\"struct HashSet\"><code>HashSet</code></a> from an iterator.</p></div>"],["std/collections/hash_set/Difference.struct.html","::std::collections::hash_set::Difference","struct",""],["std/collections/hash_map.module.html","::std::collections::hash_map","module","<div class=\"docs\"><p>A dynamic hash map.</p></div>"],["std/collections/hash_map/Values.struct.html","::std::collections::hash_map::Values","struct","<div class=\"docs\"><p>An iterator over a the values in a hash map.</p></div>"],["std/collections/hash_map/Keys.struct.html","::std::collections::hash_map::Keys","struct","<div class=\"docs\"><p>An iterator over a the keys in a hash map.</p></div>"],["std/collections/hash_map/Iter.struct.html","::std::collections::hash_map::Iter","struct","<div class=\"docs\"><p>An iterator over a hash map.</p></div>"],["std/collections/hash_map/HashMap.struct.html","::std::collections::hash_map::HashMap","struct",""],["std/collections/hash_map/HashMap.struct.html#method.new","::std::collections::hash_map::HashMap::new","method","<div class=\"docs\"><p>Creates an empty <code>HashMap</code>.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.with_capacity","::std::collections::hash_map::HashMap::with_capacity","method","<div class=\"docs\"><p>Creates an empty <code>HashMap</code> with at least the specified capacity.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.len","::std::collections::hash_map::HashMap::len","method","<div class=\"docs\"><p>Returns the number of elements in the map.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.capacity","::std::collections::hash_map::HashMap::capacity","method","<div class=\"docs\"><p>Returns the number of elements the map can hold without reallocating.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.insert","::std::collections::hash_map::HashMap::insert","method","<div class=\"docs\"><p>Inserts a key-value pair into the map.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.get","::std::collections::hash_map::HashMap::get","method","<div class=\"docs\"><p>Returns the value corresponding to the [<code>Key</code>].</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.contains_key","::std::collections::hash_map::HashMap::contains_key","method","<div class=\"docs\"><p>Returns <code>true</code> if the map contains a value for the specified [<code>Key</code>].</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.remove","::std::collections::hash_map::HashMap::remove","method","<div class=\"docs\"><p>Removes a key from the map, returning the value at the [<code>Key</code>] if the</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.clear","::std::collections::hash_map::HashMap::clear","method","<div class=\"docs\"><p>Clears the map, removing all key-value pairs. Keeps the allocated memory</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.is_empty","::std::collections::hash_map::HashMap::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the map contains no elements.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.iter","::std::collections::hash_map::HashMap::iter","method","<div class=\"docs\"><p>An iterator visiting all key-value pairs in arbitrary order.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.from_iter","::std::collections::hash_map::HashMap::from_iter","method","<div class=\"docs\"><p>Convert a hashmap from a value convert into an iterator.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.keys","::std::collections::hash_map::HashMap::keys","method","<div class=\"docs\"><p>An iterator visiting all keys in arbitrary order.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.values","::std::collections::hash_map::HashMap::values","method","<div class=\"docs\"><p>An iterator visiting all values in arbitrary order.</p></div>"],["std/collections/hash_map/HashMap.struct.html#method.extend","::std::collections::hash_map::HashMap::extend","method","<div class=\"docs\"><p>Extend this map from an iterator.</p></div>"],["std/cmp.module.html","::std::cmp","module","<div class=\"docs\"><p>Comparison and ordering.</p></div>"],["std/cmp/min.fn.html","::std::cmp::min","function","<div class=\"docs\"><p>Compares and returns the minimum of two values.</p></div>"],["std/cmp/max.fn.html","::std::cmp::max","function","<div class=\"docs\"><p>Compares and returns the maximum of two values.</p></div>"],["std/cmp/PartialOrd.trait.html","::std::cmp::PartialOrd","trait",""],["std/cmp/PartialOrd.trait.html#method.partial_cmp","::std::cmp::PartialOrd::partial_cmp","method","<div class=\"docs\"><p>Compare two values.</p></div>"],["std/cmp/PartialEq.trait.html","::std::cmp::PartialEq","trait","<div class=\"docs\"><p>Trait to perform a partial equality check over two values.</p></div>"],["std/cmp/PartialEq.trait.html#method.eq","::std::cmp::PartialEq::eq","method","<div class=\"docs\"><p>Compare two values for equality.</p></div>"],["std/cmp/PartialEq.trait.html#method.ne","::std::cmp::PartialEq::ne","method","<div class=\"docs\"><p>Compare two values for inequality.</p></div>"],["std/cmp/Ordering.enum.html","::std::cmp::Ordering","enum","<div class=\"docs\"><p>An <code>Ordering</code> is the result of a comparison between two values.</p></div>"],["std/cmp/Ordering.enum.html#variant.Less","::std::cmp::Ordering::Less","variant","<div class=\"docs\"><p>&quot;An ordering where a compared value is less than another.</p></div>"],["std/cmp/Ordering.enum.html#variant.Equal","::std::cmp::Ordering::Equal","variant","<div class=\"docs\"><p>&quot;An ordering where a compared value is equal to another.</p></div>"],["std/cmp/Ordering.enum.html#variant.Greater","::std::cmp::Ordering::Greater","variant","<div class=\"docs\"><p>&quot;An ordering where a compared value is greater than another.</p></div>"],["std/cmp/Ord.trait.html","::std::cmp::Ord","trait",""],["std/cmp/Ord.trait.html#method.cmp","::std::cmp::Ord::cmp","method","<div class=\"docs\"><p>Compare two values.</p></div>"],["std/cmp/Eq.trait.html","::std::cmp::Eq","trait","<div class=\"docs\"><p>Trait for equality comparisons.</p></div>"],["std/clone.module.html","::std::clone","module","<div class=\"docs\"><p>Cloning for Rune.</p></div>"],["std/clone/clone.fn.html","::std::clone::clone","function","<div class=\"docs\"><p>Clone the specified <code>value</code>.</p></div>"],["std/clone/Clone.trait.html","::std::clone::Clone","trait","<div class=\"docs\"><p>The <code>Clone</code> trait is used to explicitly clone values.</p></div>"],["std/clone/Clone.trait.html#method.clone","::std::clone::Clone::clone","method","<div class=\"docs\"><p>Clone the specified <code>value</code>.</p></div>"],["std/char.module.html","::std::char","module","<div class=\"docs\"><p>The character module for Rune.</p></div>"],["std/char/from_i64.fn.html","::std::char::from_i64","function","<div class=\"docs\"><p>Try to convert a number into a character.</p></div>"],["std/char/ParseCharError.type.html","::std::char::ParseCharError","type",""],["std/bytes.module.html","::std::bytes","module","<div class=\"docs\"><p>The bytes module.</p></div>"],["std/bytes/Bytes.struct.html","::std::bytes::Bytes","struct","<div class=\"docs\"><p>A vector of bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.new","::std::bytes::Bytes::new","method","<div class=\"docs\"><p>Construct a new byte array.</p></div>"],["std/bytes/Bytes.struct.html#method.with_capacity","::std::bytes::Bytes::with_capacity","method","<div class=\"docs\"><p>Construct a byte array with the given preallocated capacity.</p></div>"],["std/bytes/Bytes.struct.html#method.from_vec","::std::bytes::Bytes::from_vec","method","<div class=\"docs\"><p>Convert a byte array into bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.into_vec","::std::bytes::Bytes::into_vec","method","<div class=\"docs\"><p>Convert the byte array into a vector of bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.as_vec","::std::bytes::Bytes::as_vec","method","<div class=\"docs\"><p>Convert the byte array into a vector of bytes without consuming it.</p></div>"],["std/bytes/Bytes.struct.html#method.extend","::std::bytes::Bytes::extend","method","<div class=\"docs\"><p>Extend these bytes with another collection of bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.extend_str","::std::bytes::Bytes::extend_str","method","<div class=\"docs\"><p>Extend this bytes collection with a string.</p></div>"],["std/bytes/Bytes.struct.html#method.pop","::std::bytes::Bytes::pop","method","<div class=\"docs\"><p>Pop the last byte.</p></div>"],["std/bytes/Bytes.struct.html#method.last","::std::bytes::Bytes::last","method","<div class=\"docs\"><p>Get the last byte.</p></div>"],["std/bytes/Bytes.struct.html#method.len","::std::bytes::Bytes::len","method","<div class=\"docs\"><p>Get the length of the bytes collection.</p></div>"],["std/bytes/Bytes.struct.html#method.is_empty","::std::bytes::Bytes::is_empty","method","<div class=\"docs\"><p>Test if the collection is empty.</p></div>"],["std/bytes/Bytes.struct.html#method.capacity","::std::bytes::Bytes::capacity","method","<div class=\"docs\"><p>Returns the total number of elements the vector can hold without</p></div>"],["std/bytes/Bytes.struct.html#method.clear","::std::bytes::Bytes::clear","method","<div class=\"docs\"><p>Clears the vector, removing all values.</p></div>"],["std/bytes/Bytes.struct.html#method.reserve","::std::bytes::Bytes::reserve","method","<div class=\"docs\"><p>Reserves capacity for at least <code>additional</code> more elements to be inserted in</p></div>"],["std/bytes/Bytes.struct.html#method.reserve_exact","::std::bytes::Bytes::reserve_exact","method","<div class=\"docs\"><p>Reserves the minimum capacity for at least <code>additional</code> more elements to be</p></div>"],["std/bytes/Bytes.struct.html#method.shrink_to_fit","::std::bytes::Bytes::shrink_to_fit","method","<div class=\"docs\"><p>Shrinks the capacity of the byte array as much as possible.</p></div>"],["std/bool.type.html","::std::bool","type","<div class=\"docs\"><p>The primitive boolean type.</p></div>"],["std/any.module.html","::std::any","module","<div class=\"docs\"><p>Dynamic typing and type reflection.</p></div>"],["std/any/type_name_of_val.fn.html","::std::any::type_name_of_val","function","<div class=\"docs\"><p>Get the type name of a value.</p></div>"],["std/any/Type.type.html","::std::any::Type","type","<div class=\"docs\"><p>Represents a type in the Rune type system.</p></div>"],["std/any/Type.type.html#method.of_val","::std::any::Type::of_val","method","<div class=\"docs\"><p>Convert a value into a [<code>Type</code>] object.</p></div>"],["json.module.html","::json","module","<div class=\"docs\"><p>Module for processing JSON.</p></div>"],["json/to_string.fn.html","::json::to_string","function","<div class=\"docs\"><p>Convert any value to a json string.</p></div>"],["json/to_bytes.fn.html","::json::to_bytes","function","<div class=\"docs\"><p>Convert any value to json bytes.</p></div>"],["json/from_string.fn.html","::json::from_string","function","<div class=\"docs\"><p>Convert a JSON string into a rune value.</p></div>"],["json/from_bytes.fn.html","::json::from_bytes","function","<div class=\"docs\"><p>Convert JSON bytes into a rune value.</p></div>"],["json/Error.struct.html","::json::Error","struct","<div class=\"docs\"><p>Error type raised during JSON serialization.</p></div>"],["base64.module.html","::base64","module","<div class=\"docs\"><p>Correct and fast [base64] encoding based on the [<code>base64</code>] crate.</p></div>"],["base64/encode.fn.html","::base64::encode","function","<div class=\"docs\"><p>Encode a data into a base64 String.</p></div>"],["base64/decode.fn.html","::base64::decode","function","<div class=\"docs\"><p>Decode a base64 String into data</p></div>"],["base64/DecodeError.struct.html","::base64::DecodeError","struct","<div class=\"docs\"><p>Errors that can occur while decoding.</p></div>"],["signal.module.html","::signal","module",""],["signal/ctrl_c.fn.html","::signal::ctrl_c","function","<div class=\"docs\"><p>Completes when a &quot;ctrl-c&quot; notification is sent to the process.</p></div>"],["http.module.html","::http","module","<div class=\"docs\"><p>A simple HTTP module for Rune.</p></div>"],["http/get.fn.html","::http::get","function","<div class=\"docs\"><p>Shorthand for generating a get request.</p></div>"],["http/StatusCode.struct.html","::http::StatusCode","struct","<div class=\"docs\"><p>An HTTP status code.</p></div>"],["http/Response.struct.html","::http::Response","struct","<div class=\"docs\"><p>A Response to a submitted [<code>Request</code>].</p></div>"],["http/Response.struct.html#method.text","::http::Response::text","method","<div class=\"docs\"><p>Get the response as text.</p></div>"],["http/Response.struct.html#method.json","::http::Response::json","method","<div class=\"docs\"><p>Get the response as a Rune value decoded from JSON.</p></div>"],["http/Response.struct.html#method.bytes","::http::Response::bytes","method","<div class=\"docs\"><p>Get the response as bytes.</p></div>"],["http/Response.struct.html#method.status","::http::Response::status","method","<div class=\"docs\"><p>Get the status code of the response.</p></div>"],["http/RequestBuilder.struct.html","::http::RequestBuilder","struct","<div class=\"docs\"><p>A builder to construct the properties of a Request.</p></div>"],["http/RequestBuilder.struct.html#method.send","::http::RequestBuilder::send","method","<div class=\"docs\"><p>Send the request and receive an answer from the server.</p></div>"],["http/RequestBuilder.struct.html#method.header","::http::RequestBuilder::header","method","<div class=\"docs\"><p>Modify a header in the request.</p></div>"],["http/RequestBuilder.struct.html#method.body_bytes","::http::RequestBuilder::body_bytes","method","<div class=\"docs\"><p>Set the request body from bytes.</p></div>"],["http/RequestBuilder.struct.html#method.fetch_mode_no_cors","::http::RequestBuilder::fetch_mode_no_cors","method","<div class=\"docs\"><p>Disable CORS on fetching the request.</p></div>"],["http/Error.struct.html","::http::Error","struct","<div class=\"docs\"><p>An error returned by methods in the <code>http</code> module.</p></div>"],["http/Client.struct.html","::http::Client","struct","<div class=\"docs\"><p>An asynchronous Client to make Requests with.</p></div>"],["http/Client.struct.html#method.new","::http::Client::new","method","<div class=\"docs\"><p>Construct a new http client.</p></div>"],["http/Client.struct.html#method.get","::http::Client::get","method","<div class=\"docs\"><p>Construct a builder to GET the given <code>url</code>.</p></div>"],["http/Client.struct.html#method.post","::http::Client::post","method","<div class=\"docs\"><p>Construct a builder to POST to the given <code>url</code>.</p></div>"]];
