window.INDEX = [["examples-test-example.module.html","::examples-test-example","module",""],["examples-test-example/module.module.html","::examples-test-example::module","module",""],["examples-test-example/module/test.fn.html","::examples-test-example::module::test","function",""],["examples-test-example/main.fn.html","::examples-test-example::main","function",""],["examples-module-example.module.html","::examples-module-example","module",""],["examples-module-example/test.fn.html","::examples-module-example::test","function",""],["rune-benches-primes-bench.module.html","::rune-benches-primes-bench","module",""],["rune-benches-primes-bench/find_primes.fn.html","::rune-benches-primes-bench::find_primes","function","<div class=\"docs\"><p>Find prime numbers.</p></div>"],["process.module.html","::process","module",""],["process/Output.struct.html","::process::Output","struct",""],["process/ExitStatus.struct.html","::process::ExitStatus","struct",""],["process/ExitStatus.struct.html#method.code","::process::ExitStatus::code","method",""],["process/Command.struct.html","::process::Command","struct",""],["process/Command.struct.html#method.new","::process::Command::new","method","<div class=\"docs\"><p>Construct a new command.</p></div>"],["process/Command.struct.html#method.spawn","::process::Command::spawn","method","<div class=\"docs\"><p>Spawn the command.</p></div>"],["process/Command.struct.html#method.arg","::process::Command::arg","method","<div class=\"docs\"><p>Add an argument.</p></div>"],["process/Command.struct.html#method.args","::process::Command::args","method","<div class=\"docs\"><p>Add arguments.</p></div>"],["process/Child.struct.html","::process::Child","struct",""],["process/Child.struct.html#method.wait_with_output","::process::Child::wait_with_output","method",""],["std.module.html","::std","module","<div class=\"docs\"><p>The Rune standard library.</p></div>"],["std/vec.module.html","::std::vec","module",""],["std/vec/Vec.struct.html","::std::vec::Vec","struct","<div class=\"docs\"><p>A dynamic vector.</p></div>"],["std/vec/Vec.struct.html#method.new","::std::vec::Vec::new","method","<div class=\"docs\"><p>Constructs a new, empty dynamic <code>Vec</code>.</p></div>"],["std/vec/Vec.struct.html#method.with_capacity","::std::vec::Vec::with_capacity","method","<div class=\"docs\"><p>Constructs a new, empty dynamic <code>Vec</code> with at least the specified capacity.</p></div>"],["std/vec/Vec.struct.html#method.len","::std::vec::Vec::len","method","<div class=\"docs\"><p>Returns the number of elements in the vector, also referred to as its</p></div>"],["std/vec/Vec.struct.html#method.is_empty","::std::vec::Vec::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the vector contains no elements.</p></div>"],["std/vec/Vec.struct.html#method.capacity","::std::vec::Vec::capacity","method","<div class=\"docs\"><p>Returns the total number of elements the vector can hold without</p></div>"],["std/vec/Vec.struct.html#method.get","::std::vec::Vec::get","method","<div class=\"docs\"><p>Returns a reference to an element or subslice depending on the type of</p></div>"],["std/vec/Vec.struct.html#method.clear","::std::vec::Vec::clear","method","<div class=\"docs\"><p>Clears the vector, removing all values.</p></div>"],["std/vec/Vec.struct.html#method.extend","::std::vec::Vec::extend","method","<div class=\"docs\"><p>Extend these bytes with another collection.</p></div>"],["std/vec/Vec.struct.html#method.iter","::std::vec::Vec::iter","method","<div class=\"docs\"><p>Iterate over the collection.</p></div>"],["std/vec/Vec.struct.html#method.pop","::std::vec::Vec::pop","method","<div class=\"docs\"><p>Removes the last element from a vector and returns it, or [<code>None</code>] if it is</p></div>"],["std/vec/Vec.struct.html#method.push","::std::vec::Vec::push","method","<div class=\"docs\"><p>Appends an element to the back of a collection.</p></div>"],["std/vec/Vec.struct.html#method.remove","::std::vec::Vec::remove","method","<div class=\"docs\"><p>Removes and returns the element at position <code>index</code> within the vector,</p></div>"],["std/vec/Vec.struct.html#method.insert","::std::vec::Vec::insert","method","<div class=\"docs\"><p>Inserts an element at position <code>index</code> within the vector, shifting all</p></div>"],["std/vec/Vec.struct.html#method.clone","::std::vec::Vec::clone","method","<div class=\"docs\"><p>Clone the vector.</p></div>"],["std/vec/Vec.struct.html#method.sort_by","::std::vec::Vec::sort_by","method","<div class=\"docs\"><p>Sort a vector by the specified comparator function.</p></div>"],["std/vec/Vec.struct.html#method.sort","::std::vec::Vec::sort","method","<div class=\"docs\"><p>Sort the vector.</p></div>"],["std/u8.type.html","::std::u8","type","<div class=\"docs\"><p>The primitive byte type.</p></div>"],["std/tuple.module.html","::std::tuple","module","<div class=\"docs\"><p>Dynamic tuples.</p></div>"],["std/tuple/Tuple.struct.html","::std::tuple::Tuple","struct","<div class=\"docs\"><p>The tuple type.</p></div>"],["std/tuple/Tuple.struct.html#method.len","::std::tuple::Tuple::len","method","<div class=\"docs\"><p>Returns the number of elements in the tuple.</p></div>"],["std/tuple/Tuple.struct.html#method.is_empty","::std::tuple::Tuple::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the tuple has a length of 0.</p></div>"],["std/tuple/Tuple.struct.html#method.get","::std::tuple::Tuple::get","method","<div class=\"docs\"><p>Returns a reference to an element or subslice depending on the type of</p></div>"],["std/tuple/Tuple.struct.html#method.iter","::std::tuple::Tuple::iter","method","<div class=\"docs\"><p>Construct an iterator over the tuple.</p></div>"],["std/test.module.html","::std::test","module",""],["std/test/assert_ne.macro.html","::std::test::assert_ne","macro","<div class=\"docs\"><p>Assert that the two arguments provided are not equal, or cause a vm panic.</p></div>"],["std/test/assert_eq.macro.html","::std::test::assert_eq","macro","<div class=\"docs\"><p>Assert that the two arguments provided are equal, or cause a vm panic.</p></div>"],["std/test/assert.macro.html","::std::test::assert","macro","<div class=\"docs\"><p>Assert that the expression provided as an argument is true, or cause a vm</p></div>"],["std/test/Bencher.struct.html","::std::test::Bencher","struct","<div class=\"docs\"><p>A type to perform benchmarks.</p></div>"],["std/test/Bencher.struct.html#method.iter","::std::test::Bencher::iter","method","<div class=\"docs\"><p>Run a benchmark using the given closure.</p></div>"],["std/stringify.macro.html","::std::stringify","macro","<div class=\"docs\"><p>Stringify the given argument, causing it to expand to its underlying token</p></div>"],["std/string.module.html","::std::string","module",""],["std/string/String.type.html","::std::string::String","type",""],["std/string/String.type.html#method.from","::std::string::String::from","method","<div class=\"docs\"><p>Constructs a string from another string.</p></div>"],["std/string/String.type.html#method.from_str","::std::string::String::from_str","method",""],["std/string/String.type.html#method.new","::std::string::String::new","method","<div class=\"docs\"><p>Creates a new empty <code>String</code>.</p></div>"],["std/string/String.type.html#method.with_capacity","::std::string::String::with_capacity","method","<div class=\"docs\"><p>Creates a new empty <code>String</code> with at least the specified capacity.</p></div>"],["std/string/String.type.html#method.cmp","::std::string::String::cmp","method",""],["std/string/String.type.html#method.len","::std::string::String::len","method","<div class=\"docs\"><p>Returns the length of <code>self</code>.</p></div>"],["std/string/String.type.html#method.starts_with","::std::string::String::starts_with","method","<div class=\"docs\"><p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p></div>"],["std/string/String.type.html#method.ends_with","::std::string::String::ends_with","method","<div class=\"docs\"><p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p></div>"],["std/string/String.type.html#method.capacity","::std::string::String::capacity","method","<div class=\"docs\"><p>Returns this <code>String</code>'s capacity, in bytes.</p></div>"],["std/string/String.type.html#method.clear","::std::string::String::clear","method","<div class=\"docs\"><p>Truncates this <code>String</code>, removing all contents.</p></div>"],["std/string/String.type.html#method.contains","::std::string::String::contains","method","<div class=\"docs\"><p>Returns <code>true</code> if the given pattern matches a sub-slice of this string</p></div>"],["std/string/String.type.html#method.push","::std::string::String::push","method","<div class=\"docs\"><p>Appends the given [<code>char</code>] to the end of this <code>String</code>.</p></div>"],["std/string/String.type.html#method.push_str","::std::string::String::push_str","method","<div class=\"docs\"><p>Appends a given string slice onto the end of this <code>String</code>.</p></div>"],["std/string/String.type.html#method.reserve","::std::string::String::reserve","method","<div class=\"docs\"><p>Reserves capacity for at least <code>additional</code> bytes more than the current</p></div>"],["std/string/String.type.html#method.reserve_exact","::std::string::String::reserve_exact","method","<div class=\"docs\"><p>Reserves the minimum capacity for at least <code>additional</code> bytes more than the</p></div>"],["std/string/String.type.html#method.from_utf8","::std::string::String::from_utf8","method","<div class=\"docs\"><p>Converts a vector of bytes to a <code>String</code>.</p></div>"],["std/string/String.type.html#method.as_bytes","::std::string::String::as_bytes","method","<div class=\"docs\"><p>Returns a byte slice of this <code>String</code>'s contents.</p></div>"],["std/string/String.type.html#method.into_bytes","::std::string::String::into_bytes","method","<div class=\"docs\"><p>Returns a byte slice of this <code>String</code>'s contents while moving the string.</p></div>"],["std/string/String.type.html#method.clone","::std::string::String::clone","method","<div class=\"docs\"><p>Clones the string and its underlying storage.</p></div>"],["std/string/String.type.html#method.shrink_to_fit","::std::string::String::shrink_to_fit","method","<div class=\"docs\"><p>Shrinks the capacity of this <code>String</code> to match its length.</p></div>"],["std/string/String.type.html#method.char_at","::std::string::String::char_at","method","<div class=\"docs\"><p>Access the character at the given byte index.</p></div>"],["std/string/String.type.html#method.split","::std::string::String::split","method","<div class=\"docs\"><p>An iterator over substrings of this string slice, separated by</p></div>"],["std/string/String.type.html#method.split_str","::std::string::String::split_str","method",""],["std/string/String.type.html#method.trim","::std::string::String::trim","method","<div class=\"docs\"><p>Returns a string slice with leading and trailing whitespace removed.</p></div>"],["std/string/String.type.html#method.trim_end","::std::string::String::trim_end","method","<div class=\"docs\"><p>Returns a string slice with trailing whitespace removed.</p></div>"],["std/string/String.type.html#method.replace","::std::string::String::replace","method","<div class=\"docs\"><p>Replaces all matches of a pattern with another string.</p></div>"],["std/string/String.type.html#method.is_empty","::std::string::String::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p></div>"],["std/string/String.type.html#method.chars","::std::string::String::chars","method","<div class=\"docs\"><p>Returns an iterator over the [<code>char</code>]s of a string slice.</p></div>"],["std/string/String.type.html#method.get","::std::string::String::get","method","<div class=\"docs\"><p>Returns a subslice of <code>str</code>.</p></div>"],["std/string/String.type.html#method.parse","::std::string::String::parse","method","<div class=\"docs\"><p>Parses this string into an integer.</p></div>"],["std/string/String.type.html#method.parse","::std::string::String::parse","method","<div class=\"docs\"><p>Parses this string into a character.</p></div>"],["std/stream.module.html","::std::stream","module",""],["std/stream/Stream.struct.html","::std::stream::Stream","struct","<div class=\"docs\"><p>A stream with a stored virtual machine.</p></div>"],["std/stream/Stream.struct.html#method.next","::std::stream::Stream::next","method",""],["std/stream/Stream.struct.html#method.resume","::std::stream::Stream::resume","method",""],["std/result.module.html","::std::result","module",""],["std/result/Result.enum.html","::std::result::Result","enum","<div class=\"docs\"><p>Result is a type that represents either success (Ok) or failure (Err).</p></div>"],["std/result/Result.enum.html#method.ok","::std::result::Result::ok","method","<div class=\"docs\"><p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.</p></div>"],["std/result/Result.enum.html#method.is_ok","::std::result::Result::is_ok","method","<div class=\"docs\"><p>Returns <code>true</code> if the result is [<code>Ok</code>].</p></div>"],["std/result/Result.enum.html#method.is_err","::std::result::Result::is_err","method","<div class=\"docs\"><p>Returns <code>true</code> if the result is [<code>Err</code>].</p></div>"],["std/result/Result.enum.html#method.unwrap","::std::result::Result::unwrap","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value, consuming the <code>self</code> value.</p></div>"],["std/result/Result.enum.html#method.unwrap_or","::std::result::Result::unwrap_or","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value or a provided default.</p></div>"],["std/result/Result.enum.html#method.unwrap_or_else","::std::result::Result::unwrap_or_else","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value or computes it from a closure.</p></div>"],["std/result/Result.enum.html#method.expect","::std::result::Result::expect","method","<div class=\"docs\"><p>Returns the contained [<code>Ok</code>] value, consuming the <code>self</code> value.</p></div>"],["std/result/Result.enum.html#method.and_then","::std::result::Result::and_then","method","<div class=\"docs\"><p>Calls <code>op</code> if the result is [<code>Ok</code>], otherwise returns the [<code>Err</code>] value of <code>self</code>.</p></div>"],["std/result/Result.enum.html#method.map","::std::result::Result::map","method","<div class=\"docs\"><p>Maps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code> by applying a function to a</p></div>"],["std/result/Result.enum.html#variant.Ok","::std::result::Result::Ok","variant","<div class=\"docs\"><p>Contains the success value</p></div>"],["std/result/Result.enum.html#variant.Err","::std::result::Result::Err","variant","<div class=\"docs\"><p>Contains the error value</p></div>"],["std/panic.macro.html","::std::panic","macro","<div class=\"docs\"><p>Cause a vm panic with a formatted message.</p></div>"],["std/panic.fn.html","::std::panic","function","<div class=\"docs\"><p>Cause a vm panic with the given <code>message</code>.</p></div>"],["std/option.module.html","::std::option","module",""],["std/option/Option.enum.html","::std::option::Option","enum",""],["std/option/Option.enum.html#method.expect","::std::option::Option::expect","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value, consuming the <code>self</code> value.</p></div>"],["std/option/Option.enum.html#method.unwrap","::std::option::Option::unwrap","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value, consuming the <code>self</code> value.</p></div>"],["std/option/Option.enum.html#method.unwrap_or","::std::option::Option::unwrap_or","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value or a provided <code>default</code>.</p></div>"],["std/option/Option.enum.html#method.unwrap_or_else","::std::option::Option::unwrap_or_else","method","<div class=\"docs\"><p>Returns the contained [<code>Some</code>] value or computes it from a closure.</p></div>"],["std/option/Option.enum.html#method.is_some","::std::option::Option::is_some","method","<div class=\"docs\"><p>Returns <code>true</code> if the option is a [<code>Some</code>] value.</p></div>"],["std/option/Option.enum.html#method.is_none","::std::option::Option::is_none","method","<div class=\"docs\"><p>Returns <code>true</code> if the option is a [<code>None</code>] value.</p></div>"],["std/option/Option.enum.html#method.iter","::std::option::Option::iter","method","<div class=\"docs\"><p>Construct an iterator over an optional value.</p></div>"],["std/option/Option.enum.html#method.and_then","::std::option::Option::and_then","method","<div class=\"docs\"><p>Returns [<code>None</code>] if the option is [<code>None</code>], otherwise calls <code>f</code> with the</p></div>"],["std/option/Option.enum.html#method.map","::std::option::Option::map","method","<div class=\"docs\"><p>Maps an <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code> by applying a function to a contained</p></div>"],["std/option/Option.enum.html#method.take","::std::option::Option::take","method","<div class=\"docs\"><p>Takes the value out of the option, leaving a [<code>None</code>] in its place.</p></div>"],["std/option/Option.enum.html#method.transpose","::std::option::Option::transpose","method","<div class=\"docs\"><p>Transposes an <code>Option</code> of a [<code>Result</code>] into a [<code>Result</code>] of an <code>Option</code>.</p></div>"],["std/option/Option.enum.html#method.ok_or","::std::option::Option::ok_or","method","<div class=\"docs\"><p>Transforms the <code>Option&lt;T&gt;</code> into a [<code>Result&lt;T, E&gt;</code>], mapping [<code>Some(v)</code>] to</p></div>"],["std/option/Option.enum.html#method.ok_or_else","::std::option::Option::ok_or_else","method","<div class=\"docs\"><p>Transforms the <code>Option&lt;T&gt;</code> into a [<code>Result&lt;T, E&gt;</code>], mapping [<code>Some(v)</code>] to</p></div>"],["std/option/Option.enum.html#variant.Some","::std::option::Option::Some","variant",""],["std/option/Option.enum.html#variant.None","::std::option::Option::None","variant",""],["std/ops.module.html","::std::ops","module","<div class=\"docs\"><p>Overloadable operators.</p></div>"],["std/ops/partial_eq.fn.html","::std::ops::partial_eq","function","<div class=\"docs\"><p>Perform a partial equality check over two values.</p></div>"],["std/ops/partial_cmp.fn.html","::std::ops::partial_cmp","function","<div class=\"docs\"><p>Perform a partial comparison over two values.</p></div>"],["std/ops/hash.fn.html","::std::ops::hash","function","<div class=\"docs\"><p>Hashes the given value.</p></div>"],["std/ops/eq.fn.html","::std::ops::eq","function","<div class=\"docs\"><p>Perform a partial equality check over two values.</p></div>"],["std/ops/cmp.fn.html","::std::ops::cmp","function","<div class=\"docs\"><p>Perform a total comparison over two values.</p></div>"],["std/ops/RangeToInclusive.struct.html","::std::ops::RangeToInclusive","struct","<div class=\"docs\"><p>Type for an inclusive range expression <code>..=end</code>.</p></div>"],["std/ops/RangeToInclusive.struct.html#method.contains","::std::ops::RangeToInclusive::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeTo.struct.html","::std::ops::RangeTo","struct","<div class=\"docs\"><p>Type for an inclusive range expression <code>..end</code>.</p></div>"],["std/ops/RangeTo.struct.html#method.contains","::std::ops::RangeTo::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeInclusive.struct.html","::std::ops::RangeInclusive","struct","<div class=\"docs\"><p>Type for an inclusive range expression <code>start..=end</code>.</p></div>"],["std/ops/RangeInclusive.struct.html#method.iter","::std::ops::RangeInclusive::iter","method","<div class=\"docs\"><p>Iterate over the range.</p></div>"],["std/ops/RangeInclusive.struct.html#method.contains","::std::ops::RangeInclusive::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeFull.struct.html","::std::ops::RangeFull","struct","<div class=\"docs\"><p>Type for a full range expression <code>..</code>.</p></div>"],["std/ops/RangeFull.struct.html#method.contains","::std::ops::RangeFull::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/RangeFrom.struct.html","::std::ops::RangeFrom","struct","<div class=\"docs\"><p>Type for a from range expression <code>start..</code>.</p></div>"],["std/ops/RangeFrom.struct.html#method.iter","::std::ops::RangeFrom::iter","method","<div class=\"docs\"><p>Iterate over the range.</p></div>"],["std/ops/RangeFrom.struct.html#method.contains","::std::ops::RangeFrom::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/Range.struct.html","::std::ops::Range","struct","<div class=\"docs\"><p>Type for a range expression <code>start..end</code>.</p></div>"],["std/ops/Range.struct.html#method.iter","::std::ops::Range::iter","method","<div class=\"docs\"><p>Iterate over the range.</p></div>"],["std/ops/Range.struct.html#method.contains","::std::ops::Range::contains","method","<div class=\"docs\"><p>Test if the range contains the given value.</p></div>"],["std/ops/GeneratorState.enum.html","::std::ops::GeneratorState","enum","<div class=\"docs\"><p>Enum indicating the state of a generator.</p></div>"],["std/ops/GeneratorState.enum.html#variant.Complete","::std::ops::GeneratorState::Complete","variant",""],["std/ops/GeneratorState.enum.html#variant.Yielded","::std::ops::GeneratorState::Yielded","variant",""],["std/ops/Generator.struct.html","::std::ops::Generator","struct","<div class=\"docs\"><p>The return value of a function producing a generator.</p></div>"],["std/ops/Generator.struct.html#method.next","::std::ops::Generator::next","method","<div class=\"docs\"><p>Advance a generator producing the next value yielded.</p></div>"],["std/ops/Generator.struct.html#method.resume","::std::ops::Generator::resume","method","<div class=\"docs\"><p>Advance a generator producing the next <a href=\"GeneratorState.enum.html\" title=\"enum GeneratorState\"><code>GeneratorState</code></a>.</p></div>"],["std/ops/Generator.struct.html#method.iter","::std::ops::Generator::iter","method",""],["std/ops/Function.struct.html","::std::ops::Function","struct","<div class=\"docs\"><p>The type of a function in Rune.</p></div>"],["std/ops/ControlFlow.enum.html","::std::ops::ControlFlow","enum","<div class=\"docs\"><p>Used to tell an operation whether it should exit early or go on as usual.</p></div>"],["std/ops/ControlFlow.enum.html#variant.Continue","::std::ops::ControlFlow::Continue","variant","<div class=\"docs\"><p>Move on to the next phase of the operation as normal.</p></div>"],["std/ops/ControlFlow.enum.html#variant.Break","::std::ops::ControlFlow::Break","variant","<div class=\"docs\"><p>Exit the operation without running subsequent phases.</p></div>"],["std/object.module.html","::std::object","module",""],["std/object/Object.struct.html","::std::object::Object","struct","<div class=\"docs\"><p>Struct representing a dynamic anonymous object.</p></div>"],["std/object/Object.struct.html#method.new","::std::object::Object::new","method","<div class=\"docs\"><p>Construct a new object.</p></div>"],["std/object/Object.struct.html#method.with_capacity","::std::object::Object::with_capacity","method","<div class=\"docs\"><p>Construct a new object with the given capacity.</p></div>"],["std/object/Object.struct.html#method.len","::std::object::Object::len","method","<div class=\"docs\"><p>Returns the number of elements in the object.</p></div>"],["std/object/Object.struct.html#method.is_empty","::std::object::Object::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the object is empty.</p></div>"],["std/object/Object.struct.html#method.insert","::std::object::Object::insert","method","<div class=\"docs\"><p>Inserts a key-value pair into the map.</p></div>"],["std/object/Object.struct.html#method.remove","::std::object::Object::remove","method","<div class=\"docs\"><p>Removes a key from the map, returning the value at the key if the key was</p></div>"],["std/object/Object.struct.html#method.clear","::std::object::Object::clear","method","<div class=\"docs\"><p>Clears the object, removing all key-value pairs. Keeps the allocated</p></div>"],["std/object/Object.struct.html#method.contains_key","::std::object::Object::contains_key","method","<div class=\"docs\"><p>Returns <code>true</code> if the map contains a value for the specified key.</p></div>"],["std/object/Object.struct.html#method.get","::std::object::Object::get","method","<div class=\"docs\"><p>Returns a reference to the value corresponding to the key.</p></div>"],["std/object/Object.struct.html#method.iter","::std::object::Object::iter","method","<div class=\"docs\"><p>An iterator visiting all keys and values in arbitrary order.</p></div>"],["std/object/Object.struct.html#method.keys","::std::object::Object::keys","method","<div class=\"docs\"><p>An iterator visiting all keys in arbitrary order.</p></div>"],["std/object/Object.struct.html#method.values","::std::object::Object::values","method","<div class=\"docs\"><p>An iterator visiting all values in arbitrary order.</p></div>"],["std/num.module.html","::std::num","module",""],["std/num/ParseIntError.type.html","::std::num::ParseIntError","type",""],["std/num/ParseFloatError.type.html","::std::num::ParseFloatError","type",""],["std/mem.module.html","::std::mem","module",""],["std/mem/drop.fn.html","::std::mem::drop","function","<div class=\"docs\"><p>Explicitly drop the given value, freeing up any memory associated with it.</p></div>"],["std/macros.module.html","::std::macros","module",""],["std/macros/builtin.module.html","::std::macros::builtin","module",""],["std/macros/builtin/line.macro.html","::std::macros::builtin::line","macro","<div class=\"docs\"><p>Return the line in the current file.</p></div>"],["std/macros/builtin/file.macro.html","::std::macros::builtin::file","macro","<div class=\"docs\"><p>Return the name of the current file.</p></div>"],["std/iter.module.html","::std::iter","module",""],["std/iter/range.fn.html","::std::iter::range","function","<div class=\"docs\"><p>Produce an iterator which starts at the range <code>start</code> and ends at the value</p></div>"],["std/iter/once.fn.html","::std::iter::once","function","<div class=\"docs\"><p>Construct an iterator which produces a single <code>value</code> once.</p></div>"],["std/iter/empty.fn.html","::std::iter::empty","function","<div class=\"docs\"><p>Construct an iterator which produces no values.</p></div>"],["std/iter/Iterator.struct.html","::std::iter::Iterator","struct","<div class=\"docs\"><p>An owning iterator.</p></div>"],["std/iter/Iterator.struct.html#method.next","::std::iter::Iterator::next","method","<div class=\"docs\"><p>Advances the iterator and returns the next value.</p></div>"],["std/iter/Iterator.struct.html#method.next_back","::std::iter::Iterator::next_back","method","<div class=\"docs\"><p>Removes and returns an element from the end of the iterator.</p></div>"],["std/iter/Iterator.struct.html#method.find","::std::iter::Iterator::find","method","<div class=\"docs\"><p>Searches for an element of an iterator that satisfies a predicate.</p></div>"],["std/iter/Iterator.struct.html#method.any","::std::iter::Iterator::any","method","<div class=\"docs\"><p>Tests if any element of the iterator matches a predicate.</p></div>"],["std/iter/Iterator.struct.html#method.all","::std::iter::Iterator::all","method","<div class=\"docs\"><p>Tests if every element of the iterator matches a predicate.</p></div>"],["std/iter/Iterator.struct.html#method.chain","::std::iter::Iterator::chain","method","<div class=\"docs\"><p>Takes two iterators and creates a new iterator over both in sequence.</p></div>"],["std/iter/Iterator.struct.html#method.filter","::std::iter::Iterator::filter","method","<div class=\"docs\"><p>Creates an iterator which uses a closure to determine if an element</p></div>"],["std/iter/Iterator.struct.html#method.map","::std::iter::Iterator::map","method","<div class=\"docs\"><p>Takes a closure and creates an iterator which calls that closure on each</p></div>"],["std/iter/Iterator.struct.html#method.flat_map","::std::iter::Iterator::flat_map","method","<div class=\"docs\"><p>Creates an iterator that works like map, but flattens nested structure.</p></div>"],["std/iter/Iterator.struct.html#method.enumerate","::std::iter::Iterator::enumerate","method","<div class=\"docs\"><p>Creates an iterator which gives the current iteration count as well as</p></div>"],["std/iter/Iterator.struct.html#method.peek","::std::iter::Iterator::peek","method","<div class=\"docs\"><p>Returns a reference to the <code>next()</code> value without advancing the iterator.</p></div>"],["std/iter/Iterator.struct.html#method.peekable","::std::iter::Iterator::peekable","method","<div class=\"docs\"><p>Creates an iterator which can use the [<code>peek</code>] method to look at the next</p></div>"],["std/iter/Iterator.struct.html#method.sum","::std::iter::Iterator::sum","method","<div class=\"docs\"><p>Sums the elements of an iterator.</p></div>"],["std/iter/Iterator.struct.html#method.sum","::std::iter::Iterator::sum","method","<div class=\"docs\"><p>Sums the elements of an iterator.</p></div>"],["std/iter/Iterator.struct.html#method.sum","::std::iter::Iterator::sum","method","<div class=\"docs\"><p>Sums the elements of an iterator.</p></div>"],["std/iter/Iterator.struct.html#method.product","::std::iter::Iterator::product","method","<div class=\"docs\"><p>Iterates over the entire iterator, multiplying all the elements</p></div>"],["std/iter/Iterator.struct.html#method.product","::std::iter::Iterator::product","method","<div class=\"docs\"><p>Iterates over the entire iterator, multiplying all the elements</p></div>"],["std/iter/Iterator.struct.html#method.product","::std::iter::Iterator::product","method","<div class=\"docs\"><p>Iterates over the entire iterator, multiplying all the elements</p></div>"],["std/iter/Iterator.struct.html#method.fold","::std::iter::Iterator::fold","method","<div class=\"docs\"><p>Folds every element into an accumulator by applying an operation, returning</p></div>"],["std/iter/Iterator.struct.html#method.reduce","::std::iter::Iterator::reduce","method","<div class=\"docs\"><p>Reduces the elements to a single one, by repeatedly applying a reducing</p></div>"],["std/iter/Iterator.struct.html#method.rev","::std::iter::Iterator::rev","method","<div class=\"docs\"><p>Reverses an iterator's direction.</p></div>"],["std/iter/Iterator.struct.html#method.size_hint","::std::iter::Iterator::size_hint","method","<div class=\"docs\"><p>Returns the bounds on the remaining length of the iterator.</p></div>"],["std/iter/Iterator.struct.html#method.skip","::std::iter::Iterator::skip","method","<div class=\"docs\"><p>Creates an iterator that skips the first <code>n</code> elements.</p></div>"],["std/iter/Iterator.struct.html#method.take","::std::iter::Iterator::take","method","<div class=\"docs\"><p>Creates an iterator that yields the first <code>n</code> elements, or fewer if the</p></div>"],["std/iter/Iterator.struct.html#method.count","::std::iter::Iterator::count","method","<div class=\"docs\"><p>Consumes the iterator, counting the number of iterations and returning it.</p></div>"],["std/iter/Iterator.struct.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>Vec</code>].</p></div>"],["std/iter/Iterator.struct.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>VecDeque</code>].</p></div>"],["std/iter/Iterator.struct.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>HashSet</code>].</p></div>"],["std/iter/Iterator.struct.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>HashMap</code>].</p></div>"],["std/iter/Iterator.struct.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>Tuple</code>].</p></div>"],["std/iter/Iterator.struct.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as an [<code>Object</code>].</p></div>"],["std/iter/Iterator.struct.html#method.collect","::std::iter::Iterator::collect","method","<div class=\"docs\"><p>Collect the iterator as a [<code>String</code>].</p></div>"],["std/is_writable.fn.html","::std::is_writable","function","<div class=\"docs\"><p>Test if the given <code>value</code> is writable.</p></div>"],["std/is_readable.fn.html","::std::is_readable","function","<div class=\"docs\"><p>Test if the given <code>value</code> is readable.</p></div>"],["std/io.module.html","::std::io","module","<div class=\"docs\"><p>The std::io module contains a number of common things</p></div>"],["std/io/println.macro.html","::std::io::println","macro","<div class=\"docs\"><p>Prints to output, with a newline.</p></div>"],["std/io/println.fn.html","::std::io::println","function","<div class=\"docs\"><p>Prints to output, with a newline.</p></div>"],["std/io/print.macro.html","::std::io::print","macro","<div class=\"docs\"><p>Prints to output.</p></div>"],["std/io/print.fn.html","::std::io::print","function","<div class=\"docs\"><p>Prints to output.</p></div>"],["std/io/dbg.macro.html","::std::io::dbg","macro","<div class=\"docs\"><p>Debug print the given argument.</p></div>"],["std/io/dbg.fn.html","::std::io::dbg","function","<div class=\"docs\"><p>Debug to output.</p></div>"],["std/io/Error.type.html","::std::io::Error","type",""],["std/i64.module.html","::std::i64","module",""],["std/i64/parse.fn.html","::std::i64::parse","function",""],["std/i64.type.html","::std::i64","type","<div class=\"docs\"><p>The primitive integer type.</p></div>"],["std/i64.type.html#method.to","::std::i64::to","method","<div class=\"docs\"><p>Convert an <code>int</code> to a <code>float</code>.</p></div>"],["std/i64.type.html#method.max","::std::i64::max","method","<div class=\"docs\"><p>Compares and returns the maximum of two values.</p></div>"],["std/i64.type.html#method.min","::std::i64::min","method","<div class=\"docs\"><p>Compares and returns the minimum of two values.</p></div>"],["std/i64.type.html#method.abs","::std::i64::abs","method","<div class=\"docs\"><p>Computes the absolute value of <code>self</code>.</p></div>"],["std/i64.type.html#method.pow","::std::i64::pow","method","<div class=\"docs\"><p>Raises self to the power of <code>exp</code>, using exponentiation by squaring.</p></div>"],["std/i64.type.html#method.checked_add","::std::i64::checked_add","method","<div class=\"docs\"><p>Checked integer addition. Computes <code>self + rhs</code>, returning <code>None</code> if</p></div>"],["std/i64.type.html#method.checked_sub","::std::i64::checked_sub","method","<div class=\"docs\"><p>Checked integer subtraction. Computes <code>self - rhs</code>, returning <code>None</code> if</p></div>"],["std/i64.type.html#method.checked_div","::std::i64::checked_div","method","<div class=\"docs\"><p>Checked integer division. Computes <code>self / rhs</code>, returning <code>None</code> if `rhs ==</p></div>"],["std/i64.type.html#method.checked_mul","::std::i64::checked_mul","method","<div class=\"docs\"><p>Checked integer multiplication. Computes <code>self * rhs</code>, returning <code>None</code> if</p></div>"],["std/i64.type.html#method.checked_rem","::std::i64::checked_rem","method","<div class=\"docs\"><p>Checked integer remainder. Computes <code>self % rhs</code>, returning <code>None</code> if `rhs</p></div>"],["std/i64.type.html#method.wrapping_add","::std::i64::wrapping_add","method","<div class=\"docs\"><p>Wrapping (modular) addition. Computes <code>self + rhs</code>, wrapping around at the</p></div>"],["std/i64.type.html#method.wrapping_sub","::std::i64::wrapping_sub","method","<div class=\"docs\"><p>Wrapping (modular) subtraction. Computes <code>self - rhs</code>, wrapping around at</p></div>"],["std/i64.type.html#method.wrapping_div","::std::i64::wrapping_div","method","<div class=\"docs\"><p>Wrapping (modular) division. Computes <code>self / rhs</code>, wrapping around at the</p></div>"],["std/i64.type.html#method.wrapping_mul","::std::i64::wrapping_mul","method","<div class=\"docs\"><p>Wrapping (modular) multiplication. Computes <code>self * rhs</code>, wrapping around at</p></div>"],["std/i64.type.html#method.wrapping_rem","::std::i64::wrapping_rem","method","<div class=\"docs\"><p>Wrapping (modular) remainder. Computes <code>self % rhs</code>, wrapping around at the</p></div>"],["std/i64.type.html#method.saturating_add","::std::i64::saturating_add","method","<div class=\"docs\"><p>Saturating integer addition. Computes <code>self + rhs</code>, saturating at the</p></div>"],["std/i64.type.html#method.saturating_sub","::std::i64::saturating_sub","method","<div class=\"docs\"><p>Saturating integer subtraction. Computes <code>self - rhs</code>, saturating at the</p></div>"],["std/i64.type.html#method.saturating_mul","::std::i64::saturating_mul","method","<div class=\"docs\"><p>Saturating integer multiplication. Computes <code>self * rhs</code>, saturating at the</p></div>"],["std/i64.type.html#method.saturating_abs","::std::i64::saturating_abs","method","<div class=\"docs\"><p>Saturating absolute value. Computes <code>self.abs()</code>, returning <code>MAX</code> if `self</p></div>"],["std/i64.type.html#method.saturating_pow","::std::i64::saturating_pow","method","<div class=\"docs\"><p>Saturating integer exponentiation. Computes <code>self.pow(exp)</code>, saturating at</p></div>"],["std/i64.type.html#method.signum","::std::i64::signum","method","<div class=\"docs\"><p>Returns a number representing sign of <code>self</code>.</p></div>"],["std/i64.type.html#method.is_positive","::std::i64::is_positive","method","<div class=\"docs\"><p>Returns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number is zero or</p></div>"],["std/i64.type.html#method.is_negative","::std::i64::is_negative","method","<div class=\"docs\"><p>Returns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number is zero or</p></div>"],["std/i64.type.html#method.to_string","::std::i64::to_string","method","<div class=\"docs\"><p>Returns the number as a string.</p></div>"],["std/hash.module.html","::std::hash","module","<div class=\"docs\"><p>Types for dealing with hashing in Rune.</p></div>"],["std/hash/Hasher.struct.html","::std::hash::Hasher","struct","<div class=\"docs\"><p>The default hasher used in Rune.</p></div>"],["std/future.module.html","::std::future","module",""],["std/future/join.fn.html","::std::future::join","function","<div class=\"docs\"><p>Waits for a collection of futures to complete and joins their result.</p></div>"],["std/future/Future.struct.html","::std::future::Future","struct","<div class=\"docs\"><p>A type-erased future that can only be unsafely polled in combination with</p></div>"],["std/fmt.module.html","::std::fmt","module",""],["std/fmt/format.macro.html","::std::fmt::format","macro","<div class=\"docs\"><p>Format a string using a format specifier.</p></div>"],["std/fmt/Formatter.struct.html","::std::fmt::Formatter","struct","<div class=\"docs\"><p>A formatter for the rune virtual machine.</p></div>"],["std/fmt/Format.struct.html","::std::fmt::Format","struct","<div class=\"docs\"><p>A format specification, wrapping an inner value.</p></div>"],["std/fmt/Error.type.html","::std::fmt::Error","type",""],["std/f64.module.html","::std::f64","module",""],["std/f64/parse.fn.html","::std::f64::parse","function",""],["std/f64.type.html","::std::f64","type","<div class=\"docs\"><p>The primitive float type.</p></div>"],["std/f64.type.html#method.is_nan","::std::f64::is_nan","method","<div class=\"docs\"><p>Returns <code>true</code> if this value is NaN.</p></div>"],["std/f64.type.html#method.is_infinite","::std::f64::is_infinite","method","<div class=\"docs\"><p>Returns <code>true</code> if this value is positive infinity or negative infinity, and</p></div>"],["std/f64.type.html#method.is_finite","::std::f64::is_finite","method","<div class=\"docs\"><p>Returns <code>true</code> if this number is neither infinite nor NaN.</p></div>"],["std/f64.type.html#method.is_subnormal","::std::f64::is_subnormal","method","<div class=\"docs\"><p>Returns <code>true</code> if the number is [subnormal].</p></div>"],["std/f64.type.html#method.is_normal","::std::f64::is_normal","method","<div class=\"docs\"><p>Returns <code>true</code> if the number is neither zero, infinite, [subnormal], or NaN.</p></div>"],["std/f64.type.html#method.max","::std::f64::max","method","<div class=\"docs\"><p>Returns the maximum of the two numbers, ignoring NaN.</p></div>"],["std/f64.type.html#method.min","::std::f64::min","method","<div class=\"docs\"><p>Returns the minimum of the two numbers, ignoring NaN.</p></div>"],["std/f64.type.html#method.abs","::std::f64::abs","method","<div class=\"docs\"><p>Computes the absolute value of <code>self</code>.</p></div>"],["std/f64.type.html#method.powf","::std::f64::powf","method","<div class=\"docs\"><p>Raises a number to a floating point power.</p></div>"],["std/f64.type.html#method.powi","::std::f64::powi","method","<div class=\"docs\"><p>Raises a number to an integer power.</p></div>"],["std/f64.type.html#method.to","::std::f64::to","method","<div class=\"docs\"><p>Convert a float to a an integer.</p></div>"],["std/collections.module.html","::std::collections","module","<div class=\"docs\"><p>The <code>std::collections</code> module.</p></div>"],["std/collections/VecDeque.struct.html","::std::collections::VecDeque","struct","<div class=\"docs\"><p>A double-ended queue implemented with a growable ring buffer.</p></div>"],["std/collections/VecDeque.struct.html#method.new","::std::collections::VecDeque::new","method","<div class=\"docs\"><p>Creates an empty deque.</p></div>"],["std/collections/VecDeque.struct.html#method.with_capacity","::std::collections::VecDeque::with_capacity","method","<div class=\"docs\"><p>Creates an empty deque with space for at least <code>capacity</code> elements.</p></div>"],["std/collections/VecDeque.struct.html#method.from","::std::collections::VecDeque::from","method","<div class=\"docs\"><p>Construct a <a href=\"VecDeque.struct.html\" title=\"struct VecDeque\"><code>VecDeque</code></a> from a value.</p></div>"],["std/collections/VecDeque.struct.html#method.extend","::std::collections::VecDeque::extend","method","<div class=\"docs\"><p>Extend this VecDeque with something that implements the [<code>INTO_ITER</code>]</p></div>"],["std/collections/VecDeque.struct.html#method.insert","::std::collections::VecDeque::insert","method","<div class=\"docs\"><p>Inserts an element at <code>index</code> within the deque, shifting all elements</p></div>"],["std/collections/VecDeque.struct.html#method.iter","::std::collections::VecDeque::iter","method","<div class=\"docs\"><p>Returns a front-to-back iterator.</p></div>"],["std/collections/VecDeque.struct.html#method.reserve","::std::collections::VecDeque::reserve","method","<div class=\"docs\"><p>Reserves capacity for at least <code>additional</code> more elements to be inserted</p></div>"],["std/collections/VecDeque.struct.html#method.len","::std::collections::VecDeque::len","method","<div class=\"docs\"><p>Returns the number of elements in the deque.</p></div>"],["std/collections/VecDeque.struct.html#method.capacity","::std::collections::VecDeque::capacity","method","<div class=\"docs\"><p>Returns the number of elements the deque can hold without reallocating.</p></div>"],["std/collections/VecDeque.struct.html#method.front","::std::collections::VecDeque::front","method","<div class=\"docs\"><p>Provides a reference to the front element, or <code>None</code> if the deque is</p></div>"],["std/collections/VecDeque.struct.html#method.back","::std::collections::VecDeque::back","method","<div class=\"docs\"><p>Provides a reference to the back element, or <code>None</code> if the deque is</p></div>"],["std/collections/VecDeque.struct.html#method.push_back","::std::collections::VecDeque::push_back","method","<div class=\"docs\"><p>Appends an element to the back of the deque.</p></div>"],["std/collections/VecDeque.struct.html#method.push_front","::std::collections::VecDeque::push_front","method","<div class=\"docs\"><p>Prepends an element to the deque.</p></div>"],["std/collections/VecDeque.struct.html#method.pop_front","::std::collections::VecDeque::pop_front","method","<div class=\"docs\"><p>Removes the first element and returns it, or <code>None</code> if the deque is</p></div>"],["std/collections/VecDeque.struct.html#method.pop_back","::std::collections::VecDeque::pop_back","method","<div class=\"docs\"><p>Removes the last element from the deque and returns it, or <code>None</code> if it</p></div>"],["std/collections/VecDeque.struct.html#method.remove","::std::collections::VecDeque::remove","method","<div class=\"docs\"><p>Removes and returns the element at <code>index</code> from the deque.</p></div>"],["std/collections/VecDeque.struct.html#method.rotate_left","::std::collections::VecDeque::rotate_left","method","<div class=\"docs\"><p>Rotates the double-ended queue <code>mid</code> places to the left.</p></div>"],["std/collections/VecDeque.struct.html#method.rotate_right","::std::collections::VecDeque::rotate_right","method","<div class=\"docs\"><p>Rotates the double-ended queue <code>k</code> places to the right.</p></div>"],["std/collections/HashSet.struct.html","::std::collections::HashSet","struct",""],["std/collections/HashSet.struct.html#method.new","::std::collections::HashSet::new","method","<div class=\"docs\"><p>Creates an empty <code>HashSet</code>.</p></div>"],["std/collections/HashSet.struct.html#method.with_capacity","::std::collections::HashSet::with_capacity","method","<div class=\"docs\"><p>Creates an empty <code>HashSet</code> with at least the specified capacity.</p></div>"],["std/collections/HashSet.struct.html#method.len","::std::collections::HashSet::len","method","<div class=\"docs\"><p>Returns the number of elements in the set.</p></div>"],["std/collections/HashSet.struct.html#method.is_empty","::std::collections::HashSet::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the set contains no elements.</p></div>"],["std/collections/HashSet.struct.html#method.capacity","::std::collections::HashSet::capacity","method","<div class=\"docs\"><p>Returns the number of elements the set can hold without reallocating.</p></div>"],["std/collections/HashSet.struct.html#method.insert","::std::collections::HashSet::insert","method","<div class=\"docs\"><p>Adds a value to the set.</p></div>"],["std/collections/HashSet.struct.html#method.remove","::std::collections::HashSet::remove","method","<div class=\"docs\"><p>Removes a value from the set. Returns whether the value was present in</p></div>"],["std/collections/HashSet.struct.html#method.contains","::std::collections::HashSet::contains","method","<div class=\"docs\"><p>Returns <code>true</code> if the set contains a value.</p></div>"],["std/collections/HashSet.struct.html#method.clear","::std::collections::HashSet::clear","method","<div class=\"docs\"><p>Clears the set, removing all values.</p></div>"],["std/collections/HashSet.struct.html#method.difference","::std::collections::HashSet::difference","method","<div class=\"docs\"><p>Visits the values representing the difference, i.e., the values that are</p></div>"],["std/collections/HashSet.struct.html#method.extend","::std::collections::HashSet::extend","method","<div class=\"docs\"><p>Extend this set from an iterator.</p></div>"],["std/collections/HashSet.struct.html#method.intersection","::std::collections::HashSet::intersection","method","<div class=\"docs\"><p>Visits the values representing the intersection, i.e., the values that</p></div>"],["std/collections/HashSet.struct.html#method.union","::std::collections::HashSet::union","method","<div class=\"docs\"><p>Visits the values representing the union, i.e., all the values in <code>self</code></p></div>"],["std/collections/HashSet.struct.html#method.iter","::std::collections::HashSet::iter","method","<div class=\"docs\"><p>Iterate over the hash set.</p></div>"],["std/collections/HashSet.struct.html#method.clone","::std::collections::HashSet::clone","method",""],["std/collections/HashSet.struct.html#method.from","::std::collections::HashSet::from","method",""],["std/collections/HashMap.struct.html","::std::collections::HashMap","struct",""],["std/collections/HashMap.struct.html#method.new","::std::collections::HashMap::new","method","<div class=\"docs\"><p>Creates an empty <code>HashMap</code>.</p></div>"],["std/collections/HashMap.struct.html#method.with_capacity","::std::collections::HashMap::with_capacity","method","<div class=\"docs\"><p>Creates an empty <code>HashMap</code> with at least the specified capacity.</p></div>"],["std/collections/HashMap.struct.html#method.len","::std::collections::HashMap::len","method","<div class=\"docs\"><p>Returns the number of elements in the map.</p></div>"],["std/collections/HashMap.struct.html#method.capacity","::std::collections::HashMap::capacity","method","<div class=\"docs\"><p>Returns the number of elements the map can hold without reallocating.</p></div>"],["std/collections/HashMap.struct.html#method.insert","::std::collections::HashMap::insert","method","<div class=\"docs\"><p>Inserts a key-value pair into the map.</p></div>"],["std/collections/HashMap.struct.html#method.get","::std::collections::HashMap::get","method","<div class=\"docs\"><p>Returns the value corresponding to the [<code>Key</code>].</p></div>"],["std/collections/HashMap.struct.html#method.contains_key","::std::collections::HashMap::contains_key","method","<div class=\"docs\"><p>Returns <code>true</code> if the map contains a value for the specified [<code>Key</code>].</p></div>"],["std/collections/HashMap.struct.html#method.remove","::std::collections::HashMap::remove","method","<div class=\"docs\"><p>Removes a key from the map, returning the value at the [<code>Key</code>] if the</p></div>"],["std/collections/HashMap.struct.html#method.clear","::std::collections::HashMap::clear","method","<div class=\"docs\"><p>Clears the map, removing all key-value pairs. Keeps the allocated memory</p></div>"],["std/collections/HashMap.struct.html#method.is_empty","::std::collections::HashMap::is_empty","method","<div class=\"docs\"><p>Returns <code>true</code> if the map contains no elements.</p></div>"],["std/collections/HashMap.struct.html#method.iter","::std::collections::HashMap::iter","method","<div class=\"docs\"><p>An iterator visiting all key-value pairs in arbitrary order.</p></div>"],["std/collections/HashMap.struct.html#method.keys","::std::collections::HashMap::keys","method","<div class=\"docs\"><p>An iterator visiting all keys in arbitrary order.</p></div>"],["std/collections/HashMap.struct.html#method.values","::std::collections::HashMap::values","method","<div class=\"docs\"><p>An iterator visiting all values in arbitrary order.</p></div>"],["std/collections/HashMap.struct.html#method.extend","::std::collections::HashMap::extend","method","<div class=\"docs\"><p>Extend this map from an iterator.</p></div>"],["std/collections/HashMap.struct.html#method.from","::std::collections::HashMap::from","method","<div class=\"docs\"><p>Convert a hashmap from a <code>value</code>.</p></div>"],["std/collections/HashMap.struct.html#method.clone","::std::collections::HashMap::clone","method","<div class=\"docs\"><p>Clone the map.</p></div>"],["std/cmp.module.html","::std::cmp","module",""],["std/cmp/min.fn.html","::std::cmp::min","function","<div class=\"docs\"><p>Compares and returns the minimum of two values.</p></div>"],["std/cmp/max.fn.html","::std::cmp::max","function","<div class=\"docs\"><p>Compares and returns the maximum of two values.</p></div>"],["std/cmp/Ordering.enum.html","::std::cmp::Ordering","enum","<div class=\"docs\"><p>An <code>Ordering</code> is the result of a comparison between two values.</p></div>"],["std/cmp/Ordering.enum.html#variant.Less","::std::cmp::Ordering::Less","variant","<div class=\"docs\"><p>An ordering where a compared value is less than another.</p></div>"],["std/cmp/Ordering.enum.html#variant.Equal","::std::cmp::Ordering::Equal","variant","<div class=\"docs\"><p>An ordering where a compared value is equal to another.</p></div>"],["std/cmp/Ordering.enum.html#variant.Greater","::std::cmp::Ordering::Greater","variant","<div class=\"docs\"><p>An ordering where a compared value is greater than another.</p></div>"],["std/char.module.html","::std::char","module",""],["std/char/from_i64.fn.html","::std::char::from_i64","function","<div class=\"docs\"><p>Try to convert a number into a character.</p></div>"],["std/char/ParseCharError.type.html","::std::char::ParseCharError","type",""],["std/char.type.html","::std::char","type","<div class=\"docs\"><p>The primitive character type.</p></div>"],["std/char.type.html#method.to_i64","::std::char::to_i64","method","<div class=\"docs\"><p>Convert a character into an integer.</p></div>"],["std/char.type.html#method.is_alphabetic","::std::char::is_alphabetic","method","<div class=\"docs\"><p>Returns <code>true</code> if this <code>char</code> has the <code>Alphabetic</code> property.</p></div>"],["std/char.type.html#method.is_alphanumeric","::std::char::is_alphanumeric","method","<div class=\"docs\"><p>Returns <code>true</code> if this <code>char</code> satisfies either [<code>is_alphabetic()</code>] or [<code>is_numeric()</code>].</p></div>"],["std/char.type.html#method.is_control","::std::char::is_control","method","<div class=\"docs\"><p>Returns <code>true</code> if this <code>char</code> has the general category for control codes.</p></div>"],["std/char.type.html#method.is_lowercase","::std::char::is_lowercase","method","<div class=\"docs\"><p>Returns <code>true</code> if this <code>char</code> has the <code>Lowercase</code> property.</p></div>"],["std/char.type.html#method.is_numeric","::std::char::is_numeric","method","<div class=\"docs\"><p>Returns <code>true</code> if this <code>char</code> has one of the general categories for numbers.</p></div>"],["std/char.type.html#method.is_uppercase","::std::char::is_uppercase","method","<div class=\"docs\"><p>Returns <code>true</code> if this <code>char</code> has the <code>Uppercase</code> property.</p></div>"],["std/char.type.html#method.is_whitespace","::std::char::is_whitespace","method","<div class=\"docs\"><p>Returns <code>true</code> if this <code>char</code> has the <code>White_Space</code> property.</p></div>"],["std/char.type.html#method.to_digit","::std::char::to_digit","method","<div class=\"docs\"><p>Converts a <code>char</code> to a digit in the given radix.</p></div>"],["std/bytes.module.html","::std::bytes","module",""],["std/bytes/Bytes.struct.html","::std::bytes::Bytes","struct","<div class=\"docs\"><p>A vector of bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.new","::std::bytes::Bytes::new","method","<div class=\"docs\"><p>Construct a new byte array.</p></div>"],["std/bytes/Bytes.struct.html#method.with_capacity","::std::bytes::Bytes::with_capacity","method","<div class=\"docs\"><p>Construct a byte array with the given preallocated capacity.</p></div>"],["std/bytes/Bytes.struct.html#method.from_vec","::std::bytes::Bytes::from_vec","method","<div class=\"docs\"><p>Convert a byte array into bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.into_vec","::std::bytes::Bytes::into_vec","method","<div class=\"docs\"><p>Convert the byte array into a vector of bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.as_vec","::std::bytes::Bytes::as_vec","method","<div class=\"docs\"><p>Convert the byte array into a vector of bytes without consuming it.</p></div>"],["std/bytes/Bytes.struct.html#method.extend","::std::bytes::Bytes::extend","method","<div class=\"docs\"><p>Extend these bytes with another collection of bytes.</p></div>"],["std/bytes/Bytes.struct.html#method.extend_str","::std::bytes::Bytes::extend_str","method","<div class=\"docs\"><p>Extend this bytes collection with a string.</p></div>"],["std/bytes/Bytes.struct.html#method.pop","::std::bytes::Bytes::pop","method","<div class=\"docs\"><p>Pop the last byte.</p></div>"],["std/bytes/Bytes.struct.html#method.last","::std::bytes::Bytes::last","method","<div class=\"docs\"><p>Get the last byte.</p></div>"],["std/bytes/Bytes.struct.html#method.len","::std::bytes::Bytes::len","method","<div class=\"docs\"><p>Get the length of the bytes collection.</p></div>"],["std/bytes/Bytes.struct.html#method.is_empty","::std::bytes::Bytes::is_empty","method","<div class=\"docs\"><p>Test if the collection is empty.</p></div>"],["std/bytes/Bytes.struct.html#method.capacity","::std::bytes::Bytes::capacity","method","<div class=\"docs\"><p>Returns the total number of elements the vector can hold without</p></div>"],["std/bytes/Bytes.struct.html#method.clear","::std::bytes::Bytes::clear","method","<div class=\"docs\"><p>Clears the vector, removing all values.</p></div>"],["std/bytes/Bytes.struct.html#method.reserve","::std::bytes::Bytes::reserve","method","<div class=\"docs\"><p>Reserves capacity for at least <code>additional</code> more elements to be inserted in</p></div>"],["std/bytes/Bytes.struct.html#method.reserve_exact","::std::bytes::Bytes::reserve_exact","method","<div class=\"docs\"><p>Reserves the minimum capacity for at least <code>additional</code> more elements to be</p></div>"],["std/bytes/Bytes.struct.html#method.clone","::std::bytes::Bytes::clone","method","<div class=\"docs\"><p>Clone the byte array.</p></div>"],["std/bytes/Bytes.struct.html#method.shrink_to_fit","::std::bytes::Bytes::shrink_to_fit","method","<div class=\"docs\"><p>Shrinks the capacity of the byte array as much as possible.</p></div>"],["std/bool.type.html","::std::bool","type","<div class=\"docs\"><p>The primitive boolean type.</p></div>"],["std/any.module.html","::std::any","module","<div class=\"docs\"><p>Utilities for dynamic typing or type reflection.</p></div>"],["std/any/type_name_of_val.fn.html","::std::any::type_name_of_val","function","<div class=\"docs\"><p>Get the type name of a value.</p></div>"],["std/any/Type.type.html","::std::any::Type","type","<div class=\"docs\"><p>Represents a type in the Rune type system.</p></div>"],["std/any/Type.type.html#method.of_val","::std::any::Type::of_val","method","<div class=\"docs\"><p>Convert a value into a [<code>Type</code>] object.</p></div>"],["fs.module.html","::fs","module",""],["fs/read_to_string.fn.html","::fs::read_to_string","function",""],["json.module.html","::json","module","<div class=\"docs\"><p>Module for processing JSON.</p></div>"],["json/to_string.fn.html","::json::to_string","function","<div class=\"docs\"><p>Convert any value to a json string.</p></div>"],["json/to_bytes.fn.html","::json::to_bytes","function","<div class=\"docs\"><p>Convert any value to json bytes.</p></div>"],["json/from_string.fn.html","::json::from_string","function","<div class=\"docs\"><p>Convert a JSON string into a rune value.</p></div>"],["json/from_bytes.fn.html","::json::from_bytes","function","<div class=\"docs\"><p>Convert JSON bytes into a rune value.</p></div>"],["json/Error.struct.html","::json::Error","struct","<div class=\"docs\"><p>Error type raised during JSON serialization.</p></div>"],["signal.module.html","::signal","module",""],["signal/ctrl_c.fn.html","::signal::ctrl_c","function","<div class=\"docs\"><p>Completes when a &quot;ctrl-c&quot; notification is sent to the process.</p></div>"],["time.module.html","::time","module",""],["time/sleep.fn.html","::time::sleep","function","<div class=\"docs\"><p>Sleep for the given <a href=\"Duration.struct.html\" title=\"struct Duration\"><code>Duration</code></a>.</p></div>"],["time/Duration.struct.html","::time::Duration","struct",""],["time/Duration.struct.html#method.from_secs","::time::Duration::from_secs","method","<div class=\"docs\"><p>Construct a duration from the given number of seconds.</p></div>"],["rand.module.html","::rand","module",""],["rand/int_range.fn.html","::rand::int_range","function",""],["rand/int.fn.html","::rand::int","function",""],["rand/WyRand.struct.html","::rand::WyRand","struct",""],["rand/WyRand.struct.html#method.int","::rand::WyRand::int","method",""],["rand/WyRand.struct.html#method.int_range","::rand::WyRand::int_range","method",""],["rand/Pcg64.struct.html","::rand::Pcg64","struct",""],["rand/Pcg64.struct.html#method.int","::rand::Pcg64::int","method",""],["rand/Pcg64.struct.html#method.int_range","::rand::Pcg64::int_range","method",""],["toml.module.html","::toml","module",""],["toml/to_string.fn.html","::toml::to_string","function","<div class=\"docs\"><p>Convert any value to a toml string.</p></div>"],["toml/to_bytes.fn.html","::toml::to_bytes","function","<div class=\"docs\"><p>Convert any value to toml bytes.</p></div>"],["toml/ser.module.html","::toml::ser","module",""],["toml/ser/Error.struct.html","::toml::ser::Error","struct",""],["toml/from_string.fn.html","::toml::from_string","function","<div class=\"docs\"><p>Convert a string of TOML into a rune value.</p></div>"],["toml/from_bytes.fn.html","::toml::from_bytes","function","<div class=\"docs\"><p>Convert bytes of TOML into a rune value.</p></div>"],["toml/de.module.html","::toml::de","module",""],["toml/de/Error.struct.html","::toml::de::Error","struct",""],["http.module.html","::http","module",""],["http/get.fn.html","::http::get","function","<div class=\"docs\"><p>Shorthand for generating a get request.</p></div>"],["http/StatusCode.struct.html","::http::StatusCode","struct",""],["http/Response.struct.html","::http::Response","struct","<div class=\"docs\"><p>A Response to a submitted [<code>Request</code>].</p></div>"],["http/Response.struct.html#method.text","::http::Response::text","method","<div class=\"docs\"><p>Get the response as text.</p></div>"],["http/Response.struct.html#method.json","::http::Response::json","method","<div class=\"docs\"><p>Get the response as a Rune value decoded from JSON.</p></div>"],["http/Response.struct.html#method.status","::http::Response::status","method","<div class=\"docs\"><p>Get the status code of the response.</p></div>"],["http/RequestBuilder.struct.html","::http::RequestBuilder","struct","<div class=\"docs\"><p>A builder to construct the properties of a Request.</p></div>"],["http/RequestBuilder.struct.html#method.send","::http::RequestBuilder::send","method","<div class=\"docs\"><p>Send the request being built.</p></div>"],["http/RequestBuilder.struct.html#method.header","::http::RequestBuilder::header","method","<div class=\"docs\"><p>Modify a header in the request.</p></div>"],["http/RequestBuilder.struct.html#method.body_bytes","::http::RequestBuilder::body_bytes","method","<div class=\"docs\"><p>Set the request body from bytes.</p></div>"],["http/Error.struct.html","::http::Error","struct",""],["http/Client.struct.html","::http::Client","struct","<div class=\"docs\"><p>An asynchronous Client to make Requests with.</p></div>"],["http/Client.struct.html#method.new","::http::Client::new","method","<div class=\"docs\"><p>Construct a new http client.</p></div>"],["http/Client.struct.html#method.get","::http::Client::get","method","<div class=\"docs\"><p>Construct a builder to GET the given <code>url</code>.</p></div>"],["http/Client.struct.html#method.post","::http::Client::post","method","<div class=\"docs\"><p>Construct a builder to POST to the given <code>url</code>.</p></div>"]];
