<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/FiraSans-Medium-4ao_Crym_Z97hoxWqz7A4NshIi71DoT6u_IZY8EN1wQ.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/FiraSans-Regular-D-SK3tCXwqEZQqcL_vSFEKv4dajoAPQ9QAfc6NKjrr4.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/NanumBarunGothic-Regular-6_u5bM1Z_P691vS3fhfHDGxiAIyFL9cppAIAJVg151s.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceCodePro-It.ttf-9l14W6OSkW1dJiiKKavLd1_QdTHtv_Sl67HNQoWSu8g.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceCodePro-Regular-cU7uKbcNGR9b9LOga2jyxQUisTA9McfUTc79zF-d79A.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceCodePro-Semibold-SIsoBuinYZLCzu8ptJi6AeRraXV4sgDt4bXK2FXDebo.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceSerif4-Bold-_xCsH4HwyJAK__GCoff-x-hd_IB1y5MahmUNF4NgQsU.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceSerif4-Regular-KooC6dILCRRRWHXSr7KvGNFHM6ZZ054WggDt4WT32GU.woff2">
<link rel="stylesheet" type="text/css" href="../../syntax-hOylezLDPQHh3rL4EpbplIubIPDrhPsdZ6NqLZXhtw8.css"><link rel="stylesheet" type="text/css" href="../../runedoc-RpGnmLv54qA3EswoqjjtiCiSLHPpqlrooIFm2cj7ozI.css">
<script lang="text/javascript" src="../../search-11hco3hjyxbot2LtE0-3TZtpn7blY_QZbxQ4j4EpDNE.js"></script>
<script lang="text/javascript" src="../../index-XC5zXmGdTTyHm_a4mVNGX7ZhKuJRMko_Hopj92QPqPs.js"></script>
</head>
<body data-path="std/cmp">
    <div id="container">
        <div id="search">
            <div id="search-form">
                <input id="search-input" placeholder="Click to search..." type="text" />
            </div>

            <h3 id="search-title" class="hidden title">Results</h3>

            <div id="search-results" class="hidden"></div>
        </div>

        <div id="content">

            <div class="title-wrapper">
                <h3 class="title">Trait <a class="module" href="../../std.module.html">std</a>::<a class="module" href="../cmp.module.html">cmp</a>::<span class="trait">PartialEq</span></h3>
                <a class="overview" href="../../index.html">Overview</a>
            </div>
            
<div class="docs"><p>Trait for comparisons using the equality operator.</p><p>Implementing this trait for types provides the <code>==</code> and <code>!=</code> operators for those types.</p><p><code>x.eq(y)</code> can also be written <code>x == y</code>, and <code>x.ne(y)</code> can be written <code>x != y</code>. We use the easier-to-read infix notation in the remainder of this documentation.</p><p>This trait allows for comparisons using the equality operator, for types that do not have a full equivalence relation. For example, in floating point numbers <code>NaN != NaN</code>, so floating point types implement <code>PartialEq</code> but not [<code>trait@Eq</code>]. Formally speaking, when <code>Rhs == Self</code>, this trait corresponds to a <a href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">partial equivalence relation</a>.</p><p>Implementations must ensure that <code>eq</code> and <code>ne</code> are consistent with each other:</p><ul><li><code>a != b</code> if and only if <code>!(a == b)</code>.</li></ul><p>The default implementation of <code>ne</code> provides this consistency and is almost always sufficient. It should not be overridden without very good reason.</p><p>If [<code>PartialOrd</code>] or [<code>Ord</code>] are also implemented for <code>Self</code> and <code>Rhs</code>, their methods must also be consistent with <code>PartialEq</code> (see the documentation of those traits for the exact requirements). It&#39;s easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</p><p>The equality relation <code>==</code> must satisfy the following conditions (for all <code>a</code>, <code>b</code>, <code>c</code> of type <code>A</code>, <code>B</code>, <code>C</code>):</p><ul><li><p><strong>Symmetry</strong>: if <code>A: PartialEq&lt;B&gt;</code> and <code>B: PartialEq&lt;A&gt;</code>, then <strong><code>a == b</code> implies <code>b == a</code></strong>; and</p></li><li><p><strong>Transitivity</strong>: if <code>A: PartialEq&lt;B&gt;</code> and <code>B: PartialEq&lt;C&gt;</code> and <code>A: PartialEq&lt;C&gt;</code>, then <strong><code>a == b</code> and <code>b == c</code> implies <code>a == c</code></strong>. This must also work for longer chains, such as when <code>A: PartialEq&lt;B&gt;</code>, <code>B: PartialEq&lt;C&gt;</code>, <code>C: PartialEq&lt;D&gt;</code>, and <code>A: PartialEq&lt;D&gt;</code> all exist.</p></li></ul><p>Note that the <code>B: PartialEq&lt;A&gt;</code> (symmetric) and <code>A: PartialEq&lt;C&gt;</code> (transitive) impls are not forced to exist, but these requirements apply whenever they do exist.</p><p>Violating these requirements is a logic error. The behavior resulting from a logic error is not specified, but users of the trait must ensure that such logic errors do <em>not</em> result in undefined behavior. This means that <code>unsafe</code> code <strong>must not</strong> rely on the correctness of these methods.</p><h2>Cross-crate considerations</h2><p>Upholding the requirements stated above can become tricky when one crate implements <code>PartialEq</code> for a type of another crate (i.e., to allow comparing one of its own types with a type from the standard library). The recommendation is to never implement this trait for a foreign type. In other words, such a crate should do <code>impl PartialEq&lt;ForeignType&gt; for LocalType</code>, but it should <em>not</em> do <code>impl PartialEq&lt;LocalType&gt; for ForeignType</code>.</p><p>This avoids the problem of transitive chains that criss-cross crate boundaries: for all local types <code>T</code>, you may assume that no other crate will add <code>impl</code>s that allow comparing <code>T == U</code>. In other words, if other crates add <code>impl</code>s that allow building longer transitive chains <code>U1 == ... == T == V1 == ...</code>, then all the types that appear to the right of <code>T</code> must be types that the crate defining <code>T</code> already knows about. This rules out transitive chains where downstream crates can add new <code>impl</code>s that &quot;stitch together&quot; comparisons of foreign types in ways that violate transitivity.</p><p>Not having such foreign <code>impl</code>s also avoids forward compatibility issues where one crate adding more <code>PartialEq</code> implementations can cause build failures in downstream crates.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="storage type rust">let</span> x <span class="keyword operator rust">=</span> <span class="constant numeric integer decimal rust">0</span><span class="punctuation terminator rust">;</span>
<span class="storage type rust">let</span> y <span class="keyword operator rust">=</span> <span class="constant numeric integer decimal rust">1</span><span class="punctuation terminator rust">;</span>

<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>x <span class="keyword operator rust">=</span><span class="keyword operator rust">=</span> y<span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>x.<span class="support function rust">eq</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>y</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="support macro rust">assert!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.<span class="support function rust">eq</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="keyword operator rust">!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.<span class="support function rust">eq</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="support macro rust">assert!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">=</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">!</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
            

            <h4 class="section-title">Methods</h4>
            
                <div class="item item-fn">
                    <div id="method.eq" class="item-title">
                    fn <a href="#method.eq" class="fn">eq</a>(value: <span class="any">any</span>, value1: <span class="any">any</span>) -&gt; <a class="type" href="../bool.type.html">bool</a>
                    
                    </div>
                    <div class="docs"><p>Compare two values for equality.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="support function rust">eq</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">2</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="support function rust">eq</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">2</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="support function rust">eq</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">1</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.ne" class="item-title">
                    fn <a href="#method.ne" class="fn">ne</a>(value: <span class="any">any</span>, value1: <span class="any">any</span>) -&gt; <a class="type" href="../bool.type.html">bool</a>
                    
                    </div>
                    <div class="docs"><p>Compare two values for inequality.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="support function rust">ne</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">2</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="support function rust">ne</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">2</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="support function rust">ne</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">1</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>



        </div>
    </div>
</body>
