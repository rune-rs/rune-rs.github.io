<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/FiraSans-Medium-4ao_Crym_Z97hoxWqz7A4NshIi71DoT6u_IZY8EN1wQ.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/FiraSans-Regular-D-SK3tCXwqEZQqcL_vSFEKv4dajoAPQ9QAfc6NKjrr4.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/NanumBarunGothic-Regular-6_u5bM1Z_P691vS3fhfHDGxiAIyFL9cppAIAJVg151s.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceCodePro-It.ttf-9l14W6OSkW1dJiiKKavLd1_QdTHtv_Sl67HNQoWSu8g.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceCodePro-Regular-cU7uKbcNGR9b9LOga2jyxQUisTA9McfUTc79zF-d79A.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceCodePro-Semibold-SIsoBuinYZLCzu8ptJi6AeRraXV4sgDt4bXK2FXDebo.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceSerif4-Bold-_xCsH4HwyJAK__GCoff-x-hd_IB1y5MahmUNF4NgQsU.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../fonts/SourceSerif4-Regular-KooC6dILCRRRWHXSr7KvGNFHM6ZZ054WggDt4WT32GU.woff2">
<link rel="stylesheet" type="text/css" href="../../syntax-hOylezLDPQHh3rL4EpbplIubIPDrhPsdZ6NqLZXhtw8.css"><link rel="stylesheet" type="text/css" href="../../runedoc-RpGnmLv54qA3EswoqjjtiCiSLHPpqlrooIFm2cj7ozI.css">
<script lang="text/javascript" src="../../search-11hco3hjyxbot2LtE0-3TZtpn7blY_QZbxQ4j4EpDNE.js"></script>
<script lang="text/javascript" src="../../index-f-SvHwnfE2rDfWKEVpb4gXcfg-Gq5PzgQ2sOSBfA0Rs.js"></script>
</head>
<body data-path="std/cmp">
    <div id="container">
        <div id="search">
            <div id="search-form">
                <input id="search-input" placeholder="Click to search..." type="text" />
            </div>

            <h3 id="search-title" class="hidden title">Results</h3>

            <div id="search-results" class="hidden"></div>
        </div>

        <div id="content">

            <div class="title-wrapper">
                <h3 class="title">Trait <a class="module" href="../../std.module.html">std</a>::<a class="module" href="../cmp.module.html">cmp</a>::<span class="trait">PartialOrd</span></h3>
                <a class="overview" href="../../index.html">Overview</a>
            </div>
            
<div class="docs"><p>Trait for types that form a <a href="https://en.wikipedia.org/wiki/Partial_order">partial order</a>.</p><p>The <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> methods of this trait can be called using the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> operators, respectively.</p><p>The methods of this trait must be consistent with each other and with those of [<code>PartialEq</code>]. The following conditions must hold:</p><ol><li><code>a == b</code> if and only if <code>partial_cmp(a, b) == Some(Equal)</code>.</li><li><code>a &lt; b</code> if and only if <code>partial_cmp(a, b) == Some(Less)</code></li><li><code>a &gt; b</code> if and only if <code>partial_cmp(a, b) == Some(Greater)</code></li><li><code>a &lt;= b</code> if and only if <code>a &lt; b || a == b</code> 5. <code>a &gt;= b</code> if and only if <code>a &gt; b || a == b</code></li><li><code>a != b</code> if and only if <code>!(a == b)</code>.</li></ol><p>Conditions 2â€“5 above are ensured by the default implementation. Condition 6 is already ensured by [<code>PartialEq</code>].</p><p>If [<code>Ord</code>] is also implemented for <code>Self</code> and <code>Rhs</code>, it must also be consistent with <code>partial_cmp</code> (see the documentation of that trait for the exact requirements). It&#39;s easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</p><p>The comparison relations must satisfy the following conditions (for all <code>a</code>, <code>b</code>, <code>c</code> of type <code>A</code>, <code>B</code>, <code>C</code>):</p><ul><li><strong>Transitivity</strong>: if <code>A: PartialOrd&lt;B&gt;</code> and <code>B: PartialOrd&lt;C&gt;</code> and <code>A: PartialOrd&lt;C&gt;</code>, then <code>a &lt; b</code> and <code>b &lt; c</code> implies <code>a &lt; c</code>. The same must hold for both <code>==</code> and <code>&gt;</code>. This must also work for longer chains, such as when <code>A: PartialOrd&lt;B&gt;</code>, <code>B: PartialOrd&lt;C&gt;</code>, <code>C: PartialOrd&lt;D&gt;</code>, and <code>A: PartialOrd&lt;D&gt;</code> all exist.</li><li><strong>Duality</strong>: if <code>A: PartialOrd&lt;B&gt;</code> and <code>B: PartialOrd&lt;A&gt;</code>, then <code>a &lt; b</code> if and only if <code>b &gt; a</code>.</li></ul><p>Note that the <code>B: PartialOrd&lt;A&gt;</code> (dual) and <code>A: PartialOrd&lt;C&gt;</code> (transitive) impls are not forced to exist, but these requirements apply whenever they do exist.</p><p>Violating these requirements is a logic error. The behavior resulting from a logic error is not specified, but users of the trait must ensure that such logic errors do <em>not</em> result in undefined behavior. This means that <code>unsafe</code> code <strong>must not</strong> rely on the correctness of these methods.</p><h2>Cross-crate considerations</h2><p>Upholding the requirements stated above can become tricky when one crate implements <code>PartialOrd</code> for a type of another crate (i.e., to allow comparing one of its own types with a type from the standard library). The recommendation is to never implement this trait for a foreign type. In other words, such a crate should do <code>impl PartialOrd&lt;ForeignType&gt; for LocalType</code>, but it should <em>not</em> do <code>impl PartialOrd&lt;LocalType&gt; for ForeignType</code>.</p><p>This avoids the problem of transitive chains that criss-cross crate boundaries: for all local types <code>T</code>, you may assume that no other crate will add <code>impl</code>s that allow comparing <code>T &lt; U</code>. In other words, if other crates add <code>impl</code>s that allow building longer transitive chains <code>U1 &lt; ... &lt; T &lt; V1 &lt; ...</code>, then all the types that appear to the right of <code>T</code> must be types that the crate defining <code>T</code> already knows about. This rules out transitive chains where downstream crates can add new <code>impl</code>s that &quot;stitch together&quot; comparisons of foreign types in ways that violate transitivity.</p><p>Not having such foreign <code>impl</code>s also avoids forward compatibility issues where one crate adding more <code>PartialOrd</code> implementations can cause build failures in downstream crates.</p><h2>Corollaries</h2><p>The following corollaries follow from the above requirements:</p><ul><li>irreflexivity of <code>&lt;</code> and <code>&gt;</code>: <code>!(a &lt; a)</code>, <code>!(a &gt; a)</code></li><li>transitivity of <code>&gt;</code>: if <code>a &gt; b</code> and <code>b &gt; c</code> then <code>a &gt; c</code></li><li>duality of <code>partial_cmp</code>: <code>partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)</code></li></ul><h2>Strict and non-strict partial orders</h2><p>The <code>&lt;</code> and <code>&gt;</code> operators behave according to a <em>strict</em> partial order. However, <code>&lt;=</code> and <code>&gt;=</code> do <strong>not</strong> behave according to a <em>non-strict</em> partial order. That is because mathematically, a non-strict partial order would require reflexivity, i.e. <code>a &lt;= a</code> would need to be true for every <code>a</code>. This isn&#39;t always the case for types that implement <code>PartialOrd</code>, for example:</p><pre><code class="language-rune"><span class="source rust"><span class="storage type rust">let</span> a <span class="keyword operator rust">=</span> <span class="storage type rust">f64</span><span class="meta path rust"><span class="punctuation accessor rust">::</span></span>sqrt<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="keyword operator rust">-</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>a <span class="keyword operator rust">&lt;</span><span class="keyword operator rust">=</span> a<span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre><h2>How can I implement <code>PartialOrd</code>?</h2><p><code>PartialOrd</code> only requires implementation of the <a href="PartialOrd::partial_cmp"><code>PARTIAL_CMP</code></a> protocol, with the others generated from default implementations.</p><p>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, <code>NaN &lt; 0 == false</code> and <code>NaN &gt;= 0 == false</code> (cf. IEEE 754-2008 section 5.11).</p><p><code>PARTIAL_CMP</code> requires your type to be [<code>PARTIAL_EQ</code>].</p><p>If your type is [<code>ORD</code>], you can implement <a href="PartialOrd::partial_cmp"><code>PARTIAL_CMP</code></a> by using <a href="Ord::cmp"><code>CMP</code></a>.</p><p>You may also find it useful to use <a href="PartialOrd::partial_cmp"><code>PARTIAL_CMP</code></a> on your type&#39;s fields.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="storage type rust">let</span> x <span class="keyword operator rust">=</span> <span class="constant numeric integer decimal rust">0</span><span class="punctuation terminator rust">;</span>
<span class="storage type rust">let</span> y <span class="keyword operator rust">=</span> <span class="constant numeric integer decimal rust">1</span><span class="punctuation terminator rust">;</span>

<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>x <span class="keyword operator rust">&lt;</span> y<span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>x.<span class="support function rust">lt</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>y</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
            

            <h4 class="section-title">Methods</h4>
            
                <div class="item item-fn">
                    <div id="method.partial_cmp" class="item-title">
                    fn <a href="#method.partial_cmp" class="fn">partial_cmp</a>(value: <span class="any">any</span>, value1: <span class="any">any</span>) -&gt; <a class="enum" href="../option/Option.enum.html">Option</a>&lt;<a class="enum" href="Ordering.enum.html">Ordering</a>&gt;
                    
                    </div>
                    <div class="docs"><p>Compare two values.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">std<span class="punctuation accessor rust">::</span></span><span class="meta path rust">cmp<span class="punctuation accessor rust">::</span></span>Ordering<span class="punctuation terminator rust">;</span>

<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="support function rust">partial_cmp</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">2</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="support type rust">Some</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta path rust">Ordering<span class="punctuation accessor rust">::</span></span>Less</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="support function rust">partial_cmp</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">2</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="support type rust">Some</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta path rust">Ordering<span class="punctuation accessor rust">::</span></span>Equal</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="support function rust">partial_cmp</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric integer decimal rust">1</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="support type rust">Some</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta path rust">Ordering<span class="punctuation accessor rust">::</span></span>Greater</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.lt" class="item-title">
                    fn <a href="#method.lt" class="fn">lt</a>(value: <span class="any">any</span>, value1: <span class="any">any</span>) -&gt; <a class="type" href="../bool.type.html">bool</a>
                    
                    </div>
                    <div class="docs"><p>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&lt;</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&lt;</span> <span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&lt;</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.le" class="item-title">
                    fn <a href="#method.le" class="fn">le</a>(value: <span class="any">any</span>, value1: <span class="any">any</span>) -&gt; <a class="type" href="../bool.type.html">bool</a>
                    
                    </div>
                    <div class="docs"><p>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&lt;</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&lt;</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&lt;</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.gt" class="item-title">
                    fn <a href="#method.gt" class="fn">gt</a>(value: <span class="any">any</span>, value1: <span class="any">any</span>) -&gt; <a class="type" href="../bool.type.html">bool</a>
                    
                    </div>
                    <div class="docs"><p>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&gt;</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&gt;</span> <span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&gt;</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.ge" class="item-title">
                    fn <a href="#method.ge" class="fn">ge</a>(value: <span class="any">any</span>, value1: <span class="any">any</span>) -&gt; <a class="type" href="../bool.type.html">bool</a>
                    
                    </div>
                    <div class="docs"><p>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator.</p><h1>Examples</h1><pre><code class="language-rune"><span class="source rust"><span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&gt;</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&gt;</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">false</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
<span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="constant numeric float rust">2.</span><span class="constant numeric float rust">0</span> <span class="keyword operator rust">&gt;</span><span class="keyword operator rust">=</span> <span class="constant numeric float rust">1.</span><span class="constant numeric float rust">0</span><span class="punctuation separator rust">,</span> <span class="constant language rust">true</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>



        </div>
    </div>
</body>
