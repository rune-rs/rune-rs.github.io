<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/FiraSans-Medium-4ao_Crym_Z97hoxWqz7A4NshIi71DoT6u_IZY8EN1wQ.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/FiraSans-Regular-D-SK3tCXwqEZQqcL_vSFEKv4dajoAPQ9QAfc6NKjrr4.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/NanumBarunGothic-Regular-6_u5bM1Z_P691vS3fhfHDGxiAIyFL9cppAIAJVg151s.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceCodePro-It.ttf-9l14W6OSkW1dJiiKKavLd1_QdTHtv_Sl67HNQoWSu8g.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceCodePro-Regular-cU7uKbcNGR9b9LOga2jyxQUisTA9McfUTc79zF-d79A.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceCodePro-Semibold-SIsoBuinYZLCzu8ptJi6AeRraXV4sgDt4bXK2FXDebo.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceSerif4-Bold-_xCsH4HwyJAK__GCoff-x-hd_IB1y5MahmUNF4NgQsU.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceSerif4-Regular-KooC6dILCRRRWHXSr7KvGNFHM6ZZ054WggDt4WT32GU.woff2">
<link rel="stylesheet" type="text/css" href="../syntax-hOylezLDPQHh3rL4EpbplIubIPDrhPsdZ6NqLZXhtw8.css"><link rel="stylesheet" type="text/css" href="../runedoc-RpGnmLv54qA3EswoqjjtiCiSLHPpqlrooIFm2cj7ozI.css">
<script lang="text/javascript" src="../search-11hco3hjyxbot2LtE0-3TZtpn7blY_QZbxQ4j4EpDNE.js"></script>
<script lang="text/javascript" src="../index-G0mxehKGo9mL-fwWZsEUrCgtIk5GcrGnUq5u1fLfmwo.js"></script>
</head>
<body data-path="process">
    <div id="container">
        <div id="search">
            <div id="search-form">
                <input id="search-input" placeholder="Click to search..." type="text" />
            </div>

            <h3 id="search-title" class="hidden title">Results</h3>

            <div id="search-results" class="hidden"></div>
        </div>

        <div id="content">

            <div class="title-wrapper">
                <h3 class="title">Struct <a class="module" href="../process.module.html">process</a>::<span class="struct">Command</span></h3>
                <a class="overview" href="../index.html">Overview</a>
            </div>
            
<div class="docs"><p>This structure mimics the API of <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a> found in the standard library, but replaces functions that create a process with an asynchronous variant. The main provided asynchronous functions are <a href="Command::spawn">spawn</a>, <a href="Command::status">status</a>, and <a href="Command::output">output</a>.</p><p><code>Command</code> uses asynchronous versions of some <code>std</code> types (for example <a href="struct@Child"><code>Child</code></a>).</p></div>
            

            <h4 class="section-title">Methods</h4>
            
                <div class="item item-fn">
                    <div id="method.new" class="item-title">
                    fn <a href="#method.new" class="fn">new</a>(command: <a class="type" href="../std/string/String.type.html">String</a>) -&gt; <a class="struct" href="Command.struct.html">Command</a>
                    
                    </div>
                    <div class="docs"><p>Constructs a new <code>Command</code> for launching the program at path <code>program</code>, with the following default configuration:</p><ul><li>No arguments to the program</li><li>Inherit the current process&#39;s environment</li><li>Inherit the current process&#39;s working directory</li><li>Inherit stdin/stdout/stderr for <code>spawn</code> or <code>status</code>, but create pipes for <code>output</code></li></ul><p>Builder methods are provided to change these defaults and otherwise configure the process.</p><p>If <code>program</code> is not an absolute path, the <code>PATH</code> will be searched in an OS-defined way.</p><p>The search path to be used may be controlled by setting the <code>PATH</code> environment variable on the Command, but this has some implementation limitations on Windows (see issue <a href="https://github.com/rust-lang/rust/issues/37519">rust-lang/rust#37519</a>).</p><h1>Examples</h1><p>Basic usage:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span>Command<span class="punctuation terminator rust">;</span>
<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>sh<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.arg" class="item-title">
                    fn <a href="#method.arg" class="fn">arg</a>(<a class="struct" href="Command.struct.html">self</a>, arg: <a class="type" href="../std/string/String.type.html">String</a>)
                    
                    </div>
                    <div class="docs"><p>Adds an argument to pass to the program.</p><p>Only one argument can be passed per use. So instead of:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span>Command<span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>sh<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">arg</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>-C /path/to/repo<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre><p>usage would be:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span>Command<span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>sh<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">arg</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>-C<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">arg</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>/path/to/repo<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span></code></pre><p>To pass multiple arguments see <a href="method@Self::args"><code>args</code></a>.</p><h1>Examples</h1><p>Basic usage:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span>Command<span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>ls<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">arg</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>-l<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">arg</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>-a<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> output <span class="keyword operator rust">=</span> command.<span class="support function rust">output</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await<span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.args" class="item-title">
                    fn <a href="#method.args" class="fn">args</a>(<a class="struct" href="Command.struct.html">self</a>, args: <a class="struct" href="../std/vec/Vec.struct.html">Vec</a>)
                    
                    </div>
                    <div class="docs"><p>Adds multiple arguments to pass to the program.</p><p>To pass a single argument see <a href="method@Self::arg"><code>arg</code></a>.</p><h1>Examples</h1><p>Basic usage:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span>Command<span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>ls<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">args</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta group rust"><span class="punctuation section group begin rust">[</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>-l<span class="punctuation definition string end rust">&quot;</span></span><span class="punctuation separator rust">,</span> <span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>-a<span class="punctuation definition string end rust">&quot;</span></span><span class="punctuation section group end rust">]</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> output <span class="keyword operator rust">=</span> command.<span class="support function rust">output</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await<span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.arg0" class="item-title">
                    fn <a href="#method.arg0" class="fn">arg0</a>(<a class="struct" href="Command.struct.html">self</a>, arg: <a class="type" href="../std/string/String.type.html">String</a>)
                    
                    </div>
                    <div class="docs"><p>Sets executable argument.</p><p>Set the first process argument, <code>argv[0]</code>, to something other than the default executable path.</p></div>
                </div>
                <div class="item item-fn">
                    <div id="method.stdin" class="item-title">
                    fn <a href="#method.stdin" class="fn">stdin</a>(<a class="struct" href="Command.struct.html">self</a>, stdio: <a class="struct" href="Stdio.struct.html">Stdio</a>)
                    
                    </div>
                    <div class="docs"><p>Sets configuration for the child process&#39;s standard input (stdin) handle.</p><p>Defaults to <a href="process::Stdio::inherit"><code>inherit</code></a>.</p><h1>Examples</h1><p>Basic usage:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span><span class="meta block rust"><span class="punctuation section block begin rust">{</span>Command<span class="punctuation separator rust">,</span> Stdio</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>ls<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">stdin</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta path rust">Stdio<span class="punctuation accessor rust">::</span></span>null<span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> output <span class="keyword operator rust">=</span> command.<span class="support function rust">output</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await<span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.stdout" class="item-title">
                    fn <a href="#method.stdout" class="fn">stdout</a>(<a class="struct" href="Command.struct.html">self</a>, stdio: <a class="struct" href="Stdio.struct.html">Stdio</a>)
                    
                    </div>
                    <div class="docs"><p>Sets configuration for the child process&#39;s standard output (stdout) handle.</p><p>Defaults to <a href="process::Stdio::inherit"><code>inherit</code></a> when used with <code>spawn</code> or <code>status</code>, and defaults to <a href="process::Stdio::piped"><code>piped</code></a> when used with <code>output</code>.</p><h1>Examples</h1><p>Basic usage:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span><span class="meta block rust"><span class="punctuation section block begin rust">{</span>Command<span class="punctuation separator rust">,</span> Stdio</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>ls<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">stdout</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta path rust">Stdio<span class="punctuation accessor rust">::</span></span>null<span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> output <span class="keyword operator rust">=</span> command.<span class="support function rust">output</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await<span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.stderr" class="item-title">
                    fn <a href="#method.stderr" class="fn">stderr</a>(<a class="struct" href="Command.struct.html">self</a>, stdio: <a class="struct" href="Stdio.struct.html">Stdio</a>)
                    
                    </div>
                    <div class="docs"><p>Sets configuration for the child process&#39;s standard error (stderr) handle.</p><p>Defaults to <a href="process::Stdio::inherit"><code>inherit</code></a> when used with <code>spawn</code> or <code>status</code>, and defaults to <a href="process::Stdio::piped"><code>piped</code></a> when used with <code>output</code>.</p><h1>Examples</h1><p>Basic usage:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span><span class="meta block rust"><span class="punctuation section block begin rust">{</span>Command<span class="punctuation separator rust">,</span> Stdio</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>ls<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
command.<span class="support function rust">stderr</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta path rust">Stdio<span class="punctuation accessor rust">::</span></span>null<span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> output <span class="keyword operator rust">=</span> command.<span class="support function rust">output</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await<span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.kill_on_drop" class="item-title">
                    fn <a href="#method.kill_on_drop" class="fn">kill_on_drop</a>(<a class="struct" href="Command.struct.html">self</a>, kill_on_drop: <a class="type" href="../std/bool.type.html">bool</a>)
                    
                    </div>
                    <div class="docs"><p>Controls whether a <code>kill</code> operation should be invoked on a spawned child process when its corresponding <code>Child</code> handle is dropped.</p><p>By default, this value is assumed to be <code>false</code>, meaning the next spawned process will not be killed on drop, similar to the behavior of the standard library.</p><h1>Caveats</h1><p>On Unix platforms processes must be &quot;reaped&quot; by their parent process after they have exited in order to release all OS resources. A child process which has exited, but has not yet been reaped by its parent is considered a &quot;zombie&quot; process. Such processes continue to count against limits imposed by the system, and having too many zombie processes present can prevent additional processes from being spawned.</p><p>Although issuing a <code>kill</code> signal to the child process is a synchronous operation, the resulting zombie process cannot be <code>.await</code>ed inside of the destructor to avoid blocking other tasks. The tokio runtime will, on a best-effort basis, attempt to reap and clean up such processes in the background, but no additional guarantees are made with regard to how quickly or how often this procedure will take place.</p><p>If stronger guarantees are required, it is recommended to avoid dropping a <a href="Child.struct.html" title="struct Child"><code>Child</code></a> handle where possible, and instead utilize <code>child.wait().await</code> or <code>child.kill().await</code> where possible.</p></div>
                </div>
                <div class="item item-fn">
                    <div id="method.spawn" class="item-title">
                    fn <a href="#method.spawn" class="fn">spawn</a>(<a class="struct" href="Command.struct.html">self</a>) -&gt; <a class="enum" href="../std/result/Result.enum.html">Result</a>&lt;<a class="struct" href="Child.struct.html">Child</a>, <a class="type" href="../std/io/Error.type.html">Error</a>&gt;
                    
                    </div>
                    <div class="docs"><p>Executes the command as a child process, returning a handle to it.</p><p>By default, stdin, stdout and stderr are inherited from the parent.</p><p>This method will spawn the child process synchronously and return a handle to a future-aware child process. The <code>Child</code> returned implements <code>Future</code> itself to acquire the <code>ExitStatus</code> of the child, and otherwise the <code>Child</code> has methods to acquire handles to the stdin, stdout, and stderr streams.</p><p>All I/O this child does will be associated with the current default event loop.</p><h1>Examples</h1><p>Basic usage:</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span>Command<span class="punctuation terminator rust">;</span>

async <span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span> </span><span class="entity name function rust">run_ls</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span></span></span><span class="meta function rust"> </span><span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
   <span class="storage type rust">let</span> command <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>ls<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
   command.<span class="support function rust">spawn</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span>.<span class="support function rust">wait</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await<span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>
</span></code></pre><h1>Caveats</h1><h2>Dropping/Cancellation</h2><p>Similar to the behavior to the standard library, and unlike the futures paradigm of dropping-implies-cancellation, a spawned process will, by default, continue to execute even after the <code>Child</code> handle has been dropped.</p><p>The <a href="crate::process::Command::kill_on_drop"><code>Command::kill_on_drop</code></a> method can be used to modify this behavior and kill the child process if the <code>Child</code> wrapper is dropped before it has exited.</p><h2>Unix Processes</h2><p>On Unix platforms processes must be &quot;reaped&quot; by their parent process after they have exited in order to release all OS resources. A child process which has exited, but has not yet been reaped by its parent is considered a &quot;zombie&quot; process. Such processes continue to count against limits imposed by the system, and having too many zombie processes present can prevent additional processes from being spawned.</p><p>The tokio runtime will, on a best-effort basis, attempt to reap and clean up any process which it has spawned. No additional guarantees are made with regard to how quickly or how often this procedure will take place.</p><p>It is recommended to avoid dropping a <a href="crate::process::Child"><code>Child</code></a> process handle before it has been fully <code>await</code>ed if stricter cleanup guarantees are required.</p><h1>Errors</h1><p>On Unix platforms this method will fail with <code>std::io::ErrorKind::WouldBlock</code> if the system process limit is reached (which includes other applications running on the system).</p></div>
                </div>


            <h4 class="section-title">Protocols</h4>
            
                <div class="item item-fn">
                    <div id="protocol.DEBUG_FMT" class="item-title">
                    protocol <a href="#protocol.DEBUG_FMT" class="protocol">DEBUG_FMT</a> 
                    
                    </div>
                    <pre><code class="language-rune"><span class="source rust"><span class="support function rust">println</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>{:?}<span class="punctuation definition string end rust">&quot;</span></span><span class="punctuation separator rust">,</span> value</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>
</span></code></pre>
                    <div class="docs"><p>Allows the value to be debug printed.</p></div>
                </div>

        </div>
    </div>
</body>
