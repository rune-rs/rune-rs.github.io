<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/FiraSans-Medium-4ao_Crym_Z97hoxWqz7A4NshIi71DoT6u_IZY8EN1wQ.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/FiraSans-Regular-D-SK3tCXwqEZQqcL_vSFEKv4dajoAPQ9QAfc6NKjrr4.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/NanumBarunGothic-Regular-6_u5bM1Z_P691vS3fhfHDGxiAIyFL9cppAIAJVg151s.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceCodePro-It.ttf-9l14W6OSkW1dJiiKKavLd1_QdTHtv_Sl67HNQoWSu8g.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceCodePro-Regular-cU7uKbcNGR9b9LOga2jyxQUisTA9McfUTc79zF-d79A.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceCodePro-Semibold-SIsoBuinYZLCzu8ptJi6AeRraXV4sgDt4bXK2FXDebo.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceSerif4-Bold-_xCsH4HwyJAK__GCoff-x-hd_IB1y5MahmUNF4NgQsU.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../fonts/SourceSerif4-Regular-KooC6dILCRRRWHXSr7KvGNFHM6ZZ054WggDt4WT32GU.woff2">
<link rel="stylesheet" type="text/css" href="../syntax-hOylezLDPQHh3rL4EpbplIubIPDrhPsdZ6NqLZXhtw8.css"><link rel="stylesheet" type="text/css" href="../runedoc-RpGnmLv54qA3EswoqjjtiCiSLHPpqlrooIFm2cj7ozI.css">
<script lang="text/javascript" src="../search-11hco3hjyxbot2LtE0-3TZtpn7blY_QZbxQ4j4EpDNE.js"></script>
<script lang="text/javascript" src="../index-f-SvHwnfE2rDfWKEVpb4gXcfg-Gq5PzgQ2sOSBfA0Rs.js"></script>
</head>
<body data-path="process">
    <div id="container">
        <div id="search">
            <div id="search-form">
                <input id="search-input" placeholder="Click to search..." type="text" />
            </div>

            <h3 id="search-title" class="hidden title">Results</h3>

            <div id="search-results" class="hidden"></div>
        </div>

        <div id="content">

            <div class="title-wrapper">
                <h3 class="title">Struct <a class="module" href="../process.module.html">process</a>::<span class="struct">Child</span></h3>
                <a class="overview" href="../index.html">Overview</a>
            </div>
            
<div class="docs"><p>Representation of a child process spawned onto an event loop.</p><h1>Caveats</h1><p>Similar to the behavior to the standard library, and unlike the futures paradigm of dropping-implies-cancellation, a spawned process will, by default, continue to execute even after the <code>Child</code> handle has been dropped.</p><p>The <code>Command::kill_on_drop</code> method can be used to modify this behavior and kill the child process if the <code>Child</code> wrapper is dropped before it has exited.</p></div>
            

            <h4 class="section-title">Methods</h4>
            
                <div class="item item-fn">
                    <div id="method.stdin" class="item-title">
                    fn <a href="#method.stdin" class="fn">stdin</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/option/Option.enum.html">Option</a>&lt;<a class="struct" href="ChildStdin.struct.html">ChildStdin</a>&gt;
                    
                    </div>
                    <div class="docs"><p>The handle for writing to the child&#39;s standard input (stdin), if it has been captured. To avoid partially moving the <code>child</code> and thus blocking yourself from calling functions on <code>child</code> while using <code>stdin</code>, you might find it helpful to do:</p><pre><code class="language-rune"><span class="source rust"><span class="storage type rust">let</span> stdin <span class="keyword operator rust">=</span> child.<span class="support function rust">stdin</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.stdout" class="item-title">
                    fn <a href="#method.stdout" class="fn">stdout</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/option/Option.enum.html">Option</a>&lt;<a class="struct" href="ChildStdout.struct.html">ChildStdout</a>&gt;
                    
                    </div>
                    <div class="docs"><p>The handle for reading from the child&#39;s standard output (stdout), if it has been captured. You might find it helpful to do</p><pre><code class="language-rune"><span class="source rust"><span class="storage type rust">let</span> stdout <span class="keyword operator rust">=</span> child.stdout.<span class="support function rust">take</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre><p>to avoid partially moving the <code>child</code> and thus blocking yourself from calling functions on <code>child</code> while using <code>stdout</code>.</p></div>
                </div>
                <div class="item item-fn">
                    <div id="method.stderr" class="item-title">
                    fn <a href="#method.stderr" class="fn">stderr</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/option/Option.enum.html">Option</a>&lt;<a class="struct" href="ChildStderr.struct.html">ChildStderr</a>&gt;
                    
                    </div>
                    <div class="docs"><p>The handle for reading from the child&#39;s standard error (stderr), if it has been captured. You might find it helpful to do</p><pre><code class="language-rune"><span class="source rust"><span class="storage type rust">let</span> stderr <span class="keyword operator rust">=</span> child.<span class="support function rust">stderr</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre><p>to avoid partially moving the <code>child</code> and thus blocking yourself from calling functions on <code>child</code> while using <code>stderr</code>.</p></div>
                </div>
                <div class="item item-fn">
                    <div id="method.id" class="item-title">
                    fn <a href="#method.id" class="fn">id</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/option/Option.enum.html">Option</a>&lt;<a class="type" href="../std/u64.type.html">u64</a>&gt;
                    
                    </div>
                    <div class="docs"><p>Returns the OS-assigned process identifier associated with this child while it is still running.</p><p>Once the child has been polled to completion this will return <code>None</code>. This is done to avoid confusion on platforms like Unix where the OS identifier could be reused once the process has completed.</p></div>
                </div>
                <div class="item item-fn">
                    <div id="method.start_kill" class="item-title">
                    fn <a href="#method.start_kill" class="fn">start_kill</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/result/Result.enum.html">Result</a>&lt;(), <a class="type" href="../std/io/Error.type.html">Error</a>&gt;
                    
                    </div>
                    <div class="docs"><p>Attempts to force the child to exit, but does not wait for the request to take effect.</p><p>On Unix platforms, this is the equivalent to sending a <code>SIGKILL</code>. Note that on Unix platforms it is possible for a zombie process to remain after a kill is sent; to avoid this, the caller should ensure that either <code>child.wait().await</code> or <code>child.try_wait()</code> is invoked successfully.</p></div>
                </div>
                <div class="item item-fn">
                    <div id="method.kill" class="item-title">
                    <span class="async">async</span> fn <a href="#method.kill" class="fn">kill</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/result/Result.enum.html">Result</a>&lt;(), <a class="type" href="../std/io/Error.type.html">Error</a>&gt;
                    
                    </div>
                    <div class="docs"><p>Forces the child to exit.</p><p>This is equivalent to sending a <code>SIGKILL</code> on unix platforms.</p><p>If the child has to be killed remotely, it is possible to do it using a combination of the select! macro and a <code>oneshot</code> channel. In the following example, the child will run until completion unless a message is sent on the <code>oneshot</code> channel. If that happens, the child is killed immediately using the <code>.kill()</code> method.</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span>Command<span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> child <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>sleep<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
child.<span class="support function rust">arg</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>1<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> child <span class="keyword operator rust">=</span> child.<span class="support function rust">spawn</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> recv <span class="keyword operator rust">=</span> <span class="support function rust">wait_for_something</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

select <span class="meta block rust"><span class="punctuation section block begin rust">{</span>
   <span class="keyword operator rust">_</span> <span class="keyword operator rust">=</span> child.<span class="support function rust">wait</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=&gt;</span> <span class="meta block rust"><span class="punctuation section block begin rust">{</span></span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span>
   <span class="keyword operator rust">_</span> <span class="keyword operator rust">=</span> recv <span class="keyword operator rust">=&gt;</span> child.<span class="support function rust">kill</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await.<span class="support function rust">expect</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>kill failed<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.wait" class="item-title">
                    <span class="async">async</span> fn <a href="#method.wait" class="fn">wait</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/result/Result.enum.html">Result</a>&lt;<a class="struct" href="ExitStatus.struct.html">ExitStatus</a>, <a class="type" href="../std/io/Error.type.html">Error</a>&gt;
                    
                    </div>
                    <div class="docs"><p>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</p><p>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</p><p>If the caller wishes to explicitly control when the child&#39;s stdin handle is closed, they may <code>.take()</code> it before calling <code>.wait()</code>:</p><h1>Cancel safety</h1><p>This function is cancel safe.</p><pre><code class="language-rune"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">process<span class="punctuation accessor rust">::</span></span><span class="meta block rust"><span class="punctuation section block begin rust">{</span>Command<span class="punctuation separator rust">,</span> Stdio</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> child <span class="keyword operator rust">=</span> <span class="meta path rust">Command<span class="punctuation accessor rust">::</span></span>new<span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>cat<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
child.<span class="support function rust">stdin</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta path rust">Stdio<span class="punctuation accessor rust">::</span></span>piped<span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> child <span class="keyword operator rust">=</span> child.<span class="support function rust">spawn</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>

<span class="storage type rust">let</span> stdin <span class="keyword operator rust">=</span> child.<span class="support function rust">stdin</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>

<span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> wait for the process to complete
</span><span class="storage type rust">let</span> <span class="keyword operator rust">_</span> <span class="keyword operator rust">=</span> child.<span class="support function rust">wait</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.await<span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre></div>
                </div>
                <div class="item item-fn">
                    <div id="method.wait_with_output" class="item-title">
                    <span class="async">async</span> fn <a href="#method.wait_with_output" class="fn">wait_with_output</a>(<a class="struct" href="Child.struct.html">self</a>) -&gt; <a class="enum" href="../std/result/Result.enum.html">Result</a>&lt;<a class="struct" href="Output.struct.html">Output</a>, <a class="type" href="../std/io/Error.type.html">Error</a>&gt;
                    
                    </div>
                    <div class="docs"><p>Returns a future that will resolve to an <code>Output</code>, containing the exit status, stdout, and stderr of the child process.</p><p>The returned future will simultaneously waits for the child to exit and collect all remaining output on the stdout/stderr handles, returning an <code>Output</code> instance.</p><p>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</p><p>By default, stdin, stdout and stderr are inherited from the parent. In order to capture the output into this <code>Output</code> it is necessary to create new pipes between parent and child. Use <code>stdout(Stdio::piped())</code> or <code>stderr(Stdio::piped())</code>, respectively, when creating a <code>Command</code>.</p></div>
                </div>


            <h4 class="section-title">Protocols</h4>
            
                <div class="item item-fn">
                    <div id="protocol.DEBUG_FMT" class="item-title">
                    protocol <a href="#protocol.DEBUG_FMT" class="protocol">DEBUG_FMT</a> 
                    
                    </div>
                    <pre><code class="language-rune"><span class="source rust"><span class="support macro rust">format!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span><span class="constant other placeholder rust">{:?}</span><span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation separator rust">,</span> value<span class="punctuation section group end rust">)</span></span>
</span></code></pre>
                    <div class="docs"><p>Allows the value to be debug printed.</p></div>
                </div>

        </div>
    </div>
</body>
